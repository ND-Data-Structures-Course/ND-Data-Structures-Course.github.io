[
    {"ID":"Introduction to Programming Recap",
    "Title": "Introduction to Programming Recap",
     "Intro_text": "Computer programming is the process of writing code to facilitate specific actions in a computer, application or software program, and instructs them on how to perform. Computer programmers are professionals that create instructions for a computer to execute by writing and testing code that enables applications and software programs to operate successfully.",
     "Code":["#include <stdio.h>","int main() {","int n, i, flag = 0;", "printf(Enter a positive integer: );", "scanf('%d', &n);","if (n == 0 || n == 1);","{ flag = 1;", "for (i = 2; i <= n / 2; ++i) {","if (n % i == 0) {", " flag = 1;","break;"," }","}"],
     "Topic_title":"Concepts In Programming",
     "Body_text": [{"Title": "Abstractions and Data Structures", "Text":"Abstract data types and their implementation as data structures using object-oriented programming. Use ofobject-oriented principles in the selection and analysis of various ADT implementations. Sequential and linkedstorage representations: lists, stacks, queues, and tables. Nonlinear data structures: trees and graphs. Recursion,sorting, searching, and algorithm complexity."},{"Title": "Memory Allocation", "Text":"Memory allocation is the process of setting aside sections of memory in a program to be used to store variables, and instances of structures and classes. There are two basic types of memory allocation: When you declare a variable or an instance of a structure or class. Static Allocation occurs automatically and stores memory on the stack while Dynamic Allocation is done manually and uses the heap."},{"Title": "Memory Layout and C Pointers", "Text":"Basically, the memory layout of C program contains five segments these are the stack segment, heap segment, BSS (block started by symbol), DS (Data Segment) and text segment. Each segment has own read, write and executable permission. If a program tries to access the memory in a way that is not allowed then segmentation fault occurs.A segmentation fault is a common problem that causes programs to crash. A core file (core dumped file) also associated with a segmentation fault that is used by the developer to finding the root cause of the crashing (segmentation fault)."},{"Title": "Arrays", "Text":"Arrays a kind of data structure that can store a fixed-size sequential collection of elements of the same type. An array is used to store a collection of data, but it is often more useful to think of an array as a collection of variables of the same type.Instead of declaring individual variables, such as number0, number1, ..., and number99, you declare one array variable such as numbers and use numbers[0], numbers[1], and ..., numbers[99] to represent individual variables. A specific element in an array is accessed by an index.All arrays consist of contiguous memory locations. The lowest address corresponds to the first element and the highest address to the last element"}],
      "test_code":  ["#include <stdio.h>","int main {","int n, i, flag = 0;", "printf(Enter a positive integer: );", "scanf('%d', &n);","if (n == 0 || n == 1)"," flag = 1;", "for (i = 2; i <= n / 2; ++i) {","if (n % i == 0) {", " flag = 1;","break;","}","}"],
      "video": "https://www.youtube.com/"
},
    {"ID":"Unit 1 - Memory Layout, C Pointers, and Static and Dynamic Memory Allocation",
    "Title": "Unit 1 - Memory Layout, C Pointers, and Static and Dynamic Memory Allocation",
     "Intro_text": "When the allocation of memory performs at the compile time, then it is known as static memory. When the memory allocation is done at the execution or run time, then it is called dynamic memory allocation. 2. The memory is allocated at the compile time. The memory is allocated at the runtime.",
     "Code": ["#include <stdio.h>","char c[]='Data Structures';","Segment in read-write area*/", "const char s[]='HackerEarth'; ","Segment in read-only area*/","int main()","{","static int i=11;                     /* static variable stored in Initialized Data Segment*/","return 0;", "}"],
     "Topic_title":"More About Memory and C Pointers",
      "Body_text": [{"Title": "What is Memory Allocation?", "Text":"Memory allocation is primarily a computer hardware operation but is managed through operating system and software applications. Memory allocation process is quite similar in physical and virtual memory management. Programs and services are assigned with a specific memory as per their requirements when they are executed. Once the program has finished its operation or is idle, the memory is released and allocated to another program or merged within the primary memory. "},{"Title": "Static Allocation", "Text":"In Static Memory Allocation the memory for your data is allocated when the program starts. The size is fixed when the program is created. It applies to global variables, file scope variables, and variables qualified with static defined inside functions. This memory allocation is fixed and cannot be changed, i.e. increased or decreased after allocation. So, exact memory requirements must be known in advance.Deletion of memory allocated to a program is as important as allocation otherwise it results in memory leakage. Statically allocated memory is automatically released on the basis of scope, i.e., as soon as the scope of the variable is over, memory allocated get freed."},{"Title": "Dynamic Allocation", "Text":"Dynamic memory allocation is when an executing program requests that the operating system give it a block of main memory. The program then uses this memory for some purpose. Usually the purpose is to add a node to a data structure. In object oriented languages, dynamic memory allocation is used to get the memory for a new object.The memory comes from above the static part of the data segment. Programs may request memory and may also return previously dynamically allocated memory. Memory may be returned whenever it is no longer needed. Memory can be returned in any order without any relation to the order in which it was allocated. The heap may develop 'holes' where previously allocated memory has been returned between blocks of memory still in use.A new dynamic request for memory might return a range of addresses out of one of the holes. But it might not use up all the hole, so further dynamic requests might be satisfied out of the original hole.If too many small holes develop, memory is wasted because the total memory used by the holes may be large, but the holes cannot be used to satisfy dynamic requests. This situation is called memory fragmentation. Keeping track of allocated and deallocated memory is complicated. A modern operating system does all this."},{"Title": "Memory Tradeoffs", "Text":"In global scope statically allocated memory is built into the binary image. That is the total size of the memory required, and where it is to be located in the running binary is computed at compile time. Then when the program loads the operating system loader will allocate enough memory for all the global static arrays. I'm pretty sure it happens in constant time for all the allocations. ( e.g. more allocations don't cost more time ) In local scope, static allocations are allocated on the stack. This involves simply reserving a fixed number of bytes on the stack, and happens in constant time per allocation. Stack space is very limited.Dynamic memory must be allocated from a heap, and even in the best case most allocations will take time that scales more than linear with each allocation, like n log n time or something.Also practically speaking the dynamic allocation will be many times slower than static allocation."}],
      "test_code":  ["#include <stdio.h>","char c[]='Data Structures';","Segment in read-write area*/", "const char s[]='HackerEarth'; ","Segment in read-only area*/","int main()","{","static  i=11;                     /* static variable stored in Initialized Data Segment*/","return 0;", "}"],
      "video": "https://www.youtube.com/"
},

{"ID":"recursion",
    "Title": "Recursion and Dynamic Programming",
    "Intro_text":"Many Data Structures used in programming today are strengthened by the use of Recursion. For example, it's more efficient to use recursion to traverse trees and sort lists. While it is useful in many places, it is also one of the things most programmers struggle with, especially at university. So let's try to decrypt what it means.",
    "Code":["unsigned int factorial(unsigned int i){","if(i == 0) return 1; // base case","return i * factorial(i-1); // recursive call", "}"],
    "Topic_title":"Recursion and Dynamic Programming",
    "Body_text":[{"Title":"What is Recursion", "Text":"Definition: Recursion is the process of a function / algorithm calling itself one or more times until a specific condition is met after which it repeats the process from last to first. So if it is such a complicated topic, why do we need to learn it? Here are the advantages and disadvantages of recursion: Advantages: Recursion is simpler to program in some cases. Implementation and exploration of Binary Trees, Sorting Algorithms is easier and more efficient with recursion. Disadvantages: Every recursive call is saved to the stack (hence, there is a limit). This leads to a potential for a stack overflow. So how does Recursion work? Well, the program calls itself using something called a ‘Recursive Step’. This step calls the function itself with a different subset each time until something called a ‘Base Case’. A base case is the cut off value for the code to realize it has reached the end of the required logic and now needs to run the code in reverse order (aka recurse through it)."},{"Title":"Introduction to Dynamic Programming", "Text":"One issue with Recursion is its computationally redundant! For example, trying to find the fibonacci for 10, you would end up making 177 recursive calls!!!!! So if this is true, why should we use recursion when we can just use while loops? Well, this is where Dynamic Programming comes in. We can use it along with a concept called memoization to write more effective codes.Definition: Dynamic Programming combines the correctness of complete search and the efficiency of greedy algorithms.Definition: Memoization is the process of creating a lookup table of calculations which a code can refer to in order to speed up processing.So basically, in order to be more efficient, the code stores the results of previous computations and uses those values instead of recalculating everything. Such problems are useful when trying to maintain a count of some kind."}],
    "test_code":["#include <stdio.h>", "#include <stdlib.h>", "double factorial( int fact_num ){", "    if( fact_num == 1 )", "         return 1;","    return (double)fact_num * factorial( fact_num - 1 );", "}", "int main( const int argc, const char* argv[] ){", "    if( argc != 2 ){", "        fprintf( stderr, \"Incorrect Number of inputs\\n\" );", "      return EXIT_FAILURE;", "    }", "    int fact_num = atoi( argv[1] );", "     fprintf( stdout, \"%d! = %lf\\n\", fact_num, factorial( fact_num ) );","    return EXIT_SUCCESS;", "}"],
    "video": "https://www.youtube.com/"
}
]