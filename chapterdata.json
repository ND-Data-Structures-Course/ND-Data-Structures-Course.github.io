[
    
    {"unique_id":"1-1","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},
    {"unique_id":"1-2","content":[
        {"type":"subtitle","info":"Section 2.1 - Writing and Compiling Basic Programs"},
        {"type":"text","info":"A challenge many students have when beginning the Data Structures course is that they struggle with the idea that the computer is actually a physical machine, and not a nebulous device where magically fairies fight pointer demons. The first part of the course will drive home the idea that we must learn structure before we can master the use of data. "},
        {"type":"text","info":"So we will start with a seemingly simple piece of code:"},
        {"type":"code","info":"https://raw.githubusercontent.com/mmorri22/sp22-cse-20312/main/Lec02_Reading/nothing.c"},
        {"type":"text","info":"This piece of code takes in no inputs, (seemingly) performs no tasks, and then returns nothing on the output. However, C is a brace procedure language, meaning that tasks are divided up by using braces."},
        {"type":"text","info":"Consider the TV show Avatar: The Last Airbender. For those of you not familiar with the show, the Avatar confronts a character named King Bumi. Bumi appears to have allowed the Fire Nation to conquer his city without a fight. However, Bumi uses this as an opportunity to teach the Avatar about options in fighting. Bumi actually elected to do nothing until the time was right, which allowed him to attack from the inside. A computer is very much the same way: you must first learn that you need act on inputs or deliver the expected outputs, you need to know that they are. So you must learn to code nothing before you can learn to code something."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=e8f33aad-b1e0-4b1e-a363-ae1301491289&start=11.653175"}
        ]},

    {"unique_id":"2-1","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},
    {"unique_id":"2-2","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},
    {"unique_id":"2-3","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},
    {"unique_id":"2-4","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},

    {"unique_id":"3-1","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},
    {"unique_id":"3-2","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},
    {"unique_id":"3-3","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},

    {"unique_id":"4-1","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},
    {"unique_id":"4-2","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},

    {"unique_id":"5-1","content":[
        {"type":"subtitle","info":"Section 17.1 - Introduction to Graphs"},
        {"type":"subtitle","info":"Graphs: The Problem that Drives Modern Computing"},
        {"type":"text","info":"The Association of Computing Machinery is the global scientific and educational organization dedicated to advancing the art, science, engineering, and application of computing. (ACM Student Memberships are valuable in obtaining jobs, and particularly helpful in getting into Grad School.)"},
        {"type":"text","info":"Recently, the Communications of the ACM - the top ACM journal - ran the following headline \"The Future is Big Graphs\". As the growth of interconnected data explodes, we need students who understand the importance of graph processing, including memory management, processing efficiency, and reliability."},
        {"type":"text","info":"Graphs are also useful to study at this point in the semester because they are a strong \"2/3rds Capstone.\" To fully understand graphs, you will need to employ the following concepts you've learned so far in this course:"},
        {"type":"text","info":"- Pointers and Memory Allocations, which are extension of tree data structures."},
        {"type":"text","info":"- C++ Structs and Standard Template Libraries for Graph Abstraction"},
        {"type":"text","info":"- Vectors for Storing Node Locations in a Adjacency List"},
        {"type":"text","info":"- Complete Search and Recursion for Graph Traversals"},
        {"type":"text","info":"- Stacks - and by extension, Singly Linked Lists - for Depth-First Search"},
        {"type":"text","info":"- Queues - and by extension, Doubly Linked Lists - for Breadth-First Search"},
        {"type":"text","info":"- Priority Queues - and by extension, Heaps - for Shortest Path Algorithms"},
        {"type":"text","info":"Because graphs serve as an excellent review of material covered to this point, students often find that a previous concept they struggled with will \"click\" during this set of lectures."},
        {"type":"text","info":"- This is an example of why the Exam Clobbering Policy is pedagogically consistent with the Mission of Notre Dame. Because you can grow throughout the course of the semester, the policy will ensure that my final grade evaluation is more aligned with your growth during the semester, as opposed to allowing one Exam to drag down your overall score."},
        {"type":"subtitle","info":"Brute Force vs. Complete Search vs. Algorithmic Approaches"},
        {"type":"text","info":"Consider this common puzzle: Can you trace every line in this graph without lifting your pencil?"},
        {"type":"text","info":"- How would you go about this problem?"},
        {"type":"text","info":"- What techniques would you use to figure this out?"},
        {"type":"text","info":"Our first attempt: Brute Force"},
        {"type":"text","info":"In the video below, I show an attempt where I keep trying approaches and see if they work."},
        {"type":"text","info":"- Little-to-no technique"},
        {"type":"text","info":"- No guarantee you will find the solution"},
        {"type":"text","info":"- Even if one exists!"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=088dbe7d-c8b8-44bd-8819-ae4901046b7f"},
        {"type":"subtitle","info":"Complete Search"},
        {"type":"text","info":"In the next video, I show how we would apply a Complete Search to solving the problem. As we have previously studied, Complete Search will exhaustively determine a solution. However, these solutions may be computationally expensive. As graph sizes grow significantly, we will see the benefit of \"pruning the search tree\", like we did in the N-Queens Problem."},
        {"type":"text","info":"- Optional Growth Opportunity - After you study these graph algorithms in Lectures 17-19, it is common for a student to revisit the N-Queens problem we studied in Reading 13.3 and understand the concept much more clearly."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=5569e1dc-52ac-412a-b324-ae49010f35cb"},
        {"type":"subtitle","info":"Algorithmic: Bridges of Koningsberg Problem"},
        {"type":"text","info":"In 1786, Leohnard Euler was commissioned to solve the “Seven Bridges of Konigsberg” problem"},
        {"type":"text","info":"- Does there exist a route that allowed a person to cross all seven bridges in Konigsberg without crossing any bridge twice?"},
        {"type":"text","info":"- To this point, Everyone else is trying the Greedy approach"},
        {"type":"text","info":"- A Google Maps drawing of the 7 Bridges is shown below"},
        {"type":"text","info":"Euler realized that where a person starts is irrelevant to the solution! He translated the islands and bridges into locations"},
        {"type":"text","info":"- Locations are Nodes (in graph theory, nodes are more commonly referred to a Vertices)"},
        {"type":"text","info":"- Bridges are Edges"},
        {"type":"text","info":"Then, Euler combined common nodes into one node with several incoming and outgoing edges. Consider the diagram below:"},
        {"type":"text","info":"- 1, 7, and 8 on the left are the same island"},
        {"type":"text","info":"-> Combined into Node 1 on the right"},
        {"type":"text","info":"- 4, 5, and 6 on the left are the same island"},
        {"type":"text","info":"-> Combined into Node 3 on the right"},
        {"type":"text","info":"He also realized that, to get to an island, you can do one of three things:"},
        {"type":"text","info":"- Leave and never come back"},
        {"type":"text","info":"- Reach the island and leave the island"},
        {"type":"text","info":"- Arrive to the island, which is where you finish"},
        {"type":"text","info":"Therefore, he realized that if two nodes have an odd number of bridges and the rest have an even number, then the problem is solvable."},
        {"type":"text","info":"- Since more than two nodes have an odd number of bridges, the problem is not solvable!"},
        {"type":"text","info":"- Optional: From Wikipedia: Two of the seven original bridges did not survive the bombing of Königsberg in World War II. Two others were later demolished and replaced by a modern highway. The three other bridges remain, although only two of them are from Euler's time (one was rebuilt in 1935). Thus, as of 2021, five bridges exist at the same sites that were involved in Euler's problem. In terms of graph theory, two of the nodes now have degree 2, and the other two have degree 3. Therefore, an Eulerian path is now possible, but it must begin on one island and end on the other."},
        {"type":"text","info":"So now let's apply this logic to our puzzle from above:"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=5d142cad-8002-40a1-abd1-ae4901170fcf"},
        {"type":"text","info":"As we learned in the Complete Search discussion, algorithms should scale to much larger problems. In this case, the solution to the bridges of Koningsberg and the original maze puzzle scales to a more-complicated version of the puzzle."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=35986580-203f-421f-befd-ae49011b6654"},
        {"type":"text","info":"In the next section, we will build the foundations of a graph data structure."},
        {"type":"text","info":"Optional: A significant challenge in modern computing - all the way from determine a proper silicon layout of a chip device all the way to mapping the human genome - is determining a Hamiltonian Cycle of a graph, which is finding a path through an undirected or directed graph that visits each vertex exactly once."},
        {"type":"text","info":"Lecture 17 Introduction Question 1: What are the three approaches to solving Computing problems discussed in Section 17.1"},
        {"type":"text","info":"Lecture 17 Introduction Question 2: What are the major components of a Graph, and how did construction a graph in this manner help Euler solve the Bridges of Koningsberg problem?"},
        {"type":"subtitle","info":"17.2 - Building Edges and Vertices for a Graph Data Structure"},
        {"type":"subtitle","info":"Understanding \"Data\" and \"Structure\" in a Graph"},
        {"type":"text","info":"A graph is an abstract data type"},
        {"type":"text","info":"- Must define the vertex's location in the graph"},
        {"type":"text","info":"Must define the data it contains."},
        {"type":"text","info":"Consider the graph below. We have node locations highlighted in red, and the data contained in their locations inside the vertex. Understanding this difference, while seemingly intuitive, is a common issue when students start studying graphs. Just like an array, linked list, queue, stack, ect., the difference between data and structure is essential to implementing an effective graph:"},
        {"type":"text","info":"- Location of the array element on the heap is ( (char *)array + 1 )"},
        {"type":"text","info":"- De-referenced data of the array element is *( (char *)array + 1 )"},
        {"type":"text","info":"So how can we represent this difference? First we use an Edge struct to represent adjacency, which is a property of graphs where two vertices are connected by an edge."},
        {"type":"subtitle","info":"Representing an Edge"},
        {"type":"text","info":"In the code presented below, we will represent an edge as a C++ struct with public members. We will do this to reduce coding complexity within the Vertex struct and the Graph struct. We have the destination of the edge, as well as the edge's weight."},
        {"type":"text","info":"- Note: In the Algorithms course, you will study advanced graphs with negative edge weights. To set you up for success in that course, we will define the edge weight as a signed integer. However, we will only investigate graphs with positive edge weights in the course."},
        {"type":"text","info":"We will also introduce our first C++ operator. An operator is a method we can use to perform tasks with objects we have created. For example, we have defined an operator== which allows us to compare the weight of an edge, and return true/false. Instead of having to write methods that pass the weight to the user and then requiring the user to call and compare, we can reduce the coding complexity by allowing the programmer to simply call == on two edges."},
        {"type":"text","info":"- The format for the C++ operator for == is bolded and highlighted in maroon in the Code Example below, which also may be found at Edge.h"},
        {"type":"code","info":"https://raw.githubusercontent.com/mmorri22/sp22-cse-20312/main/Lec17_Reading/include/Edge.h"},
        {"type":"subtitle","info":"Adjacency List vs Adjacency Matrix"},
        {"type":"text","info":"The first approach is to represent each vertex as a cell in a vector, and each vertex contains a list of outgoing edges. This is known as an Adjacency List."},
        {"type":"text","info":"- Space-efficient, when G is sparse, meaning the number of edges between vertices are small."},
        {"type":"text","info":"- Easy modification for variants."},
        {"type":"text","info":"However, the adjacency list has some disadvantages"},
        {"type":"text","info":"- Determining whether an edge exists between two vertices requires a search through all the outgoing edges from both nodes"},
        {"type":"text","info":"The diagram below shows our initial graph, as well as the corresponding Adjacency List."},
        {"type":"text","info":"The second approach is to represent each vertex as an n by n matrix, where he outgoing edge and weight are represented in each cell. This is known as an Adjacency Matrix."},
        {"type":"text","info":"- Can immediately find whether an edge exists between two vertices in O(1) time."},
        {"type":"text","info":"- Space: O(V2)."},
        {"type":"text","info":"- Not memory efficient for large graphs. Worse for sparse graphs."},
        {"type":"text","info":"The diagram below shows our initial graph, as well as the corresponding Adjacency Matrix. For simplicity at this stage, we assume all edge weights are equal to 1."},
        {"type":"text","info":"Design Choice: Because of the relative simplicity to implement, as well as lower memory overhead and reinforcement of previous course concepts, we will be implementing an adjacency list representation of a graph in this course."},
        {"type":"subtitle","info":"Representing a Vertex"},
        {"type":"text","info":"Next, we will design a vertex struct which will be used in the entire Vertex struct we will present below is available at Vertex.h"},
        {"type":"text","info":"Constructors and Destructor"},
        {"type":"text","info":"In the Vertex, we will have three private members,"},
        {"type":"text","info":"- a VECTOR of Edges to represent the outgoing edges."},
        {"type":"text","info":"- The data element itself"},
        {"type":"text","info":"- A boolean to represent whether the boolean is valid."},
        {"type":"text","info":"Why do you think we need that boolean? Take a moment to consider, and the solution is after the presented code. (Hint: Think Hash deletion)"},
        {"type":"text","info":"template<class T>"},
        {"type":"text","info":"class Vertex{"},
        {"type":"text","info":"     private:"},
        {"type":"text","info":"         VECTOR< Edge > edges;"},
        {"type":"text","info":"         T data;"},
        {"type":"text","info":"         bool valid; // Valid Vertex"},
        {"type":"text","info":"The reason we keep track of a boolean is that, just like a Hash Table, the values inserted rely on the index of the previous values. If we delete an element from the vector, then all of the edge locations after that deleted element are now off by one. We will see later that we will mark the vertex as invalid and then delete all the outgoing and incoming edges in the Graph."},
        {"type":"text","info":"Next, we create a default constructor for no data value input, and an overloaded constructor where we have a data value. For the destructor, we leave it empty, and the destructor will automatically call the destructor in std::vector Standard Template Library."},
        {"type":"text","info":"Vertex( ) : edges(), data( ), valid( true ) {}"},
        {"type":"text","info":"Vertex( const T& dataIn ) : edges(), data( dataIn ), valid( true ) {}"},
        {"type":"text","info":"~Vertex(){ }"},
        {"type":"text","info":"Next, we will create methods to get and set the vertex data value. These methods are also presented to help review the use of const in C++ methods and Call by Reference."},
        {"type":"text","info":"- Remember that any method in a C++ struct that does not change a private member should be labeled as const"},
        {"type":"text","info":"- Remember that we call by reference in the event the templated type is significantly larger than an int, as it often will be in graphs. The call be reference reduces the memory by creating a pointer to the original object instead of making a copy."},
        {"type":"text","info":"- The const in set_vertex_value allows us to create an object directly in the method call without having to save to an intermediate register."},
        {"type":"text","info":"T get_vertex_value() const{"},
        {"type":"text","info":"     return data;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"void set_vertex_value(const T& dataIn){"},
        {"type":"text","info":"     data = dataIn;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"In the method add_edge, we will pass the destination index and the weight, and then call the Edge constructor in the push_back method"},
        {"type":"text","info":"- Calling the constructor in push_back is an example of why we use const T& in the templated type."},
        {"type":"text","info":"- Notice in the C++ STL that the call for push_back is void push_back( const value_type& val ) for this exact reason"},
        {"type":"text","info":"- Since unsigned ints and ints are smaller than the 64 bit pointer, I pass by value since the memory is lower."},
        {"type":"text","info":"void add_edge( unsigned int destin, int weight ){"},
        {"type":"text","info":"     // If not, put the edge on the back of the array"},
        {"type":"text","info":"     edges.push_back( Edge(destin, weight) );"},
        {"type":"text","info":"}"},
        {"type":"text","info":"In the method get_edge_value, we use call by reference to return the weight, and a bool to check if the edge exists in the graph. Since this is an adjacency list representation, we must iterate through all the edges and compare destin with the value in the edge."},
        {"type":"text","info":"In the if-statement where we determine if the element is true, we set edgeFound to true, and then update weight to return with the call by reference"},
        {"type":"text","info":"The boolean allows us to tell the user if the edge does not exist, meaning we do not implement the resulting code, allowing us to employ the graph cleanly and safely."},
        {"type":"text","info":"// Pass the destination, return weight with call be reference, bool if found"},
        {"type":"text","info":"bool get_edge_value( unsigned int destin, int& weight ) const{"},
        {"type":"text","info":"     bool edgeFound = false;"},
        {"type":"text","info":"     for( unsigned int i = 0; i < edges.size(); i++){"},
        {"type":"text","info":"         if( edges[i].destin == destin ){"},
        {"type":"text","info":"             edgeFound = true;"},
        {"type":"text","info":"             weight = edges[i].weight;"},
        {"type":"text","info":"         }"},
        {"type":"text","info":"     }"},
        {"type":"text","info":"     return edgeFound;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"We have two more crucial methods, which involve deletion for the edge and for the vertex. For the edge, we need to find the destination in the outgoing edge, and then call the std::vector erase method. Just like with the other methods, we use a boolean to return to the user whether the requested edge was found and deleted:"},
        {"type":"text","info":"bool remove_edge( unsigned int edgeLoc ){"},
        {"type":"text","info":"     bool deleted = false;"},
        {"type":"text","info":"     for(unsigned int i = 0; i < edges.size(); i++){"},
        {"type":"text","info":"         if( edges[i].destin == edgeLoc ){"},
        {"type":"text","info":"             edges.erase( edges.begin() + i);"},
        {"type":"text","info":"             deleted = true;"},
        {"type":"text","info":"             break;"},
        {"type":"text","info":"         }"},
        {"type":"text","info":"     }"},
        {"type":"text","info":"     return deleted;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"Finally, for marking the vertex as deleted, and then we delete all the outgoing edges"},
        {"type":"text","info":"void lazy_delete(){"},
        {"type":"text","info":"     valid = false;"},
        {"type":"text","info":"     while( edges.size() > 0 ){"},
        {"type":"text","info":"         // Remove the front edge"},
        {"type":"text","info":"         edges.erase( edges.begin() );"},
        {"type":"text","info":"     }"},
        {"type":"text","info":"}"},
        {"type":"text","info":"In the code testVert2.cpp, we create a Graph where the data are std::string values that represent the banks and islands in the Bridges of Koningsberg problem."},
        {"type":"text","info":"- The printout format for the edges is { destination, weight }"},
        {"type":"text","info":"- We also delete the edge going from 2 -> 1 and then print the vertices again."},
        {"type":"text","info":"- We are able to perform all these tasks and pass valgrind."},
        {"type":"text","info":"-bash-4.2$ make testVert2"},
        {"type":"text","info":"g++ -m64 -std=c++11 -O2 -g -Wall -Wextra -Wconversion -Wshadow -Werror -c src/testVert2.cpp -o objects/testVert2.o"},
        {"type":"text","info":"g++ -m64 -std=c++11 -O2 -g -Wall -Wextra -Wconversion -Wshadow -Werror -o exe/testVert2 objects/testVert2.o"},
        {"type":"text","info":"-bash-4.2$ valgrind --leak-check=full exe/./testVert2"},
        {"type":"text","info":"==12470== Memcheck, a memory error detector"},
        {"type":"text","info":"==12470== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al."},
        {"type":"text","info":"==12470== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info"},
        {"type":"text","info":"==12470== Command: exe/./testVert2"},
        {"type":"text","info":"==12470=="},
        {"type":"text","info":"0: [Top River Bank: {1, 1} {1, 1} {3, 1} ]"},
        {"type":"text","info":"1: [Left Island: {0, 1} {0, 1} {2, 1} {2, 1} {3, 1} {1, 1} ]"},
        {"type":"text","info":"2: [Bottom River Bank: {1, 1} {3, 1} ]"},
        {"type":"text","info":"3: [Right Island: {2, 1} {0, 1} ]"},
        {"type":"text","info":"Deleting Edge {2, 1} from Graph"},
        {"type":"text","info":"0: [Top River Bank: {1, 1} {1, 1} {3, 1} ]"},
        {"type":"text","info":"1: [Left Island: {0, 1} {0, 1} {2, 1} {3, 1} {1, 1} ]"},
        {"type":"text","info":"2: [Bottom River Bank: {1, 1} ]"},
        {"type":"text","info":"3: [Right Island: {2, 1} {0, 1} ]"},
        {"type":"text","info":"==12470=="},
        {"type":"text","info":"==12470== HEAP SUMMARY:"},
        {"type":"text","info":"==12470== in use at exit: 0 bytes in 0 blocks "},
        {"type":"text","info":"==12470== total heap usage: 18 allocs, 18 frees, 658 bytes allocated"},
        {"type":"text","info":"==12470=="},
        {"type":"text","info":"==12470== All heap blocks were freed -- no leaks are possible"},
        {"type":"text","info":"==12470=="},
        {"type":"text","info":"==12470== For lists of detected and suppressed errors, rerun with: -s"},
        {"type":"text","info":"==12470== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)"},
        {"type":"text","info":"Lecture 17 Introduction Question 3: What are the differences between an adjacency list and an adjacency matrix?"},
        {"type":"text","info":"Lecture 17 Introduction Question 4: How do we implement an Edge and a Vertex in an Adjacency List Representation of a Graph?"},
        {"type":"subtitle","info":"Reading 17.3 - Making the Graph Data Structure"},
        {"type":"subtitle","info":"Creating the Graph Struct"},
        {"type":"text","info":"In the file Graph.h, we will create the vector of vertices to represent the Adjacency List."},
        {"type":"text","info":"template< typename T > struct Graph{ private: VECTOR< Vertex< T > > vertices;    // Adjacency List public: // Constructor Graph( ) : vertices() {} // Destructor ~Graph( ) { }"},
        {"type":"text","info":"Next, we will create methods to add an initial vertex as well as an edge to the Graph using our previously defined Edge and Vertex methods. Notice how, in the Graph add_edge method, I check the origin and destination to ensure the locations are valid, and then we call add_edge from the Vertex."},
        {"type":"text","info":"// Add a vertex prior to any edges void add_vertex( const T& vertexData ){ Vertex<T> theVertex( vertexData ); vertices.push_back( theVertex ); } // Add Edge from Origin to Destination, with weight void add_edge(unsigned int origin, unsigned int destin, int weight ){ if( origin < vertices.size() && destin < vertices.size() ){vertices[origin].add_edge( destin, weight );}}"},
        {"type":"text","info":"We implemented the follow methods that use the same approach as vertex, except we go to the index indicated by the vertex value"},
        {"type":"text","info":"bool get_vertex_value( const unsigned int vertex, T& value )"},
        {"type":"text","info":"bool set_vertex_value( const unsigned int vertex, T& value )"},
        {"type":"text","info":"bool get_edge_value( const unsigned int origin, const unsigned int destin, int& weight)"},
        {"type":"text","info":"bool set_edge_value( const unsigned int origin, const unsigned int destin, const int weight)"},
        {"type":"text","info":"To delete an edge at the Graph level, we need the origin (to find it in the Adjacency List vector) and the destination (to find it in the list of outgoing edges). Notice how we still use the bool to ensure safe operation by informing the user whether the edge was actually deleted r not"},
        {"type":"text","info":"bool remove_edge( unsigned int origin, unsigned int destin){ // If the origin and destination are valid if( origin < vertices.size() && destin < vertices.size() ){ // From the Origin vertex, remove the destination vertex return vertices[origin].remove_edge( destin ); } return false;}"},
        {"type":"text","info":"Finally, for deleting a vertex, we mark the element at the index as deleted. Then, we iterate through all the other vertices and remove outgoing edges that point to the marked vertex. This allows us to reduce memory overhead consumed by edges going to a vertex that is no longer part of the graph while simultaneously allowing us to preserve the original location of all the edges, preventing indexing errors throughout the graph."},
        {"type":"text","info":"void remove_vertex( unsigned int vertVal ){ // First, perform Lazy Deletion on the vertex vertices[ vertVal ].lazy_delete(); // Next, go through each vertex and remove all edges with the destination to the vertex for( unsigned int iter = 0; iter < vertices.size(); iter++ ){ int jter = 0; // While the increment is less than the number of edges while( jter < vertices[iter].num_edges() ){ // If the destination of the edge is the vertex we are removing if( vertices[iter].get_edge( jter ).destin == vertVal ){ // Remove that edge vertices[iter].remove_edge( vertVal ); } else{ // Only increment jter is there is not any deletion jter++; } } } }"},
        {"type":"text","info":"In the file testGraph1.cpp (Links to an external site.), we test a robust Graph test where we insert, remove, and print elements. Notice how we tested the graph at various stages, include the edges, vertices, and then the final Graph. This design process will serve you well as a Computer Scientist or Computer Engineer, because modularity in design reduces coding and testing complexity."},
        {"type":"text","info":"-bash-4.2$ make testGraph1 g++ -m64 -std=c++11 -O2 -g -Wall -Wextra -Wconversion -Wshadow -Werror -c src/testGraph1.cpp -o objects/testGraph1.o g++ -m64 -std=c++11 -O2 -g -Wall -Wextra -Wconversion -Wshadow -Werror -o exe/testGraph1 objects/testGraph1.o -bash-4.2$ valgrind --leak-check=full exe/./testGraph1 ==30408== Memcheck, a memory error detector ==30408== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al. ==30408== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info ==30408== Command: exe/./testGraph1 ==30408== 0: [Top River Bank: {1, 1} {1, 1} {3, 1} ] 1: [Left Island: {0, 1} {0, 1} {2, 1} {2, 1} {3, 1} ] 2: [Bottom River Bank: {1, 1} {1, 1} {3, 1} ] 3: [Right Island: {2, 1} {0, 1} ] ==30408== ==30408== HEAP SUMMARY: ==30408== in use at exit: 0 bytes in 0 blocks ==30408== total heap usage: 19 allocs, 19 frees, 690 bytes allocated ==30408== ==30408== All heap blocks were freed -- no leaks are possible ==30408== ==30408== For lists of detected and suppressed errors, rerun with: -s  ==30408== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)"}
        ]},
    {"unique_id":"5-2","content":[
        {"type":"subtitle","info":"Reading 18.1 - Topological Sorting"},
        {"type":"subtitle","info":"Pruning the Graph"},
        {"type":"text","info":"In our study of Complete Search, we learned about the benefits of \"pruning the search tree\" in order to minimize the required search time for a specific task. For example, we used a mathematical approach in the N-Queens problem to find the placed Queens instead of searching every possible location a Queen could be, which significantly reduced the run time."},
        {"type":"text","info":"In this lecture, we will cover two methods of pruning a Graph to improve search time."},
        {"type":"text","info":"- Topological Sorting, which builds upon Depth-First Search"},
        {"type":"text","info":"- Minimum Spanning Tree, which builds upon Breadth-First Search and accounts for edge weights."},
        {"type":"subtitle","info":"Topological Sorting"},
        {"type":"text","info":"The main idea of Topological Sorting is that we perform an exhaustive Depth-First Search, meaning that we determine the path from the origin to every reachable node in the Graph. The end result is that the result of a Depth-First Search from the origin to any other node is determined in the Topologically Sorted graph. The difference is that all the edges that are not directly traversed in a DFS from the original graph are removed, in effect pruning the search tree."},
        {"type":"text","info":"The algorithm for DFS is the same, except we do not have a \"destination\" to terminate the algorithm."},
        {"type":"text","info":"- Start at the origin of the search"},
        {"type":"text","info":"- Create arrays for bool visited_verts and unsigned int visited_edges"},
        {"type":"text","info":"- For each outgoing edge E in the current Vertex V"},
        {"type":"text","info":"-> If the destination edge Vdest in E in visited_verts is false"},
        {"type":"text","info":"--> Set visited_verts[Vdest] = true"},
        {"type":"text","info":"-> Recursively call DFS with Vdest as the new edge origin"},
        {"type":"text","info":"- Increment visited_edges[ V ]"},
        {"type":"text","info":"Consider the following Example:"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=806047fd-2a90-462b-954d-ae4b00769444&start=0"},
        {"type":"text","info":"Lecture 18 Introduction Question 1: What is the main idea behind a Topological Sort of a Graph, and how is a Topologically Sorted Graph derived?"},
        {"type":"subtitle","info":"Reading 18.2 - Implementing Topological Sorting in C++ Code"},
        {"type":"text","info":"In our new Graph.h code for this lecture, we will implement the Topological Sorting in out C++ struct that we have been building C++ Lecture 17 In Class and in Lab 08."},
        {"type":"text","info":"You can see that the TopSort method in our updated Graph.h (Links to an external site.) is similar to the method we programmed together in class, with the exception that we do not terminate since we do not have a \"destination\" vertex. We simply run DFS exhaustively until we read every node."},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/raw/main/Lec18_Reading/include/Graph.h"},
        {"type":"text","info":"The primary difference is in the public method that is called by the user.  We create a new graph object, and then make copies of all the vertices. When we run the Topological Sort from the index, we will make a copy of all the edges in the original graph that we encounter into the new graph. What we return is a pruned graph where the edges that are not part of the Topologically Sorted graph are simply not copied into the new graph."},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/raw/main/Lec18_Reading/src/TopSort.cpp"},
        {"type":"text","info":"In the testing function TopSort.cpp (Links to an external site.), you will see that we create an entirely new graph and then copy all the vertices and only the encountered edges into the new graph.  You will see that, when we run the same Depth-First Searches on the original graph (shown above in the diagram), and the Topologically Sorted graph (shown in the bottom diagram), we will always get the same result)."},
        {"type":"text","info":"-bash-4.2$ make TopSort"},
        {"type":"text","info":"g++ -m64 -std=c++11 -O2 -g -Wall -Wextra -Wconversion -Wshadow -Werror -c src/TopSort.cpp -o objects/TopSort.o"},
        {"type":"text","info":"g++ -m64 -std=c++11 -O2 -g -Wall -Wextra -Wconversion -Wshadow -Werror -o exe/TopSort objects/TopSort.o"},
        {"type":"text","info":"exe/./TopSort"},
        {"type":"text","info":"Original Graph:"},
        {"type":"text","info":"0: [4: {1, 1} {2, 1} ]"},
        {"type":"text","info":"1: [20: {3, 1} {4, 1} ]"},
        {"type":"text","info":"2: [5: {3, 1} ]"},
        {"type":"text","info":"3: [10: {5, 1} {2, 1} ]"},
        {"type":"text","info":"4: [30: {5, 1} ]"},
        {"type":"text","info":"5: [18: {4, 1} ]"},
        {"type":"text","info":"The valid DFS path from 0 to 5 is: 0 1 3 5"},
        {"type":"text","info":"The valid DFS path from 0 to 4 is: 0 1 3 5 4 "},
        {"type":"text","info":"The valid DFS path from 0 to 3 is: 0 1 3"},
        {"type":"text","info":"The valid DFS path from 0 to 2 is: 0 1 3 2"},
        {"type":"text","info":"The valid DFS path from 0 to 1 is: 0 1"},
        {"type":"text","info":"The valid DFS path from 0 to 0 is: 0"},
        {"type":"text","info":"Topological Sort Graph:"},
        {"type":"text","info":"0: [4: {1, 1} ]"},
        {"type":"text","info":"1: [20: {3, 1} ]"},
        {"type":"text","info":"2: [5: ]"},
        {"type":"text","info":"3: [10: {2, 1} {5, 1} ]"},
        {"type":"text","info":"4: [30: ]"},
        {"type":"text","info":"5: [18: {4, 1} ]"},
        {"type":"text","info":"The valid DFS path from 0 to 5 is: 0 1 3 5"},
        {"type":"text","info":"The valid DFS path from 0 to 4 is: 0 1 3 5 4"},
        {"type":"text","info":"The valid DFS path from 0 to 3 is: 0 1 3"},
        {"type":"text","info":"The valid DFS path from 0 to 2 is: 0 1 3 2"},
        {"type":"text","info":"The valid DFS path from 0 to 1 is: 0 1"},
        {"type":"text","info":"The valid DFS path from 0 to 0 is: 0"},
        {"type":"text","info":"Lecture 18 Introduction Question 2: How do we implement a Topological Sort in C++, and what are the main differences between a Topological Sort and performing a Depth-First Search in C++?"},
        {"type":"subtitle","info":"Reading 18.3 - Deriving the Minimum Spanning Tree"},
        {"type":"text","info":"Consider the following problem: We are tasked to wire the entire Notre Dame campus. Since we are working in Fitzpatrick Hall, we will originate our power station from the CSE Commons. If we are going to wire the campus we must consider length and cost of all the wires."},
        {"type":"text","info":"Consider a naive approach where all the wires all going from Fitzpatrick Hall to their destination. We require significant, excessive, and redundant wiring across campus. This approach would drive up costs without providing an additional benefits to our customers."},
        {"type":"text","info":"Now let's consider an approach where we reduce the total wire length but setting up wire-routing stations where we strategically split the wiring to reach as many locations on campus as possible. Not only does this reduce wire costs, but makes the process of troubleshooting wire routing issues easier."},
        {"type":"text","info":"To solve this problem, we want to find a graph with a minimum length of wire that connects all the relevant locations on campus."},
        {"type":"text","info":"More formally, we want to find a subgraph of an undirected weighted graph G, such that:"},
        {"type":"text","info":"- it is a tree (i.e., it is acyclic - we do not visit the same node twice)"},
        {"type":"text","info":"- it covers all the vertices V"},
        {"type":"text","info":"-> contains |V| - 1 edges"},
        {"type":"text","info":"A graph G that meets these conditions is known as a Minimum Spanning Tree."},
        {"type":"text","info":"Minimum spanning trees have direct applications in the design of networks, including computer networks, telecommunications networks, transportation networks, water supply networks, and electrical grids"},
        {"type":"subtitle","info":"Prim's Algorithm"},
        {"type":"text","info":"There are several algorithms for finding a Minimum Spanning Tree in a Graph. The Greedy approach is known as Borůvka's algorithm, and the advanced algorithmic approach is known as Kruskal's algorithm. The approach we will study is a pruning search tree approach that utilizes Hash Tables and Priority Queues called Prim's Algorithm."},
        {"type":"text","info":"- At this stage of your Computer Science or Computer Engineering career, think of Prim's Algorithm like Goldilocks: Kruskal's algorithm is too hot. Borůvka's algorithm is too cold. And Prim's Algorithm is just right."},
        {"type":"text","info":"To begin the algorithm, we pick a vertex to be the root, just like in Topological Sorting."},
        {"type":"text","info":"- Create vectors for the weight to reach each node, as well as the parent of each node."},
        {"type":"text","info":"- Start at the root node, and enter all vertices that can be reached by the outgoing edges."},
        {"type":"text","info":"-> In BFS, we put the elements in a queue by the order we encountered them."},
        {"type":"text","info":"-> In Topological Sorting, we sort the elements in a stack by the order we encountered them"},
        {"type":"text","info":"-> We continuously evaluate each vertex, updating the parent and weight values for each location until we have the minimum set of edges."},
        {"type":"text","info":"Note: Graphs can have multiple Minimum Spanning Trees where the total edge weights are the same, but have different edges going to different nodes. On examples in Weekly Surveys and Exam 2, the graph you will be presented is guaranteed to have precisely one Minimum Spanning Tree."},
        {"type":"text","info":"In the video below, I walk through an example of Prim's Algorithm. The example starts with the graph G on the left, and produces the minimum spanning tree on the right:"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=858f52fd-a8a8-45bc-9de3-ae4b0091dd17&start=1.872798"},
        {"type":"text","info":""},
        {"type":"subtitle","info":"Minimum Spanning Tree Example"},
        {"type":"text","info":"Another Minimum Tree Example is presented in the video below. As you review this example, note how the ordering of the inserted node has an impact on which vertices are evaluated next (although, as previously promised, this graph has one unique Minimum Spanning Tree)."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=9bcdaa89-100b-4976-bd5c-ae4b00aace77"},
        {"type":"text","info":"Lecture 18 Introduction Question 3: What is a Minimum Spanning Tree, and what are the benefits of deriving a Minimum Spanning Tree?"},
        {"type":"text","info":"Lecture 18 Introduction Question 4: How do we derive a Minimum Spanning Tree? Specifically, which data structures that we have learned to this point are utilized to perform this algorithmic approach?"}
        ]},
    {"unique_id":"5-3","content":[
        {"type":"subtitle","info":"Reading 19.1 - Finding the Shortest Path in a Graph"},
        {"type":"text","info":"To this point, we have utilized Complete Search and Pruning the Search Tree approaches to performing graph traversals:"},
        {"type":"text","info":"- Complete Search: Breadth-First Search and Depth-First Search"},
        {"type":"text","info":"- Pruning the Search Tree: Minimum Spanning Trees and Topological Sorting"},
        {"type":"text","info":"However, none of these approaches or algorithms return the solution to the shortest path between two locations."},
        {"type":"text","info":"Consider a problem where we want to find the shortest path from  Fitzpatrick Hall to the Hesburgh Library."},
        {"type":"text","info":"Naïve: Long Route around the football and basketball stadiums"},
        {"type":"text","info":"- Technically a correct route"},
        {"type":"text","info":"- But is it a good route? Not in the rain!"},
        {"type":"text","info":"-> BFS or DFS often produce this solution. The goal of BFS and DFS is to determine whether a path exists, not if it is the best path."},
        {"type":"text","info":"-> BFS and DFS are dependent upon the order in which the locations are inserted into the data structure."},
        {"type":"text","info":"-> If a sidewalk is entered into the graph that improves upon the previous solution, DFS definitely will not find it and BFS likely will not find it."},
        {"type":"text","info":"-> Illustrates the importance of understand how the structure of data impacts the computing efficiency."},
        {"type":"subtitle","info":"Using Edge Weights, Priority Queues, and Dynamic Programming to Improve the Search Algorithm"},
        {"type":"text","info":"We can build upon the idea of using edge weights and Priority Queues, like we did in determining the Minimum Spanning Tree, to derive the shortest path."},
        {"type":"text","info":"- Sorting and updating the edges in a priority queue allows us to make an educated guess as to which path we can choose."},
        {"type":"text","info":"- By using a Heap instead of a Doubly Linked List when we aggregate the Priority Queue, we improve the insertion into the priority queue from O(n2) to O(n*lg2(n))"},
        {"type":"text","info":"-> For a graph with a million nodes, here is the Priority Queue improvement"},
        {"type":"text","info":"--> O(n2) is 1,000,000,000,000 operations"},
        {"type":"text","info":"--> O(n*lg2(n)) is 19,931,568 operations"},
        {"type":"text","info":"--> An improvement of 99.998 percent!"},
        {"type":"text","info":"Consider the following graph where there are several paths from the node containing 4 to the node containing 18."},
        {"type":"text","info":"The following path: 4->20->10->18 encounters edges of weights 3 + 4 + 2 = 9"},
        {"type":"text","info":"Meanwhile, the path 4->20->30->18 encounters edges of weights 3 + 2 + 2 = 7"},
        {"type":"text","info":"Also, the path 4->5->10->18 encounters edges of weights 1 + 5 + 2 = 8"},
        {"type":"text","info":"In a simple graph like this, we can tell with our own eyes which is the shortest path. But we need to use effective data structures to scale to a much larger graph, like one we would encounter in a map!"},
        {"type":"text","info":"We can improve upon this approach even further using Dynamic Programming!"},
        {"type":"text","info":"Intuitively: The shortest path between u and v is measured by distance d"},
        {"type":"text","info":"- If d(u,v) < d(u,x) + d(x,v)"},
        {"type":"text","info":"-> Then Edge (u,v) is the shortest path between them"},
        {"type":"text","info":"Therefore, the shortest path for a graph contains the shortest path for the subgraphs that contain that path. Consider the diagram below."},
        {"type":"text","info":"- I claim the path 4->5->10->18 > 4->20->10->18"},
        {"type":"text","info":"- Both paths contain the edge between the vertices containing 10->18"},
        {"type":"text","info":"- Therefore, the shortest path to 10 is now the shortest path between these two paths"},
        {"type":"text","info":"- Now we compare the two paths to the vertex containing 10:"},
        {"type":"text","info":"-> 4->5->10 < 4->20->10"},
        {"type":"text","info":"-> Weights: 3 + 4 < 1 + 5"},
        {"type":"text","info":"-> Weights: 7 < 6"},
        {"type":"text","info":"With this knowledge, we can use dynamic programming to find the Shortest Path in the graph, which we will accomplish in the next section."},
        {"type":"text","info":"Lecture 19 Introduction Question 1: What are the drawbacks to using Breadth-First Search or Depth-First Search to determining a path from one location to another in a graph?"},
        {"type":"text","info":"Lecture 19 Introduction Question 2: How can we use out knowledge of Priority Queues and Dynamic Programming to find the shortest path in a Graph?"},
        {"type":"subtitle","info":"Reading 19.2 - Dijkstra's Algorithm"},
        {"type":"text","info":"In this section, we will study Dijkstra's Algorithm, which will help us determine the Shortest Path between two vertices in a graph using the concepts we studied in Reading 19.1."},
        {"type":"text","info":"In this algorithm we first initialize vectors to distance and parents, as we have done in DFS, BFS, Topological Sort, and Minimum Spanning Trees."},
        {"type":"text","info":"- Distance from all but origin is infinity"},
        {"type":"text","info":"- Parent is currently -1 for all vertices"},
        {"type":"text","info":"Create a Priority Queue to evaluate the next values"},
        {"type":"text","info":"- We put them in when visited"},
        {"type":"text","info":"- Put on the PQ in Edge Weight Order"},
        {"type":"text","info":"If dist[u] + weight < dist [v] of the current vertices we are evaluatin"},
        {"type":"text","info":"- Update dist[v] to dist[u] + weight"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=d5e11a10-d673-4521-a6d1-ae4b00b32c9d&start=5.092727"},
        {"type":"text","info":"Lecture 19 Introduction Question 3: Describe the process for determining the shortest path in a graph using Dijkstra's Algorithm"},
        {"type":"subtitle","info":"Reading 19.3 - Implementing Dijkstra in C++ Object-Oriented Programming"},
        {"type":"text","info":"In this section, we will present the code segment to implement Dijkstra's Algorithm in C++. The code below is a subset of the code presented in Graph.h, which has input checking for origin and destin, and include the same process of using the finalPath stack to print the actual path."},
        {"type":"text","info":"- Note how each parent is initialized to -1"},
        {"type":"text","info":"- Note how each distance is initialized to 2147483647, which is the largest possible signed integer, which will represent infinity in this case"},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/raw/main/Lec19_Reading/include/Graph.h"},
        {"type":"text","info":"Finally, we will compile and run the program. The program run will create a graph and then run Dijkstra's Algorithm (found at Dijkstra.cpp (Links to an external site.)) on several paths in the graph. You will also see that the final graph (provided at Graph.h) implements Breadth-First Search, Depth-First Search, Topological Sorting, Prim's Algorithm for the Minimum Spanning Tree, and Dijkstra's Algorithm for the Shortest Path algorithm. I also run two tests with invalid inputs."},
        {"type":"text","info":"You should now see that Graphs combine all the concepts we have learned up to this point in the semester:"},
        {"type":"text","info":"- Stacks - which aggregate from Singly Linked Lists - and Recursion were used for Depth-First Search, as well as tracking the final paths for all the algorithms"},
        {"type":"text","info":"-> To review trees, Depth-First Search is the graph equivalent of a Pre-Order Traversal in a Binary Search Tree"},
        {"type":"text","info":"- Queues - which aggregate from Doubly Linked Lists - were used for Breadth-First Search"},
        {"type":"text","info":"-> To review trees, Breadth-First Search is the graph equivalent of a Level-Order Traversal in a Binary Search Tree"},
        {"type":"text","info":"- Priority Queues - which aggregate from Heaps - for pruning the search tree via dynamic programming in both Prim's Algorithm and Dijkstra's Algorithm"},
        {"type":"text","info":"- Vectors to track intermediate steps for BFS and DFS, as well as the Adjacency List for the Graph we implemented"},
        {"type":"text","info":"- C and C++ pointers and structs were used for tracking all outgoing edges and vertices"},
        {"type":"text","info":"- C++ Operators, which we used for the Minimum Spanning Tree for implementing object-oriented priority queues."},
        {"type":"text","info":"In Lecture 19, we will review two examples of Dijkstra's Algorithm, and then will spend the rest of the Lecture reviewing for Exam 2."},
        {"type":"text","info":"-bash-4.2$ make Dijkstra"},
        {"type":"text","info":"g++ -m64 -std=c++11 -O2 -g -Wall -Wextra -Wconversion -Wshadow -Werror -c src/Dijkstra.cpp -o objects/Dijkstra.o"},
        {"type":"text","info":"g++ -m64 -std=c++11 -O2 -g -Wall -Wextra -Wconversion -Wshadow -Werror -o exe/Dijkstra objects/Dijkstra.o"},
        {"type":"text","info":"-bash-4.2$ valgrind --leak-check=full exe/./Dijkstra"},
        {"type":"text","info":"==27018== Memcheck, a memory error detector"},
        {"type":"text","info":"==27018== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al."},
        {"type":"text","info":"==27018== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info"},
        {"type":"text","info":"==27018== Command: exe/./Dijkstra"},
        {"type":"text","info":"==27018=="},
        {"type":"text","info":"0: [4: {1, 3} {2, 1} ]"},
        {"type":"text","info":"1: [20: {3, 4} {4, 2} ]"},
        {"type":"text","info":"2: [5: {3, 5} ]"},
        {"type":"text","info":"3: [10: {5, 2} ]"},
        {"type":"text","info":"4: [30: {5, 2} ]"},
        {"type":"text","info":"5: [18: ]"},
        {"type":"text","info":"The valid Dijkstra path from 0 to 5 is: 0 1 4 5 , and the distance is 7"},
        {"type":"text","info":"The valid Dijkstra path from 0 to 4 is: 0 1 4 , and the distance is 5"},
        {"type":"text","info":"The valid Dijkstra path from 0 to 3 is: 0 2 3 , and the distance is 6"},
        {"type":"text","info":"The valid Dijkstra path from 0 to 2 is: 0 2 , and the distance is 1"},
        {"type":"text","info":"The valid Dijkstra path from 0 to 1 is: 0 1 , and the distance is 3"},
        {"type":"text","info":"The valid Dijkstra path from 0 to 0 is: 0 , and the distance is 0"},
        {"type":"text","info":"Invalid Inputs"},
        {"type":"text","info":"Invalid Inputs"},
        {"type":"text","info":"==27018=="},
        {"type":"text","info":"==27018== HEAP SUMMARY:"},
        {"type":"text","info":"==27018== in use at exit: 0 bytes in 0 blocks"},
        {"type":"text","info":"==27018== total heap usage: 58 allocs, 58 frees, 7,816 bytes allocated"},
        {"type":"text","info":"==27018=="},
        {"type":"text","info":"==27018== All heap blocks were freed -- no leaks are possible"},
        {"type":"text","info":"==27018=="},
        {"type":"text","info":"==27018== For lists of detected and suppressed errors, rerun with: -s"},
        {"type":"text","info":"==27018== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)"}
        ]},

    {"unique_id":"6-1","content":[
        {"type":"subtitle","info":"Reading 21.1 - Software Engineering"},
        {"type":"subtitle","info":"Lecture 21: Skim and Learn"},
        {"type":"text","info":"For this lecture, I want you to skim and learn these concepts. I will not be asking you about any of these concepts directly on the Exam or Weekly Surveys. However, these concepts are more important in the context of your final project and careers. Focus your reading on developing questions for class so we can have a robust discussion on software engineering principles."},
        {"type":"subtitle","info":"Building towards larger programs"},
        {"type":"text","info":"In the Fundamentals of Computing class, Professor Ramzi Bualuan tells the students at the beginning of the semester that one of the keys to success is to \"break your bad habits\" from your previous programming. We do the same thing here with the application of Production Quality Compilation rules and strict valgrind passing. You now have a much better understanding of the importance of keeping elements in the bounds of an array than you did one year ago, and that is a good thing!"},
        {"type":"text","info":"Normally, when someone has \"bad habits\", the blame falls right on the person. But this is not your fault! Always working at a “small scale” introduces habits that will cause you great pain later, and many of you have only worked at small or medium scale."},
        {"type":"text","info":"In this lecture, I'll work to give you a sense of how to deal with the “large scale” programming. In the official course description, you may have noticed that one of the course objectives is that a student will be able to \"apply and use data structures in real-world application, employing abstractions to make them work together cleanly and safely.\""},
        {"type":"text","info":"Note: This lecture is heavily inspired by two articles and books."},
        {"type":"text","info":"- \"A Philosophy of Software Design\" by John Ousterhout."},
        {"type":"text","info":"- \"A Spiral Model of Software Development and Enhancement\" by Barry Boehm"},
        {"type":"text","info":"Quick Story Time: The \"PQC rules\" originated from a dinner I had with William Gerstenmaier and Richard Morris, the VPs of Mission Assurance and Production and Launch a SpaceX who have led the development of an impressive software development and testing suite. Software failures are one of the most dominant causes of failures in aerospace mission-critical systems. They lamented modern students lacking fundamental and critical knowledge of secure and reliable computing. This is a complaint you will hear and read from hiring managers, especially from industries where memory and reliability are at a premium:"},
        {"type":"text","info":"Some major aerospace failures resulting from bad software over the years include:"},
        {"type":"text","info":"- Ariane-5 (which we studied in our discussion of floats and doubles) - Unhandled floating point exception"},
        {"type":"text","info":"- Mariner I - Missing Hyphen in code"},
        {"type":"text","info":"- Mars Pathfinder - Priority inversion /scheduling bug"},
        {"type":"text","info":"Mars Climate Orbiter - Navigation system failure, metric to imperial units conversion failure"},
        {"type":"text","info":"In fact, Apollo 11 - the mission that first landed humans on the Moon - had a software error that was nearly catastrophic. Known as the Code 1202 error, the Error 1202 error message started flashing approximately seven minutes prior to landing. Furthermore, the software had not been fully tested and the astronauts had not encountered Error 1202. (Imagine if you encountered a new compiler or valgrind error message you had never seen before while simultaneously trying to land an shuttle on the Moon!)"},
        {"type":"text","info":"It turns out that Error 1202 indicated that the guidance system was overloaded with tasks. So the astronauts had to shut the computer off and reboot the system while 33,000 ft from landing on the Moon."},
        {"type":"text","info":"- Error Code 1202 was essentially a Instruction Stack overflow."},
        {"type":"text","info":"Optional Reading: A recently published article goes over many of the same concepts we will discuss in this lecture: How SpaceX Develops Software"},
        {"type":"subtitle","info":"The Power of Software"},
        {"type":"text","info":"Unlike other engineering disciplines, software is effectively unconstrained by the laws of physics."},
        {"type":"text","info":"- Programming is an act of almost pure creativity!"},
        {"type":"text","info":"The greatest limitation we face in building systems is being able to understand what we're building! Very unlike other disciplines, e.g."},
        {"type":"text","info":"- Chemical engineers have to worry about temperature."},
        {"type":"text","info":"- Material scientists have to worry about how brittle a material is."},
        {"type":"text","info":"- Civil engineers have to worry about the strength of concrete."},
        {"type":"text","info":"Our greatest limitation is simply understanding the system we're trying to build!"},
        {"type":"text","info":"As real programs are worked on, they gain more features and complexity."},
        {"type":"text","info":"- Over time, it becomes more difficult for programmers to understand all the relevant pieces as they make future modifications."},
        {"type":"text","info":"Tools like Tabby, GDB, and valgrind all make it easier to deal with complexity."},
        {"type":"text","info":"But our most important goal is to keep our software simple."},
        {"type":"subtitle","info":"Dealing with Complexity"},
        {"type":"text","info":"There are two approaches to managing complexity:"},
        {"type":"text","info":"- Making code simpler and more obvious."},
        {"type":"text","info":"-> Eliminating special cases"},
        {"type":"text","info":"- Encapsulation into modules, as we have done with C++ structs and methods"},
        {"type":"text","info":"-> In a modular design, creators of one “module” can use other modules without knowing how they work."},
        {"type":"subtitle","info":"The Nature of Coding Complexity"},
        {"type":"text","info":"What is complexity exactly? Ousterhout defines it thus:"},
        {"type":"text","info":"- “Complexity is anything related to the structure of a software system that makes it hard to understand and modify the system.”"},
        {"type":"text","info":"Complexity takes many forms:"},
        {"type":"text","info":"- Understanding how the code works."},
        {"type":"text","info":"- The amount of time it takes to make small improvements."},
        {"type":"text","info":"- Finding what needs to be modified to make an improvement."},
        {"type":"text","info":"- Difficult to fix one bug without introducing another."},
        {"type":"text","info":"“If a software system is hard to understand and modify, then it is complicated. If it is easy to understand and modify, then it is simple”."},
        {"type":"text","info":"For example: Using recursion allowed us to perform advanced backtracking regardless of the size of the problem. Recursion allowed us to simplify the coding"},
        {"type":"text","info":"- If you understand how recursion and backtracking work"},
        {"type":"text","info":"- Then, you can significantly reduce the complexity of code"},
        {"type":"text","info":"- The modularity allows us to easily troubleshoot a bug without unintentionally introducing others."},
        {"type":"subtitle","info":"Symptoms and Causes of Complexity"},
        {"type":"text","info":"Ousterhout describes three symptoms of complexity:"},
        {"type":"text","info":"- Change amplification: A simple change requires modification in many places."},
        {"type":"text","info":"-> Our 2048 was a good example of this."},
        {"type":"text","info":"-> This is why I recommended you get the shift_left function working fully first, so that way logical mistakes you may have made in shift_left would not propagate to the other functions."},
        {"type":"text","info":"- Cognitive load: How much you need to know in order to make a change."},
        {"type":"text","info":"-> Note: This is not the same as number of lines of code. Often MORE lines of code actually makes code simpler, because it is more narrative."},
        {"type":"text","info":"-> You'll see this in code I present in lecture. Sometimes, I could combine several lines of code into fewer lines, but that code is harder to decipher for newer programmers."},
        {"type":"text","info":"- Unknown unknowns: The worst type of complexity. This occurs when it's not even clear what you need to know in order to make modifications!"},
        {"type":"text","info":"-> Common in large databases."},
        {"type":"text","info":"-> Quick Story: Two previous ND Data Structures students, Tara Flannery and Brooke Mackey, were tasked with updating code on a gyroscopic monitoring system for the Navy. They successfully recommended cleaning up the code base because the systems code would frequently fail on several tests. They even used the PQC rules to prove the previously existing code was inefficient and unsafe, putting sailors at risk. Based on their recommendations, Pacific Northwest Naval Labs adopted the PQC coding standards."},
        {"type":"subtitle","info":"Complexity Comes Slowly"},
        {"type":"text","info":"Every software system starts out beautiful, pure, and clean.  As they are built upon, they slowly twist into uglier and uglier shapes. This is almost inevitable in real systems."},
        {"type":"text","info":"- Each complexity introduced is no big deal:"},
        {"type":"text","info":"-> “Complexity comes about because hundreds or thousands of small dependences and obscurities build up over time.”"},
        {"type":"text","info":"- “Eventually, there are so many of these small issues that every possible change is affected by several of them.”"},
        {"type":"text","info":"- This incremental process is part of what makes controlling complexity so hard."},
        {"type":"text","info":"- Ousterhout recommends a zero tolerance philosophy."},
        {"type":"text","info":"For those of you who have attended my office hours, this is why I have the message \"Better is the Enemy of Good Enough\" written in my office."},
        {"type":"text","info":"Lecture 21 Introduction Question 1: What is Programming Complexity?"},
        {"type":"text","info":"Lecture 21 Introduction Question 2: What are the three symptoms and causes of Programming Complexity?"},
        {"type":"subtitle","info":"Reading 21.2 - Strategic vs. Tactical Programming"},
        {"type":"text","info":"To this point in your career, much (or all) of the programming that you've done, Ousterhout would describe as “tactical”."},
        {"type":"text","info":"- “Your main focus is to get something working, such as a new feature or bug fix.”"},
        {"type":"text","info":"This may seem like a silly criticism. Clearly, working code is good. "},
        {"type":"text","info":"The problem with tactical programming is that you don't spend problem thinking about overall design."},
        {"type":"text","info":"- As a result, you introduce tons of little complexities, e.g. making two copies of a method that do something similar."},
        {"type":"text","info":"- Each individual complexity seems reasonable, but eventually you start to feel the weight."},
        {"type":"text","info":"-> Refactoring would fix the problem, but it would also take time, so you end up introducing even more complexity to deal with the original ones."},
        {"type":"text","info":"The objective of the Final Project is for you to get your significant experience working through individual complexity throughout a larger design."},
        {"type":"subtitle","info":"Strategic Programming"},
        {"type":"text","info":"“The first step towards becoming a good software designer is to realize that working code isn't enough.”"},
        {"type":"text","info":"- “The most important thing is the long term structure of the system.”"},
        {"type":"text","info":"- Adding complexities to achieve short term time games is unacceptable"},
        {"type":"text","info":"Many of you experienced this growth as a computer scientist or computer engineer when working with valgrind. The code may appear to have worked, except with a valgrind error. The reality is that your code work for that specific set of inputs only, and even then, it didn't necessarily \"work\". For example, perhaps you successfully read elements outside of the array because no other program was using that memory location. However, the valgrind error exposed an unsafe code condition that meant a potentially serious issue with the long term structure of the system."},
        {"type":"subtitle","info":"Suggestions for Strategic Programming"},
        {"type":"text","info":"Strategic programming requires lots of time investment. But those who can do it well are highly coveted in industry, because too many programmers are simply tactical programmers. The \"strategic\" aspect of programming is what differentiates a true computing scientist."},
        {"type":"text","info":"For each new programming task:"},
        {"type":"text","info":"- Rather than implementing the first idea, try coming up with (and possibly even partially implementing) a few different ideas."},
        {"type":"text","info":"-> In the Final Project, you will see that I show you how to \"ideate and discuss\" different ideas with your groupmates"},
        {"type":"text","info":"- When you feel like you have found something that feels clean, then fully implement that idea."},
        {"type":"text","info":"- In real systems: Try to imagine how things might need to be changed in the future, and make sure your design can handle such changes."},
        {"type":"subtitle","info":"Strategic Programming is Hard"},
        {"type":"text","info":"No matter how careful you try to be, there will be mistakes in your design."},
        {"type":"text","info":"- Avoid the temptation to patch around these mistakes. Instead, fix the design."},
        {"type":"text","info":"-> Example: Don't add a bunch of special cases! Instead, make sure the system gracefully handles the cases you didn't think about."},
        {"type":"text","info":"- Indeed, it is impossible to design large software systems entirely in advance."},
        {"type":"subtitle","info":"Facebook as a Tactical Programming Case Study"},
        {"type":"text","info":"As a startup, Facebook embraced tactical programming."},
        {"type":"text","info":"- “Move fast and break things.”"},
        {"type":"text","info":"- Common for new engineers to push changes to the live site within their first week."},
        {"type":"text","info":"-> Very rapid development process in the short term."},
        {"type":"text","info":"-> Felt empowering!"},
        {"type":"text","info":"- Facebook was very successful, but its codebase was a mess."},
        {"type":"text","info":"-> Ousterhout describe their code as “incomprehensible, unstable, few comments or tests, and painful to work with.”"},
        {"type":"text","info":"- Eventually, Facebook's motto became “Move fast with stable infra.”"},
        {"type":"text","info":"Note: Arguably Facebook's general attitude has done great harm. Will discuss in a future lecture."},
        {"type":"subtitle","info":"Google and VMware as a Strategic Programming Case Studies"},
        {"type":"text","info":"By contrast Google and VMware are known as highly strategic organizations."},
        {"type":"text","info":"- Both companies placed a heavy emphasis on high quality code and good design."},
        {"type":"text","info":"-> Google, for many years, was \"in Beta\" because they were committed to proactively fix their design"},
        {"type":"text","info":"- Both companies built sophisticated products that solved complex problems with reliable software systems."},
        {"type":"text","info":"- The companies' strong technical cultures became well known in Silicon Valley. Few other companies could compete with them to hire the top technical talent."},
        {"type":"text","info":"Real world projects and companies succeed with either approach! "},
        {"type":"text","info":"- … but Ousterhout says it's probably more fun to work somewhere with a nice code base."},
        {"type":"subtitle","info":"The Ledger of Harms"},
        {"type":"text","info":"Why is understanding the difference between Tactical and Strategic Programming as a computing professional so important? Because the same ideas you use to following strategic programming are the same you will use when making ethical decisions."},
        {"type":"text","info":"- “I think we have created tools that are ripping apart the social fabric of how society works.” - Chamath Palihapitiya (early executive at Facebook)"},
        {"type":"text","info":"- “The technologies we were most excited about 10 years ago are now implicated in just about every catastrophe of the day.” - Farhad Manjoo (technology journalist)"},
        {"type":"text","info":"The reality is that technology companies do inflict significant negative externalities upon society."},
        {"type":"text","info":"- Most of them are still a net positive, e.g. I personally use and enjoy Facebook."},
        {"type":"text","info":"My personal sense is that these are largely unintended consequences by well intentioned people."},
        {"type":"text","info":"- Yes, there are some bad actors, but I don't think they are common."},
        {"type":"text","info":"- Workers and executives at these companies do care."},
        {"type":"text","info":"-> … but money does skew people's perspective in strange ways."},
        {"type":"text","info":"So why does this matter in Data Structures and in programming? For many of you, this semester was the first time you truly had to confront how the code you write impacts the operation of the computing machinery."},
        {"type":"text","info":"- You shouldn't just understand that saving intermediate steps in registers and stack memory is a performance improvement over dynamic memory. You should also understand that safety device chips in automobiles require efficient, secure, and fast processing , and that your understanding of these mechanisms can literally be the difference between life and death."},
        {"type":"text","info":"- You shouldn't just understand that hashing provides faster insertion and look-up time. You should also understand that financial and medical environments using hashing for fast decision making and cryptography, so that your understanding of these mechanisms can improve decision times for stock broking and time critical decisions in emergency rooms."},
        {"type":"text","info":"Lecture 21 Introduction Question 3: Describe Tactical and Strategic Programming. Why should a computer scientist or a computer engineer employ Strategic Programming instead of Tactical Programming"},
        {"type":"subtitle","info":"Reading 21.3 - Modularity in Software Engineering"},
        {"type":"text","info":"So far in Fundamentals of Computing and Data Structures, we have promoted modularity as the use of functions to divide computing into small, re-usable tasks. However, as you grow as a computer scientist or computer engineer, you will need to perform advanced modularity"},
        {"type":"text","info":"In the Programming Paradigms course, you will apply these concepts to"},
        {"type":"text","info":"- Quickly learn a new language that supports imperative, functional, object-oriented, and logic paradigms."},
        {"type":"text","info":"- Evaluate the right combination of programming languages to solve a given problem. Provide a convincing argument."},
        {"type":"text","info":"Studying programming paradigms will help you be better at your job, make more money, and be a happier, more fulfilled and more informed citizen, because you'll learn to: choose the most appropriate language for a given task. You will be able to quickly learn a new language that supports imperative, functional, object-oriented, and logic paradigms."},
        {"type":"text","info":"- Imperative programming is a programming paradigm that uses statements that change a program's state."},
        {"type":"text","info":"- Procedural programming is a type of imperative programming in which the program is built from one or more procedures"},
        {"type":"text","info":"-> C is a procedural programming language"},
        {"type":"text","info":"- Object-oriented is a programming paradigm based on the concept of \"objects\", which can contain data and code: data in the form of fields (often known as attributes or properties), and code, in the form of procedures"},
        {"type":"text","info":"-> C++, Java, and Python are object-oriented languages with procedural aspects"},
        {"type":"text","info":"To understand which programming paradigm you would choose, you need to understand modularity at a deeper level."},
        {"type":"subtitle","info":"Hiding Complexity through Modularity and Abstraction"},
        {"type":"text","info":"Modularity is the idea of building components that can be re-used; and abstraction is the idea that after constructing a module (be it software or circuits or gears), most of the details of the module construction can be ignored and a simpler description used for module interaction (the module computes the square root, or doubles the voltage, or changes the direction of motion)."},
        {"type":"text","info":"Given basic modules, one can move up a level of abstraction and construct a new module by putting together several previously-built modules, thinking only of their abstract descriptions, and not their implementations. And, of course, this process can be repeated over many stages. This process gives one the ability to construct systems with complexity far beyond what would be possible if it were necessary to understand each component in detail."},
        {"type":"text","info":"In an ideal world, system would be broken down into modules, where every module would be totally independent."},
        {"type":"text","info":"- Here, “module” is an informal term referring to a struct, class, a package, or other unit of code."},
        {"type":"text","info":"- Not possible for modules to be entirely independent, because code from each module has to call other modules."},
        {"type":"text","info":"-> e.g. need to know signature of methods to call them."},
        {"type":"text","info":"In modular design, our goal is to minimize dependencies between modules."},
        {"type":"subtitle","info":"Graphs as an Example of Modular Design"},
        {"type":"text","info":"Our study of graphs is an good example of modular design. During that lecture series, we:"},
        {"type":"text","info":"- Built the graph in pieces, selecting an adjacency list, and then designed and tested Edge and Vector structs"},
        {"type":"text","info":"- Then we implemented BFS and DFS traversals."},
        {"type":"text","info":"-> We used C++ libraries of data structures we had already learned, such as vectors, stacks, queues, priority queues, and hash tables,"},
        {"type":"text","info":"- Then we studied Dijsktra and Prim's Algoritm"},
        {"type":"text","info":"-> Built upon the \"Pruning the Search Tree\" approach we learned during Complete search"},
        {"type":"text","info":"At each stage, once we completed the design at a lower level of abstraction, we were able to move higher and build upon that work."},
        {"type":"subtitle","info":"Interface vs. Implementation"},
        {"type":"text","info":"A common phrase you will hear in your career is: the more complicated the Data Structure, the simpler the algorithm. Ousterhout said “The best modules are those whose interfaces are much simpler than their implementation.” You have experienced this in our course! It was much simpler to just use the push_back() method in a vector than design the underlying code we covered in class."},
        {"type":"text","info":"- A simple interface minimizes the complexity the module can cause elsewhere. If you only have a getNext() method, that's all someone can do."},
        {"type":"text","info":"- If a module's interface is simple, we can change an implementation of that module without affecting the interface."},
        {"type":"subtitle","info":"Modules Should Be Deep"},
        {"type":"text","info":"The best modules are those that provide powerful functionality yet have simple interfaces. These are known as deep modules."},
        {"type":"text","info":"For example, the Graph we covered in class is a deep module."},
        {"type":"text","info":"- Simple interface:"},
        {"type":"text","info":"-> insert, search, delete."},
        {"type":"text","info":"-> Nothing informal that user needs to know (e.g. user doesn't have to specify or know the adjacency list or which operations)"},
        {"type":"text","info":"- Powerful functionality:"},
        {"type":"text","info":"-> Operations are efficient."},
        {"type":"text","info":"-> Graph ordering is maintained using sophisticated, subtle rules."},
        {"type":"subtitle","info":"Generic Classes are Deeper"},
        {"type":"text","info":"- Should new classes be general-purpose or special-purpose?"},
        {"type":"text","info":"-> Special-purpose: just do exactly what's needed today"},
        {"type":"text","info":"-> General-purpose: solve a range of problems that may in the future"},
        {"type":"text","info":"- My advice: make classes somewhat generic:"},
        {"type":"text","info":"-> Overall capabilities reflect current needs"},
        {"type":"text","info":"-> Design an interface that is generic enough to be used for other purposes besides today's needs"},
        {"type":"text","info":"-> Result: simpler and deeper interface than special-purpose approach"},
        {"type":"text","info":"- Questions to ask yourself:"},
        {"type":"text","info":"-> What is the simplest API that will cover all of my current needs?"},
        {"type":"text","info":"-> In how many situations will this method be used?"},
        {"type":"text","info":"-> Is this API convenient to use for my current needs?"},
        {"type":"subtitle","info":"Information Hiding"},
        {"type":"text","info":"- First proposed by David Parnas in the paper \"On the Criteria To Be Used in Decomposing Systems into Modules\""},
        {"type":"text","info":"-> More than 40 years old, but still one of the most important papers in all of computing systems."},
        {"type":"text","info":"- Each module (class) should encapsulate certain knowledge or design decisions:"},
        {"type":"text","info":"-> The knowledge/design decisions are only known to the one module"},
        {"type":"text","info":"-> The interface does not reflect this information (much)"},
        {"type":"text","info":"- Benefits:"},
        {"type":"text","info":"-> Simpler interface (deeper class)"},
        {"type":"text","info":"-> Can modify the implementation without impacting other classes"},
        {"type":"text","info":"-> This is the single most important idea in software design; will revisit it over and over throughout the rest of your career at Notre Dame"},
        {"type":"subtitle","info":"Information Leakage"},
        {"type":"text","info":"The opposite of information hiding is information leakage."},
        {"type":"text","info":"- Implementation details exposed, other classes depend on them"},
        {"type":"text","info":"- Anything in the interface is leaked"},
        {"type":"text","info":"- Back-door leakage: not visible in the interface"},
        {"type":"text","info":"Ousterhout:"},
        {"type":"text","info":"- “Information leakage is one of the most important red flags in software design.”"},
        {"type":"text","info":"- “One of the best skills you can learn as a software designer is a high level of sensitivity to information leakage.”"},
        {"type":"text","info":"Lecture 21 Introduction Question 4: Describe the importance of reducing complexity through modularity and abstraction"},
        {"type":"subtitle","info":"Reading 21.4 - Spiral Software Development"},
        {"type":"text","info":"In the Final Project for this course, you will conduct a 4-week long project in a group of 4. The research project for CSE 20312 will serve as a capstone for the course. It's a way for you to run wild with a topic and discover something interesting."},
        {"type":"text","info":"You'll choose a data structure, an algorithm pertaining to a specific data structure, or a theoretical result about data structures that will serve as the focus of your project. You'll spend the remainder of the semester doing your best to become an expert on the topic. To do that, you'll probably read several research papers, blog posts, book chapters, etc. to see what you find. "},
        {"type":"text","info":"One of the benefits of this assignment is to provide you with experience you can quantify on a resume to position you for better internships and jobs. I strongly recommend you work on a project in an area you want to work in when you graduate, such as Machine Learning, Cryptography, Design, Testing, ect. The more you are excited about the project, the more likely you will be to enjoy your work on this assignment."},
        {"type":"text","info":"Two other reasons for this assignment:"},
        {"type":"text","info":"- Get practice working on a team."},
        {"type":"text","info":"- Get more creativity into the project since it's so open ended."},
        {"type":"text","info":"- Get practice with strategic programming instead of purely tactical programming you have done up to now."},
        {"type":"subtitle","info":"Why Software Development Models?"},
        {"type":"text","info":"All software construction involves two task types: (Source, The Mythical Man-Month: Essays on Software Engineering)"},
        {"type":"text","info":"- Essential tasks, the fashioning of the complex conceptual structures that compose the abstract software entity"},
        {"type":"text","info":"-> In Data Structures, the essential tasks have been designing and implementing the various structures in C and C++"},
        {"type":"text","info":"- Accidental tasks, the representation of these abstract entities in programming languages and the mapping of these onto machine languages within space and speed constraints."},
        {"type":"text","info":"-> In Data Structures, the accidental tasks involve use of Production Quality Compilation to map to the x86_64 architecture on the Notre Dame server machines."},
        {"type":"text","info":"-> By implementing PQC, we limit how much \"accident\" translates into the accidental tasks."},
        {"type":"text","info":"In Reading 21.2, we mentioned the three symptoms and causes of complexity. To review, those were:"},
        {"type":"text","info":"- Change amplification"},
        {"type":"text","info":"- Cognitive load"},
        {"type":"text","info":"- Unknown unknowns"},
        {"type":"text","info":"Once you graduate and reach the \"real world\", you will encounter these issues far more frequently. In Fundamentals of Computing and Data Structures, we only have 15 weeks to teach you the expected material. As a result, most of the focus on code design is tactical and focuses on strengthening your understanding of change amplification and cognitive load."},
        {"type":"text","info":"But the final project will be a deep dive into using your understanding of Data Structures dealing with unknown unknowns."},
        {"type":"subtitle","info":"Incremental Development"},
        {"type":"text","info":"Incremental development - or progressive refinement - is one where every day you are measurably and visibility closer to the goal of shipping your product by building your product one step at a time."},
        {"type":"text","info":"Typically, you will have many sub-release phases or versions (say, version 0.1, 0.2, and so on) where each phase implements more function (i.e., covers more requirement or specification items)."},
        {"type":"text","info":"The idea of inchstones fits well with incremental development. The idea of iterating between the spec/design and implementation fits will with incremental development."},
        {"type":"text","info":"The major flaw with incremental development is the lack of feedback into the design process, meaning how you address unknown unknowns as they evolve into known unknowns."},
        {"type":"subtitle","info":"Waterfall Development"},
        {"type":"text","info":"The waterfall model is a breakdown of project activities into linear sequential phases, where each phase depends on the deliverables of the previous one and corresponds to a specialization of tasks. In software development, the progress flows in largely one direction (\"downwards\" like a waterfall) through the phases of conception, initiation, analysis, design, construction, testing, deployment and maintenance."},
        {"type":"text","info":"Waterfall tends to be among the less iterative and flexible approaches, and designers may not be aware of future difficulties when designing a new software product or feature."},
        {"type":"text","info":"It is better to revise the design than persist in a design that does not account for any newly discovered constraints, requirements, or problems."},
        {"type":"text","info":"Some organizations, such as the United States Department of Defense, now have a stated preference against waterfall-type methodologies, which encourages evolutionary acquisition and Iterative and Incremental Development."},
        {"type":"subtitle","info":"Spiral Software Development"},
        {"type":"text","info":"The Spiral model was presented in 1988 by Barry Boehm, and was specifically designed to help the Department of Defense manage increasingly large software projects, and was a direct response to the challenges they encountered with waterfall development models."},
        {"type":"text","info":"High-level view: continuously perform the following four tasks"},
        {"type":"text","info":"- Identify Objectives - Consider the win conditions of all success-critical stakeholders."},
        {"type":"text","info":"- Identify Risks and Alternatives - Identify and evaluate alternative approaches for satisfying the win conditions"},
        {"type":"text","info":"- Product Development - Perform the tasks based on the assessment of objectives, risks, and alternatives"},
        {"type":"text","info":"- Plan the next phase - Until project release, consider the results from testing and development, and develop an amended set of win conditions."},
        {"type":"text","info":"“Spiral” reflects increasing costs (y axis)"},
        {"type":"subtitle","info":"The six invariants of spiral model"},
        {"type":"text","info":"Sequentially defining the key artifacts for a project often increases the possibility of developing a system that meets stakeholder \"win conditions\" (objectives and constraints)."},
        {"type":"text","info":"This invariant excludes “hazardous spiral look-alike” processes that use a sequence of incremental waterfall passes in settings where the underlying assumptions of the waterfall model do not apply. Boehm lists these assumptions as follows:"},
        {"type":"text","info":"1. The requirements are known in advance of implementation."},
        {"type":"text","info":"2. The requirements have no unresolved, high-risk implications, such as risks due to cost, schedule, performance, safety, user interfaces, or organizational impacts"},
        {"type":"text","info":"3. The nature of the requirements will not change very much during development or evolution."},
        {"type":"text","info":"4. The requirements are compatible with all the key system stakeholders' expectations, including users, customer, developers, maintainers, and investors."},
        {"type":"text","info":"5. The right architecture for implementing the requirements is well understood."},
        {"type":"text","info":"6. There is enough calendar time to proceed sequentially."},
        {"type":"text","info":"In situations where these assumptions do apply, it is a project risk not to specify the requirements and proceed sequentially. The waterfall model thus becomes a risk-driven special case of the spiral model."},
        {"type":"subtitle","info":"Risk determines level of effort"},
        {"type":"text","info":"For any project activity (e.g., requirements analysis, design, prototyping, testing), the project team must decide how much effort is enough. In authentic spiral process cycles, these decisions are made by minimizing overall risk."},
        {"type":"text","info":"For example, investing additional time testing a software product often reduces the risk due to the marketplace rejecting a shoddy product. However, additional testing time might increase the risk due to a competitor's early market entry. From a spiral model perspective, testing should be performed until the total risk is minimized, and no further."},
        {"type":"text","info":"\"Hazardous spiral look-alikes\" that violate this invariant include evolutionary processes that ignore risk due to scalability issues, and incremental processes that invest heavily in a technical architecture that must be redesigned or replaced to accommodate future increments of the product."},
        {"type":"subtitle","info":"Risk determines Programming Complexity"},
        {"type":"text","info":"For any project artifact (e.g., requirements specification, design document, test plan), the project team must decide how much detail is enough. In authentic spiral process cycles, these decisions are made by minimizing overall risk."},
        {"type":"text","info":"Considering requirements specification as an example, the project should precisely specify those features where risk is reduced through precise specification (e.g., interfaces between hardware and software, interfaces between prime and sub-contractors). Conversely, the project should not precisely specify those features where precise specification increases the risk (e.g., graphical screen layouts, the behavior of off-the-shelf components)."},
        {"type":"text","info":"Lecture 21 Introduction Question 5: Describe the Spiral Software Development Model, as well as the four continuously performed tasks"}
        ]},
    {"unique_id":"6-2","content":[
        {"type":"subtitle","info":"Reading 22.1 - B-Tree Motivation"},
        {"type":"text","info":"Reading Note: This section is a \"skim\" section, which is used to motivate and explain the importance of the B-Tree data structure we will cover in depth in the subsequent sections. No material from this section will be on the Final Exam, but it is useful in helping you understand why we are studying this specific B-Tree Data Structure."},
        {"type":"subtitle","info":"Databases and Disk Structure"},
        {"type":"text","info":"In the Database Systems Concepts course (commonly taught by Prof. Tim Weninger) or the Advanced Database Projects (Links to an external site.) (commonly taught by Prof. Ramzi Bualuan), you will learn the fundamentals of using and implementing relational database management systems (DBMS). You will also will study data representation, indexing, query optimization and processing, transaction processing, and large scale “big-data” processing systems."},
        {"type":"text","info":"With the advent and growth of cloud computing and version control systems like GitHub, understanding how to structure data within a Database is increasingly important for Computer Scientists and Computer Engineers."},
        {"type":"text","info":"- You have been introduced to this concept through the use of GitHub in this course as well as Systems Programming. Me and Professor Peter Bui use different techniques, but we both ensure you understand that pushing objects and executables to Git consumes significant memory and should be avoided."},
        {"type":"text","info":"Optional Reading: From IBM, \"What is a Cloud Database? (Links to an external site.)\""},
        {"type":"text","info":"Optional Reading: From Git, \"What is Git? (Links to an external site.)\", where they discuss how Git is a relational database."},
        {"type":"text","info":"When students try to learn B-Trees (and B+ Trees in the Database Concepts course), they often simply try to understand the balancing mechanisms of the B-Tree. But that doesn't give students a robust understanding of why they work the way that they do. In previous lectures, I've asked you to draw both the logical layout as well as the physical layout so you understand both the idea of the Data Structure, as well as how the Operating System contributes  to how the data is structured. (I assessed this understanding with the Priority Queue question on Exam 1)."},
        {"type":"text","info":"Not only did I teach the material in that manner to set you up for success in your future OS course, but also to set you up for success in understanding B-Trees, as well as Red-Black Trees in Lecture 23. Please be sure to ask questions if you were unsure about those concepts, and we will be happy to help strengthen your understanding."},
        {"type":"text","info":"So what is a Disk Structure?"},
        {"type":"text","info":"A memory disk consists of tracks and sectors. Think of the tracks as circles, and the sectors like a slice of pie"},
        {"type":"text","info":"- Tracks are logical circles. Each \"circle\" goes from the outside to the inside represents a track from 0 to n-1."},
        {"type":"text","info":"- Sectors are logical slices. Each \"slice\" going counter clockwise represents a sector from 0 to m-1."},
        {"type":"text","info":"- Each intersection of a track and a sector is known as a block"},
        {"type":"text","info":"-> Therefore, there are n*m blocks of memory per disc."},
        {"type":"text","info":"-> Any address on the disk can be reached if you know the track number and the sector number."},
        {"type":"text","info":"For this example, we will assume that a block is 512 bytes. (This number changes based on the manufacturer of the disk.) Whenever we read or write to a disc, we always write in terms of blocks"},
        {"type":"text","info":"- We write the entire 512 bytes per write"},
        {"type":"text","info":"- We read the entire 512 bytes per read"},
        {"type":"text","info":"In that block, each byte has its own address, which we call the offset."},
        {"type":"text","info":"- This is known as byte addressing, which you will cover in detail in the Computer Architecture courseLinks to an external site.."},
        {"type":"text","info":"Another aspect of disk reading: The disk is mounted on a spindle. By spinning, the sector will change. The header will move to a specified track, which will take us to the exact block we need."},
        {"type":"text","info":"The blocks of memory are brought into the Data Heap, and only then can it be accessed."},
        {"type":"text","info":"- This is why dynamic memory through the Data Heap can store so much more memory than the static memory. The static memory stores precisely what is known at compile time, whereas Dynamic Memory can swap blocks based on which elements of the data structure we can use at any given moment."},
        {"type":"text","info":"We have learned that the purpose of Data Structures is to learn how store data in memory in a way that can be efficiently used by the program."},
        {"type":"text","info":"But now, we can also understand that Operating Systems use data structures to effectively find memory in the disk! A Database Management System (DBMS) is a software system used to manage and manipulate data in a database."},
        {"type":"subtitle","info":"Brief DBMS Overview - How Databases are Stored on Disks"},
        {"type":"text","info":"Let's say we have a database with 100 entries. Each entry in the database contains"},
        {"type":"text","info":"- ID: Unsigned integer - 4 bytes"},
        {"type":"text","info":"- Name:  std::string - Up to 50 characters - 8 bytes for base pointer plus 50 bytes, which is 58 bytes"},
        {"type":"text","info":"- Department: std::string - Up to 12 characters - 8 bytes for base pointer plus 12 bytes, which is 20 bytes"},
        {"type":"text","info":"- Section: std::string - Up to 8 characters - 8 bytes for base pointer plus 10 bytes, which is 18 bytes"},
        {"type":"text","info":"- Additional: std::string  - Up to 50 characters - 8 bytes for base pointer plus 50 bytes, which is 58 bytes"},
        {"type":"text","info":"In total, each Object in the Database takes 156 bytes. Therefore, 100 entries requires 15,600 bytes."},
        {"type":"text","info":"- We can store 512 / 156 = 3.28 records per block."},
        {"type":"text","info":"We can store 512 / 156 = 3.28 records per block."},
        {"type":"text","info":"- Put only 3 records per block, leaving the remaining memory empty."},
        {"type":"text","info":"-> We would require 52 blocks"},
        {"type":"text","info":"-> Consumes more memory, but easier to insert, find and delete data"},
        {"type":"text","info":"- Put all the records consecutively in memory, "},
        {"type":"text","info":"-> We would require 31 blocks"},
        {"type":"text","info":"-> Harder to insert, lookup and delete from the memory"},
        {"type":"text","info":"- The tradeoffs of these approaches are studied in detail in the Operating Systems course."},
        {"type":"text","info":"Optional Reading: Operating Systems preview - Paging vs. Segmentation"},
        {"type":"text","info":"In order to find whether a specific unique ID in a database, we might have to iterate through the entire database array, which would potentially go through several sectors and tracks."},
        {"type":"text","info":"If we use a Hash Table, the memory overhead would be significant in order to prevent collisions, although the lookup time between the key (the ID) and the value (the address of the block on the disk) would be fast."},
        {"type":"text","info":"Binary Search Trees are a good compromise. However, since we are sorting by the ID, we run into a serious possibility that - in order to traverse the Binary Search Tree - we will jump around several blocks, reducing the benefit of the Binary Search Tree."},
        {"type":"text","info":"Ideation: We know the number of records that can be stored per block! So what if we designed a Data Structure that gave us the benefit of Binary Search Trees where each node contains the same number of records that can be stored per block?"},
        {"type":"text","info":"That is the main idea behind the B-Tree."},
        {"type":"text","info":"Lecture 22 Introduction Question 1: How are databases stored on a disk, and how does this impact our ability to search and find data in long-term memory?"},
        {"type":"subtitle","info":"Reading 22.2 - Introduction to Tree Balancing"},
        {"type":"subtitle","info":"The Issue with Search Trees"},
        {"type":"text","info":"To this point in the semester, with respect to trees we have learned:"},
        {"type":"text","info":"- How to program a Binary Search Tree in C,"},
        {"type":"text","info":"- Perform pre-order, in-order, post-order, and level-order traversals"},
        {"type":"text","info":"- Studied LeetCode algorithms for Binary Search Trees to promote advanced computational thinking"},
        {"type":"text","info":"- In C++, we learned that the std::set (Links to an external site.) library is a specific type of Binary Search Tree."},
        {"type":"text","info":"However, we side-stepped a specific issue in Binary Search Trees back in Lecture 9. But now that you understand concepts like Big-O notation, amortized analysis and pruning the search tree, we can now address this issue in detail."},
        {"type":"text","info":"Binary Search Tree balance well when we receive a random order. However, as we learned in Amortized Analysis, as well as our considering of Hash Tables, we won't always be able to insert into a BST in random order. What if our data comes in real-time? Then, we will be forced to insert in the order that data comes to us."},
        {"type":"text","info":"Consider the scenario where we enter the elements 15, 25, 30, 40, and 50 into a Binary Search Tree. The tree as we have defined it to this point looks like this:"},
        {"type":"text","info":"We do not get any of the benefits of the Binary Search Tree! It is actually a glorified Singly Linked List. Plus, we have a stray node pointer in each node, which means we get:"},
        {"type":"text","info":"- The worst-case memory overhead of a Doubly Linked List"},
        {"type":"text","info":"- But we can't search backwards, which incurs all the disadvantages of a Singly Linked List"},
        {"type":"text","info":"- And we don't get any of the searching benefits from the Binary Search Tree"},
        {"type":"text","info":"The difference in runtime between a worst-case tree and best-case tree is very dramatic."},
        {"type":"text","info":"Worst case: O(N)"},
        {"type":"text","info":"Best-case: O(lg2N)"},
        {"type":"subtitle","info":"BST Performance"},
        {"type":"text","info":"Some terminology for BST performance:"},
        {"type":"text","info":"- depth: the number of links between a node and the root."},
        {"type":"text","info":"- height: the lowest depth of a tree."},
        {"type":"text","info":"- average depth: average of the total depths in the tree."},
        {"type":"text","info":"You calculate this by taking: where di is depth and ni is number of nodes at that depth."},
        {"type":"text","info":"The height of the tree determines the worst-case runtime, because in the worst case the node we are looking for is at the bottom of the tree."},
        {"type":"text","info":"The average depth determines the average-case runtime."},
        {"type":"subtitle","info":"An Initial Brute Force Approach - Multiple Data Elements Per Node"},
        {"type":"text","info":"Our ultimate objective is to reduce the amount of time it takes to find a specific element. Now that we understand that databases can be search more efficiently if we store multiple elements per node, let us strategically design a data structure that accomplishes this task!"},
        {"type":"text","info":"Consider the scenario in the video below. Here, we have a tree with two values per node. In the video, the values of 10, 15, 4, 21, 8, and 18 are inserted. We encounter an issue when running into the value 12:"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=9247ebe8-5ac1-4783-8cce-ae4c01234a3a&start=0.869149"},
        {"type":"subtitle","info":"A More Refined Approach to Multi-Value Nodes"},
        {"type":"text","info":"One potential solution would be if we had a node pointer for every possible child path. If we have two values in the nodes, say n1 and n2, then there would be three ranges where a child node could be placed."},
        {"type":"text","info":"- child < n1"},
        {"type":"text","info":"- n1 < child < n2"},
        {"type":"text","info":"- n2 < child"},
        {"type":"text","info":"Next, let's consider a scenario where the node can hold three values, n1, n2, and n3. There would be four ranges where a child node could be placed."},
        {"type":"text","info":"- child < n1"},
        {"type":"text","info":"- n1 < child < n2"},
        {"type":"text","info":"- n2 < child < n3"},
        {"type":"text","info":"- n3 < child"},
        {"type":"text","info":"This pattern will continue for any value of n greater than or equal to 2, there will be n+1 possible ranges for children. So any node with n values should contain n+1 node pointers to reach those locations. Let us revisit the scenario in Video 2, except the nodes containing 2 values have 3 node pointers. Now we can insert 12 into the tree as shown below."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=8ff21ba4-27aa-4c00-bb3c-ae4c0129c4e8&start=0.640373"},
        {"type":"text","info":"Growing the Tree Up instead of Down"},
        {"type":"text","info":"You may have noticed that, in the video above, we encounter another issue, which is that we only divide our original problem in half if we insert the values in a sorted order originally. "},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=c65c9c98-6643-4cbb-9deb-ae4c012b1791&start=1.326088"},
        {"type":"text","info":"The solution is to divide and split the tree up when we encounter a cell overflow. The splitting and catenation processes are initiated at the leaves only and propagate toward the root."},
        {"type":"text","info":"n the video below, I will show this process. The first example is when we insert 4 after inserting 10 and 15. Since 4 is the third value inserted, it would cause an overflow. What you will see is that we will split the 3 values, with 10 being the middle value. Each value will go into their own node, with 4 being the first child of 10, and 15 being the second child of 10."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=2c81d87f-c2e2-41e8-b5b0-ae4c012de590&start=1.107583"},
        {"type":"text","info":"Lecture 22 Introduction Question 2: What is the main drawback of a Binary Search Tree as we have studied to this point?"},
        {"type":"text","info":"Lecture 22 Introduction Question 3: How do \"multi-value\" nodes address this issue, and what is the flaw with the initial attempt we presented at a multi-value node?"},
        {"type":"text","info":"Lecture 22 Introduction Question 4: How does \"splitting and catenating\" from the leaf up to the root address the major issue brought up in Question 2?"},
        {"type":"subtitle","info":"Reading 22.3 - Formally Defining a B-Tree"},
        {"type":"text","info":"In this section, we will formally define the idea of \"multi-value\" nodes as a B Tree."},
        {"type":"text","info":"We will define the number of child pointer nodes as the order of the B Tree."},
        {"type":"text","info":"A B Tree of order m is a tree which satisfies the following properties:"},
        {"type":"text","info":"- Every node has m child pointers"},
        {"type":"text","info":"- Every node has at buckets available for m-1 data elements"},
        {"type":"text","info":"- Every non-leaf node (except root) has at least ⌈m/2⌉ child nodes."},
        {"type":"text","info":"- The root has at least two children if it is not a leaf node."},
        {"type":"text","info":"- All leaves appear in the same level"},
        {"type":"text","info":"Consider a B-Tree of order 3. This means:"},
        {"type":"text","info":"- Every node has 3 child pointers"},
        {"type":"text","info":"- Every node has at buckets available for 2 values data elements."},
        {"type":"text","info":"- Every non-lead node, except the root, has at least  3+1/2 = 2 child nodes."},
        {"type":"text","info":"- The root has at least two children if it is not a leaf node."},
        {"type":"subtitle","info":"Example for B-Tree Insertion for a Degree of 3"},
        {"type":"text","info":"In this video, I present an example of insertion for a B-Tree of degree of 3 with the following insertions: 10, 7, 11, 6, 5, 13, 12, 15"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=e6da0a47-ff9c-4b81-98af-ae4e016c8ba1&start=0.83693"},
        {"type":"subtitle","info":"Example for B-Tree Insertion for a Degree of 4"},
        {"type":"text","info":"The process for inserting and splitting the nodes for an even node and odd node are identical. The difference, and cause of common confusion among students, is where we split the node when we overflow. When the degree is odd, the logic seems simpler: there will be the same number of elements to the left and to the right of the middle element:"},
        {"type":"text","info":"- If we split 7, 10, 11"},
        {"type":"text","info":"-> 10 will be in the middle"},
        {"type":"text","info":"-> 7 will be to the left"},
        {"type":"text","info":"-> 11 will be to the right."},
        {"type":"text","info":"But when we have a degree of 4, the splitting is slightly more complicated. Let's say we have 6, 7, 10, and 11. Where do we split?"},
        {"type":"text","info":"- We could have 7 split up, with 6 to the left in one node, and 10, 11 to the right in another node."},
        {"type":"text","info":"- We could have 10 split up, with 6,7 to the left in one node, and 11 to the right in another node."},
        {"type":"text","info":"The two possible choices are shown below:"},
        {"type":"text","info":"So which do we choose? The solution lies in the idea of an algorithmic approach. The code for the B-Tree splitting must work the same for both even and odd length nodes because we will not know the length until the programmer initializes the B-Tree."},
        {"type":"text","info":"Let's consider the case where the length is odd, and the location to split is obvious:"},
        {"type":"text","info":"- We subtract one from the degree, which is the number of elements in the node, and divide by 2."},
        {"type":"text","info":"-> So (3-1)/2 = 1, so the data element at index 1 is split."},
        {"type":"text","info":"-> Which is why we split 7 up when we split 6, 7, 10"},
        {"type":"text","info":"Performing the same algorithm for an even numbered element, we get the following:"},
        {"type":"text","info":"- We subtract one from the degree, which is the number of elements in the node, and divide by 2."},
        {"type":"text","info":"-> So (4-1)/2 = 1, so the data element at index 1 is split."},
        {"type":"text","info":"-> Which is why we will split 7 up when we split 6, 7, 10, 11"},
        {"type":"text","info":"So the diagram on the left is the approach we will choose."},
        {"type":"text","info":"Design -> Compute -> Then Code"},
        {"type":"text","info":"In this image, I drew out all the possible scenarios for splitting the nodes for orders 3, 4, 5 and 6 to visualize the pattern I would need to program. You can see the benefit of splitting at order / 2 for odd orders and order / 2 - 1 for the even orders here:"},
        {"type":"text","info":"In this video, I present an example of insertion for a B-Tree of degree of 3 with the following same insertions: 10, 7, 11, 6, 5, 13, 12, 15, 16, 17, 18."},
        {"type":"text","info":"- Note: The question \"why do split even sized nodes they way we do?\" is the single most commonly asked question about B-Trees, and I have budgeted time in lecture anticipating that this question will be asked. Likely multiple times."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=7da116db-6483-47f7-bd64-ae4e016f958e&start=0.825646"},
        {"type":"subtitle","info":"Why are B-Trees are often called 2-3 and 2-3-4 Trees?"},
        {"type":"text","info":"Many B-Trees are implements with order = 3 or order = 4 as we've shown in the last two example problems."},
        {"type":"text","info":"B-trees of order m = 4  are also called 2-3-4 trees (or 2-4 trees)."},
        {"type":"text","info":"- “2-3-4” refers to the number of children that a node can have, e.g. a 2-3-4 tree node may have 2, 3, or 4 children."},
        {"type":"text","info":"B-trees of order m = 3 are also called 2-3 trees."},
        {"type":"text","info":"We will note here that the other popular form of B-Trees have higher orders closer to a thousand!"},
        {"type":"text","info":"- Used in practice for databases and filesystems (i.e. systems with very large records)."},
        {"type":"text","info":"- You can learn more about this in the Database Systems Concepts (Links to an external site.) elective course"},
        {"type":"subtitle","info":"Optional: Interesting Historical Note"},
        {"type":"text","info":"There is no formal meaning for the \"B\" in B-Trees. Over the years, many suggestions have been made, including \"Bayer\", \"Boeing\", \"Balanced\", \"Broad\", and \"Bushy.\""},
        {"type":"text","info":"- Based on our study, we could even propose \"Block\" as the meaning of B-Tree since they are design to utilize Disk Blocks."},
        {"type":"text","info":"- Rudolf Bayer once said \"the more you think about what the B in B-trees means, the better you understand B-trees.\""},
        {"type":"text","info":"- He co-invented B-Trees with Edward McCreight, and they wrote in their paper “for reasons clear to American English speakers, the name BM Tree is a non-starter”"},
        {"type":"text","info":"Lecture 22 Introduction Question 5: What is the process for splitting and rising an element into a B-Tree, and what is the design choice we make with even degree node splitting?"},
        {"type":"subtitle","info":"Reading 22.4 - Designing the B-Tree in C++"},
        {"type":"text","info":"Reading Note: This section is a \"skim\" section, which is used to show the design process for the B-Tree in C++. No material from this section will be on the Final Exam, but it is designed to reinforce your understanding of both the material in Reading 22.1-22.3, as well as the Software Engineering principles we covered in Lecture 21."},
        {"type":"text","info":"In this section, I will take you through the process of designing and testing a B-Tree in C++. Throughout this reading, I want you to take away some important approaches to design concepts."},
        {"type":"text","info":"- Notice how I build the B-Tree in pieces. I do not attempt to program the entire Data Structure all at once."},
        {"type":"text","info":"-> Just like modularity in function calls, by breaking the design process into parts, it becomes easier for you to find a logical error later in the design process."},
        {"type":"text","info":"-> This lesson is valuable, even if you never perform work in Databases or use B-Trees, because this approach to programming will save you hours and hours of time troubleshooting coding errors."},
        {"type":"text","info":"-> Notice my approach using Strategic Programming instead of Tactical Programming."},
        {"type":"text","info":"- Notice how I draw the diagrams before I code. (In this reading, I will do it in videos for you.) This approach helps me visualize the pointers when I design the data structure, so I know the exact processes for insertion and deletion prior to coding, which also saves me hours of programming time."},
        {"type":"subtitle","info":"Building the B-Tree Node"},
        {"type":"text","info":"In the code below, which may be found at btree_node1.h (Links to an external site.), I initialize the C++ struct with members order and curr_size. I also initialize vector of data with a size of order_in - 1, and a vector of btree_node pointers with order as the initialize size and all the pointers initialized to NULL."},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/raw/main/Lec22_Reading/include/btree_node1.h"},
        {"type":"text","info":"In its corresponding test suite btree_node1_test.cpp (Links to an external site.), I initialize a btree_node of order 3 and a btree_node of order 4, and test to make sure this node passes valgrind. I template one of them to an int and the other to a std::string, and I do so because I want to ensure my data structure will properly structure the data regardless of templated type."},
        {"type":"text","info":"- The single most common error you will find from code on the internet are data structures that use data and the index of the underlying nodes as the same thing, failing to separate data from structure. The website will claim that the data structure properly templates, but if you template the code to anything other than an integer, the structure literally falls apart inside the machine due to segmentation faults."},
        {"type":"text","info":"-> If you only test with integers, you will only know that your code passes with integers."},
        {"type":"text","info":"-> To paraphrase the TV show \"Game of Throne\" - Code on the internet is dark and full of errors"},
        {"type":"text","info":"- Notice in the B-Tree code above that I do not initialize thee values in data to a specific value. I made this choice so I can use any data type. That line of code initializes everything to the default constructor of the template."},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/raw/main/Lec22_Reading/src/btree_node1_test.cpp"},
        {"type":"subtitle","info":"Initial Insertion: Before Splitting"},
        {"type":"text","info":"Before we split, we need to know that we can insert and re-order valid values in the B-Tree node.  So I design a method insert where I perform an insertion for the case where we insert prior to splitting. In the video, I show the steps for how I will insert 10, 7, and 11 into a B-Tree Node with an order of 4"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=563ca5f0-fd8f-442f-ba55-ae4f00b5348d&start=0.335266"},
        {"type":"text","info":"In my initial coding iteration of the insert method, btree_node2.h (Links to an external site.), I will test for the case where curr_size is less than the order - 1. Just like I did in the video, I will copy the elements over until I find the correct location. In the test suite btree_node2_test.cpp (Links to an external site.), I will insert 10 and then 7 into the integer B-Tree Node, and then I will insert \"Zebra\", \"Aardvark\", and \"Horse\" into the std::string B-Tree Node."},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/raw/main/Lec22_Reading/include/btree_node2.h"},
        {"type":"text","info":"When I run the code and print the contents of the node after each insert, you will see the values are properly sorted:"},
        {"type":"text","info":"-bash-4.2$ make btree_node2_test"},
        {"type":"text","info":"g++ -m64 -std=c++11 -O2 -g -Wall -Wextra -Wconversion -Wshadow -Werror -c src/btree_node2_test.cpp -o objects/btree_node2_test.o"},
        {"type":"text","info":"g++ -m64 -std=c++11 -O2 -g -Wall -Wextra -Wconversion -Wshadow -Werror -o exe/btree_node2_test objects/btree_node2_test.o"},
        {"type":"text","info":"-bash-4.2$ exe/./btree_node2_test"},
        {"type":"text","info":"10"},
        {"type":"text","info":"7 10"},
        {"type":"text","info":"Zebra"},
        {"type":"text","info":"Aardvark Zebra"},
        {"type":"text","info":"Aardvark Horse Zebra"},
        {"type":"subtitle","info":"Initial Encapsulation of the B-Tree Itself"},
        {"type":"text","info":"Eventually, we will be splitting the node in the case where curr_size is equal to order - 1. In order to manage the B-Tree Nodes on the Data Heap, I will encapsulate all the B-Tree Nodes into a B-Tree C++ Struct. Just like the B-Tree Node, I will create an initial test suite to test the construction of the B-Tree Node."},
        {"type":"text","info":"- Creating the initial NULL node: btree1.h (Links to an external site.) and btree1_test.cpp"},
        {"type":"text","info":"In btree2.h (Links to an external site.), we limit the design to the case where the root node is NULL and we insert elements to fill the node. In this case, all we are doing is call the insert that is currently in btree_node2.h (Links to an external site.)."},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/raw/main/Lec22_Reading/include/btree2.h"},
        {"type":"text","info":"Combining Concepts - A Quick Valgrind Note before Split Nodes: When we run make btree2_test, we will create a B-Tree of order 3 and a B-Tree of order 4. We insert 2 elements into the order-3 B-Tree, and we insert 3 elements into the order-4 B-Tree. So we construct and destruct two B-Tree nodes. But if we run valgrind, we get 9 allocs and 9 frees. See if you can think of why this occurs:"},
        {"type":"text","info":"==14395== HEAP SUMMARY:"},
        {"type":"text","info":"==14395== in use at exit: 0 bytes in 0 blocks"},
        {"type":"text","info":"==14395== total heap usage: 9 allocs, 9 frees, 309 bytes allocated "},
        {"type":"text","info":"==14395=="},
        {"type":"text","info":"==14395== All heap blocks were freed -- no leaks are possible"},
        {"type":"text","info":"==14395=="},
        {"type":"text","info":"==14395== For lists of detected and suppressed errors, rerun with: -s"},
        {"type":"text","info":"==14395== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)"},
        {"type":"text","info":"The reason is because of the NULL node pointers when we construct the B-Tree nodes themselves. Remember, just because a pointer is NULL does not mean it is not taking up memory. We still need base pointer blocks to contain the eventual addresses we need to point to."},
        {"type":"text","info":"If they are not pointing to anything, the value inside the pointer is NULL, but it still takes memory to contain the value of NULL, as we see in the diagram below."},
        {"type":"text","info":"- This memory management concept reinforces the concepts of void pointers, casting pointers, and memory allocation on the Data Heap that we learned earlier this semester."},
        {"type":"subtitle","info":"Splitting Nodes from One to Two Levels"},
        {"type":"text","info":"Before implementing the recursive splitting, I worked on getting the split to work from one level to two levels. Once that task was tested, the recursive element builds upon that work."},
        {"type":"text","info":"The code can be found at btree3.h (Links to an external site.). To perform this task, we first need to split the nodes into a parent, and left, and a right node:"},
        {"type":"text","info":"First, the drawing:"},
        {"type":"text","info":"Next, the corresponding code:"},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/raw/main/Lec22_Reading/include/btree3.h"},
        {"type":"text","info":"We will encounter three cases. First, we will have the case that the value we are elevating will be in the left node, the value in the middle, or the in the right node. To determine where the middle should be, I drew out the cases for splitting for cases from Orders 3 through 6."},
        {"type":"text","info":"To set this up, I determined the current middle. We do not have a guarantee that the node will be full, so we divide the current size by two:"},
        {"type":"text","info":"SIZE_T curr_middle;"},
        {"type":"text","info":"// If the order is odd"},
        {"type":"text","info":"if( this->order %2 == 1 )"},
        {"type":"text","info":"     curr_middle    = (this->order) / 2;"},
        {"type":"text","info":"// Else, if the order is even"},
        {"type":"text","info":"else"},
        {"type":"text","info":"     curr_middle    = (this->order) / 2 - 1;"},
        {"type":"text","info":"Next, I keep track of iterators for the left and the right. Since we don't know where right will start, it is not defined yet."},
        {"type":"text","info":"SIZE_T left_iter = 0;"},
        {"type":"text","info":"SIZE_T right_iter;"},
        {"type":"text","info":"In each case, we will add elements to the left until we reach the element to raise. I am also copying the pointers, even though I know we have not yet reached the case where we are recursing, because I want to make sure I am staying in bounds for both the data and the structure."},
        {"type":"text","info":"// Iterate through the elements until we either reach curr_middle or the raised value"},
        {"type":"text","info":"while( left_iter < curr_middle && curr_node->data.at(left_iter) < insert_val ){"},
        {"type":"text","info":"     // Insert the current value into the node"},
        {"type":"text","info":"     left->node_insert( curr_node->data.at(left_iter) );"},
        {"type":"text","info":"     // The pointer to the left in curr node will be the pointer to the left in the new node"},
        {"type":"text","info":"     left->child_ptrs.at(left_iter) = curr_node->child_ptrs.at( left_iter );"},
        {"type":"text","info":"     ++left_iter;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"If we didn't reach curr_middle, the insert_val is on the left :"},
        {"type":"text","info":"if( left_iter < curr_middle ){ left->child_ptrs.at(left_iter) = curr_node->child_ptrs.at(iter)->child_ptrs.at(0); left->node_insert( raised_value ); left->child_ptrs.at(left_iter + 1) = curr_node->child_ptrs.at(iter)->child_ptrs.at(1); // Delete the child pointer since we no longer need that pointer - Essential to pass valgrind delete curr_node->child_ptrs.at(iter); // The we go until the element BEFORE the current middle while( left_iter < curr_middle - 1 ){ left->node_insert( curr_node->data.at(left_iter) ); left->child_ptrs.at(left_iter + 2) = curr_node->child_ptrs.at( left_iter + 1 ); ++left_iter; } // The curr middle needs to be the first element in the parent parent->node_insert( curr_node->data.at(left_iter) ); right_iter = curr_middle; while( right_iter < curr_node->curr_size ){ right->node_insert( curr_node->data.at(right_iter) ); right->child_ptrs.at(right_iter - curr_middle) = curr_node->child_ptrs.at( right_iter ); ++right_iter; } right->child_ptrs.at(right_iter - curr_middle) = curr_node->child_ptrs.at( right_iter );}"},
        {"type":"text","info":"Finally, we have the case where the split is on the right"},
        {"type":"text","info":"// Case where insert_val will be on the right else{ left->child_ptrs.at(left_iter) = curr_node->child_ptrs.at( left_iter ); // Insert the curr_middle in the parent parent->node_insert( curr_node->data.at(curr_middle) ); // Add all the values to the right right_iter = curr_middle + 1; while( right_iter < curr_node->curr_size && curr_node->data.at(right_iter) < raised_value ){ right->node_insert( curr_node->data.at(right_iter) ); right->child_ptrs.at(right_iter - curr_middle - 1) = curr_node->child_ptrs.at( right_iter ); ++right_iter; } right->child_ptrs.at(right_iter - curr_middle - 1) = curr_node->child_ptrs.at(iter)->child_ptrs.at(0); right->node_insert( raised_value ); right->child_ptrs.at(right_iter - curr_middle) = curr_node->child_ptrs.at(iter)->child_ptrs.at(1); if( right_iter < curr_node->curr_size ){ while( right_iter < curr_node->curr_size  ){ right->node_insert( curr_node->data.at(right_iter) ); right->child_ptrs.at(right_iter - curr_middle + 1) = curr_node->child_ptrs.at( right_iter + 1 ); ++right_iter; } } if( this->order % 2 == 1 ) right->child_ptrs.at(right_iter) = curr_node->child_ptrs.at( right_iter ); // Delete the child pointer since we no longer need that pointer - Essential to pass valgrind delete curr_node->child_ptrs.at(iter);"},
        {"type":"subtitle","info":"Testing this iteration"},
        {"type":"text","info":"The commands to run the tests are shown below. I am not testing past order + 1 insertions at this stage, since I have only accounted for one split in my design. Since there is no recursive case coded so far, there is a good chance it will segmentation fault (in fact, it often does if we go past the accounted for test cases. We will address this in the next section). But since we are working on one split only here, this is fine for now. You will see I've accounted for several cases to guarantee exactly one split. They all pass the tests as well as valgrind."},
        {"type":"text","info":"- btree3_int_test is a B-Tree templated to int with an order of 3"},
        {"type":"text","info":"- btree3_str_test is a B-Tree templated to string with an order of 4"},
        {"type":"text","info":"In the video below, I show the run of tests"},
        {"type":"text","info":"make btree3_int_test"},
        {"type":"text","info":"valgrind --leak-check=full exe/./btree3_int_test 11 10 7"},
        {"type":"text","info":"valgrind --leak-check=full exe/./btree3_int_test 7 10 11"},
        {"type":"text","info":"valgrind --leak-check=full exe/./btree3_int_test 11 10 7"},
        {"type":"text","info":"valgrind --leak-check=full exe/./btree3_int_test 10 7 11"},
        {"type":"text","info":"make btree3_str_test"},
        {"type":"text","info":"valgrind --leak-check=full exe/./btree3_str_test Aardvark Horse Manatee Zebra"},
        {"type":"text","info":"valgrind --leak-check=full exe/./btree3_str_test Horse Aardvark Manatee Zebra"},
        {"type":"text","info":"valgrind --leak-check=full exe/./btree3_str_test Horse Manatee Aardvark Zebra"},
        {"type":"text","info":"valgrind --leak-check=full exe/./btree3_str_test Zebra Manatee Horse Aardvark"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=c17f05a4-f48d-4caf-84f5-ae51012ed69d&start=0.224822"},
        {"type":"subtitle","info":"Recursively Splitting Up The B-Tree"},
        {"type":"text","info":"The final recursive design may be found in btree.h (Links to an external site.). We know from our study of B-Trees in the previous sections that, if the level did not split below, then it will not split at higher levels"},
        {"type":"text","info":"// Recursively call the insert node "},
        {"type":"text","info":"bool did_split = insert( curr_node->child_ptrs.at(iter), insert_val );"},
        {"type":"text","info":"// If the previous level did not split, then we do not need to check again"},
        {"type":"text","info":"if( !did_split ){"},
        {"type":"text","info":"return false;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"From there, we must account for two cases. First, that we split below and the current level is not full. Second, that we split below and the current level is full."},
        {"type":"text","info":"In my drawing for the first case, I copy the parent's one data element into the curr_node, and then have the pointers point to the left and the right."},
        {"type":"text","info":"- As I drew the elements, I realized that the old parent would not have a pointer pointing to the value. So I created a temporary pointer and then deleted that node once I updated the parent"},
        {"type":"text","info":"// Update the curr_node to point at parent"},
        {"type":"text","info":"// Create a reference node for deletion"},
        {"type":"text","info":"btree_node<T>* to_delete = curr_node;"},
        {"type":"text","info":"// Set the current node to the parent to recursively return"},
        {"type":"text","info":"curr_node = parent;"},
        {"type":"text","info":"// Delete the node we were pointing to"},
        {"type":"text","info":"delete to_delete;"},
        {"type":"text","info":"// We split again, so we must return true"},
        {"type":"text","info":"return true;"},
        {"type":"text","info":"To fully test the B-Tree, I performed  suite, which I will perform and demonstrate in class. The tests I ran are available at the following page"},
        {"type":"text","info":"Note: We will be going over several tests in detail in Lecture"}
        ]},
    {"unique_id":"6-3","content":[
        {"type":"subtitle","info":"Reading 23.1 - Conceptually Understanding Red-Black Trees"},
        {"type":"text","info":"In this lecture, we are going to study one of the most commonly used data structures: the Red-Black Tree. The Red-Black Tree is used as the underlying data structure for virtually all implementations of trees in programming languages"},
        {"type":"text","info":"- In C++, std::set (Links to an external site.), std::map (Links to an external site.), and std::multiset are implemented using Red-Black Trees"},
        {"type":"text","info":"- In Java, the TreeSet (Links to an external site.) and TreeMap (Links to an external site.) libraries are implemented using a Red-Black Tree"},
        {"type":"text","info":"- In Python, treelib (Links to an external site.) is an installable library using a Red-Black Tree"},
        {"type":"text","info":"So Red-Black Trees are common and important! However, if you've talked to any classmates or friends at other schools, you've likely heard horror stories about trying to learn Red-Black Trees (Links to an external site.)."},
        {"type":"text","info":"Even the Data Structure course at West Point starts out their lecture on Red-Black Trees (Links to an external site.) with the following statement:"},
        {"type":"text","info":"Everybody learns about balanced binary search trees in their introductory computer science classes, but even the stouthearted tremble at the thought of actually implementing such a beast."},
        {"type":"text","info":"Or consider this article published at Harvard: Left-Leaning Red-Black Trees Considered Harmful"},
        {"type":"text","info":"The consternation about the stress of Red-Black Trees is a bit ironic considering the are also called \"Relaxed Balance Trees\".  So how do we learn Red-Black Trees in a way that helps us be more relaxed and balanced? In my experience, students master the Red-Black topic through three iterations."},
        {"type":"text","info":"- First, an analogy of the invention of Red-Black Trees as a unique case of a Order-4 B-Tree."},
        {"type":"text","info":"-> In fact, Red-Black Trees are often referred to as 2-3-4 Color Trees"},
        {"type":"text","info":"- Second, by studying the rotations from an intuitive perspective and then applying the rules, instead of the other way around"},
        {"type":"text","info":"-> We will be talking about Red-Black Trees as an art, and then as a science"},
        {"type":"text","info":"- Third, by drawing the layout in memory, just like we did with Priority Queues, Stacks, Queues, and Deques."},
        {"type":"text","info":"-> The ideas behind coding and implementing Red-Black Trees become clearer"},
        {"type":"subtitle","info":"Real-World Motivation: Drum Memories"},
        {"type":"text","info":"In 1973, computing performance was driving innovation"},
        {"type":"text","info":"- Bottleneck - Drum Memory, which were 180kB of memory"},
        {"type":"text","info":"- To give you perspective: Need 10 of these Drum Memories to hold one Cell Phone photo in 2022"},
        {"type":"text","info":"Let's consider some of the Data Structures we have studied so far, and why they were not advantageous for Drum Memories:"},
        {"type":"text","info":"- Hash Tables - O(1) insert and find"},
        {"type":"text","info":"-> However, they used too much memory in the Hash to prevent collisions"},
        {"type":"text","info":"- AVL Trees and B-Trees"},
        {"type":"text","info":"-> Balancing Mechanisms were too complex"},
        {"type":"text","info":"So there was a need to find a compromise. It is helpful to think of Red-Black Trees as a compromise between the benefits and tradeoffs of various data structures we have studied so far."},
        {"type":"subtitle","info":"Brief Historical Note"},
        {"type":"text","info":"Why Red-Black Trees? From Robert Sedgewick, the inventor of Red-Black Trees:"},
        {"type":"text","info":"\"A lot of people ask why did we use the name red-black. Well, we invented this data structure, this way of looking at balanced trees, at Xerox PARC... But one of the things that was invented there was laser printing and we were very excited to have nearby color laser printer that could print things out in color and out of the colors the red looked the best.\""},
        {"type":"subtitle","info":"Step 1 - Red-Black Trees as a 2-3-4 Tree Variant"},
        {"type":"text","info":"(Unlike the Marvel TV show Loki and the Alligator Loki pictured above, we consider variants to be good!)"},
        {"type":"text","info":"Let's do a Thought Experiment: We will design a 2-3-4 B-Tree, except we will make the following variations in rules"},
        {"type":"text","info":"- Instead of putting the initial B-Tree value in the leftmost node (i.e. keys[0]),"},
        {"type":"text","info":"-> we put that value in the middle slot. Define as Black"},
        {"type":"text","info":"- This means that any value that would be smaller would go in the left slot"},
        {"type":"text","info":"-> Any value that is larger would go in the right slot."},
        {"type":"text","info":"-> Define those as red"},
        {"type":"text","info":"In the video below, I show an example of this analogy with the B-Tree and Red-Black Tree"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=19b76ecc-e2a4-4d47-ba28-ae5301266c55&start=0.975602"},
        {"type":"subtitle","info":"Step 2 - Intuitive Approach to Red-Black Trees"},
        {"type":"text","info":"Compared to B-Trees so the strict AVL trees we briefly discussed, let's relax the balancing requirement"},
        {"type":"text","info":"- Recall c from the Big-O notation requirement"},
        {"type":"text","info":"- What would happen if we said the worst-case would be 2*log(n)"},
        {"type":"text","info":"- Still qualifies as O( lg(n) ) search"},
        {"type":"text","info":"- But reduces the work of balancing"},
        {"type":"text","info":"Let's set some ground rules. To have 2 levels, we will separate the levels with colors, Red and Black"},
        {"type":"text","info":"- To maintain balance, we will have the same number of Black Nodes along each path"},
        {"type":"text","info":"-> This aligns well with our B-Tree analogy since we need one Black node per equivalent B-Tree cell"},
        {"type":"text","info":"- The root must be black"},
        {"type":"text","info":"-> Every element is inserted as a Red node"},
        {"type":"text","info":"- We cannot have consecutive red nodes"},
        {"type":"text","info":"- But we can have consecutive black nodes"},
        {"type":"text","info":"- The root node must be black"},
        {"type":"text","info":"In this video, I go over several examples to show what we would want to do when performing balance with these rules."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=55aa0eda-baf2-4786-a287-ae5301305551&start=0.189498"},
        {"type":"text","info":"Lecture 23 Introduction Question 1: Describe the idea of \"relaxed balanced trees\", and why are they so commonly used in modern programming language libraries?"},
        {"type":"text","info":"Lecture 23 Introduction Question 2: What is the metaphor between a 2-3-4 B-Tree that we studied in Lecture 22 and the Red-Black Tree we are studying in this lecture?"},
        {"type":"text","info":"Lecture 23 Introduction Question 3: What are some of the patterns for rotation you saw in the second video where we performed several insertions and rotations?"},
        {"type":"subtitle","info":"Reading 23.2 - Formally Defining Red-Black Trees"},
        {"type":"text","info":"Now that we've studied some intuitive approaches to relaxed balancing of Binary Search Trees, let's formally define rules for Red-Black Trees and put them into practice."},
        {"type":"text","info":"A Red-Black Tree is a binary search tree that uses locality of relationships recursively to provide a relaxed balanced tree"},
        {"type":"text","info":"- Every node is either red or black."},
        {"type":"text","info":"- The root and all NULL pointers are always black"},
        {"type":"text","info":"- If a node is red, then its children are black."},
        {"type":"text","info":"- All paths from a node to NULL pointers contain the same number of black nodes"},
        {"type":"subtitle","info":"Finding the “relaxed” balanced height"},
        {"type":"text","info":"At least half of all the nodes along any path in this tree are black:"},
        {"type":"text","info":"- bh(root) is at least h(root)/2."},
        {"type":"text","info":"- n≥2bh(root) -1"},
        {"type":"text","info":"- n+1≥2h(root)/2"},
        {"type":"text","info":"- lg(n+1)≥h(root)/2"},
        {"type":"text","info":"- 2*lg(n+1)≥h(root)"},
        {"type":"text","info":"Therefore, a Red-Black Tree with n nodes is guaranteed to have a height of no greater than 2*lg(n+1)"},
        {"type":"text","info":"Going back to Big-O notation."},
        {"type":"text","info":"For a function g(n), we define O(g(n)) as the asymptotic upper bound of the set of functions:"},
        {"type":"text","info":"O( lg(n) ) = {2*lg(n+1) : there exist positive constants c=3 and n0=1 such that 0 < 2*lg(n+1) < 3*lg(n) for all n > 1}"},
        {"type":"subtitle","info":"The Four Insertion Cases"},
        {"type":"text","info":"We now present the four cases for Red-Black Tree insertion. In the videos below, I show the examples comparing the cases with the insertion analogies we presented in the previous section."},
        {"type":"text","info":"Case 0: Root is red"},
        {"type":"text","info":"- Change the root node to black"},
        {"type":"text","info":"- Is the last check"},
        {"type":"text","info":"- Since it's the root, will not affect any of the other balancing mechanisms"},
        {"type":"text","info":"-> Increases the black nodes on each path by 1."},
        {"type":"text","info":"Case 1: Child is red. Parent is red. Uncle is red"},
        {"type":"text","info":"- Re-color Grandparent, Parent, and Uncle"},
        {"type":"text","info":"- No rotation needed, as the subtree now meets the Red-Black tree conditions"},
        {"type":"text","info":"In the video below, we will show two different instances of Case 1, both of which combine to Case 0 at the end. In both examples, the tree starts with 7, 10, 12, where 10 is black, and 7 and 12 are red. In the first example, we insert 9. In the second example, we insert 11. Both of these produce Case 1, which then recolors the root to red, necessitation Case 0."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=9f3fb079-2d06-446f-8f99-ae5301358f88&start=0.368138"},
        {"type":"text","info":"Case 2: Child is red. Parent is red. Uncle is black"},
        {"type":"text","info":"In this case, we need to perform a rotation. The child will become the new parent of the original parent and the child of the original grandparent."},
        {"type":"text","info":"Case 2 is not a terminal case."},
        {"type":"text","info":"In the video below, we have an initial tree with 10 and 15, and then we insert 12. The video only shows the completion of Case 2 to show that Case 2 is not a terminal case, and you can see how Case 3 is set up."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=d4824d03-bd42-4df9-9aff-ae5301389491&start=0.574628"},
        {"type":"text","info":"Case 3: Red node is a child of Parent, and red parent is child of grandparent in the same direction as the parent, and the Uncle is Black"},
        {"type":"text","info":"- Meaning if parent is greater than the grandparent (i.e. right child), then the child is greater than the parent (also right child)"},
        {"type":"text","info":"- If parent is less than the grandparent (i.e. left child), then the child is also less than the parent (also left child)"},
        {"type":"text","info":"Now we perform the rotation in the opposite direction."},
        {"type":"text","info":"In the video below, I show two examples where we just came from Case 2, and need to perform a case 3"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=dbe05edb-28c6-4bbb-95da-ae53013a5889&start=0.031499"},
        {"type":"text","info":"In the final video for this section, I will perform the exact same insertions from Reading 23.1, except I will describe the rules we covered here. Come to class with plenty of questions if you are still confused here."},
        {"type":"text","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=a2fbc3a5-33cb-4b91-8ba5-ae53013be70e&start=0.231944"},
        {"type":"text","info":"Lecture 23 Introduction Question 4: What are the four insertion rules for a Red-Black Tree"},
        {"type":"subtitle","info":"Reading 23.3 - Combining Concepts - The Red-Black Tree in Memory"},
        {"type":"text","info":"In Lecture 8, we went into detail about the layout of the Priority Queue, Stack, Heap, and Deque in the computing memory. In order to better understand how Red-Black Trees are designed, we will revisit memory layout by drawing the final Red-Black Tree."},
        {"type":"text","info":"You may review my implementations of a Red-Black Tree Node (RBTreeNode.h (Links to an external site.)) and the overall Red-Black Tree (RBTree.h (Links to an external site.)) online. For the purposes of this course, I will go over a couple of crucial concepts."},
        {"type":"subtitle","info":"Red-Black Tree Nodes Require a Parent Pointer"},
        {"type":"text","info":"In order to perform the rotations we discussed in the first two sections, we need to be able to \"look back\" at the parent so we can see the color of the sibling and uncle."},
        {"type":"text","info":"- Recall that we couldn't look back in a Singly Linked List"},
        {"type":"text","info":"- We addressed this issue with the prev_node pointer in a Doubly Linked List."},
        {"type":"text","info":"We will do the same thing we a parent pointer as shown below in the code segment from the RBTreeNode below:"},
        {"type":"text","info":"enum COLOR { RED, BLACK };"},
        {"type":"text","info":"template<class T>"},
        {"type":"text","info":"struct RBTNode {"},
        {"type":"text","info":"     T value; // Data itself"},
        {"type":"text","info":"     COLOR color; // Indicates if red or black"},
        {"type":"text","info":"     RBTNode<T> *left, *right, *parent; // Keeps track of the nodes for rotation"},
        {"type":"text","info":"     // Default constructor"},
        {"type":"text","info":"     RBTNode<T>() : value(), color(RED), left(NULL), right(NULL), parent(NULL) { }"},
        {"type":"text","info":"     // Overloaded Constructor"},
        {"type":"text","info":"     RBTNode<T>(const T& valueIn) : value(valueIn), color(RED), left(NULL), right(NULL), parent(NULL) { }"},
        {"type":"text","info":"Using our understanding of the this pointer to a node, as well as our understanding of pointer addresses we can now easily determine if the child is on the left or right of the parent:"},
        {"type":"text","info":"bool isOnLeft() const{"},
        {"type":"text","info":"     return this == parent->left; "},
        {"type":"text","info":"}"},
        {"type":"text","info":"// Returns true if this is the parent's right node"},
        {"type":"text","info":"bool isOnRight() const{"},
        {"type":"text","info":"     return this == parent->right;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"Note: In many of the links I provided in Reading 23.1 where people expressed frustration in designing and implementing a Red-Black Tree, their concept errors tend to occur right here. Many of the concepts we've studied, from void pointers, to memory management, to C structs, to C++ object keywords, have built to this concept. If you understand why isOnLeft and isOnRight work, you are well ahead of your peers."},
        {"type":"text","info":"Now that we can identify if the child is on the left or right, we can now determine the color of the Uncle as well."},
        {"type":"text","info":"// Get the Node's Uncle"},
        {"type":"text","info":"RBTNode<T>* uncle() const{"},
        {"type":"text","info":"     // If no parent or grandparent, then no uncle"},
        {"type":"text","info":"     if (parent == NULL or parent->parent == NULL)"},
        {"type":"text","info":"         return NULL;"},
        {"type":"text","info":"     // Return a pointer to the uncle"},
        {"type":"text","info":"     return (parent->isOnLeft()) ? parent->parent->right : parent->parent->left;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"To conclude, we will compare the addresses of the Red-Black Tree with the logical and physical layout. In the code I have provided at RBTreePrintAddr.cpp (Links to an external site.), we print the contents and addresses of the Level-Order Traversal of the Red-Black Tree."},
        {"type":"text","info":"Given the same example where I insert 2, 4, 6, 10, 9, 8, 12, and 11, the program prints the following outputs (Note: the 0/1 in the print out represents whether it is red (0) or black (1))"},
        {"type":"text","info":"rb_tree*: 0x7ffc9c6e1318"},
        {"type":"text","info":"root : 0xa46010 0xa460b0 "},
        {"type":"text","info":"Value Address  R/B Parent    Left     Right "},
        {"type":"text","info":"4     0xa460b0 1   0         0xa46030 0xa46140"},
        {"type":"text","info":"2     0xa46030 1   0xa460b0  (nil)    (nil)"},
        {"type":"text","info":"9     0xa46140 0   0xa460b0  0xa460e0 0xa461d0"},
        {"type":"text","info":"6     0xa460e0 1   0xa46140  (nil)    0xa46170"},
        {"type":"text","info":"11    0xa461d0 1   0xa46140  0xa46110 0xa461a0"},
        {"type":"text","info":"8     0xa46170 0   0xa460e0  (nil)    (nil)"},
        {"type":"text","info":"10    0xa46110 0   0xa461d0  (nil)    (nil)"},
        {"type":"text","info":"12    0xa461a0 0   0xa461d0  (nil)    (nil)"},
        {"type":"text","info":"We know from our previous studies that the RBTree struct contains a register at 0x7ffc9c6e1318 that contains the address of the root node pointer at 0xa46010. That root node pointer contains the address of the root node at 0xa460b0 containing the value 4."},
        {"type":"text","info":"The final drawing below combines all these concepts. On the Final Exam, you will have one problem where you will be given a set of inputs and will be expected to balance the Red-Black Tree. In the second problem, you will be given a set of addresses, and you will be expected to produce the layout in memory. By doing both problems, you will demonstrate advanced proficiency in both data and structure: "}
        ]},
    {"unique_id":"6-4","content":[
        {"type":"subtitle","info":"Reading 24.1 - Tries"},
        {"type":"text","info":"In this lecture, we are going to study two Data Structures that focus on memory reduction. To learn about these, we will need to study... Batman?"},
        {"type":"text","info":"Well, kind of... In 1959 Office of Naval Research needed to store large amounts of information regarding their storage of ordinances."},
        {"type":"text","info":"- Losing track of where we store bombs would be bad."},
        {"type":"text","info":"The Navy was storing ordinance data on a Datatron 205"},
        {"type":"text","info":"- Stored 32KB of memory total"},
        {"type":"text","info":"As you now know, searching algorithms with high speed, which used Hash functions, required significant memory overhead due to the empty buckets."},
        {"type":"text","info":"Their innovation was to use a “tree” property to store redundant information"},
        {"type":"text","info":"- Each character as a node in a decision tree"},
        {"type":"text","info":"- Sorts words and makes a subtree for each unique sub-word"},
        {"type":"text","info":"- The tree the derived has the following words: CAN, CANDY, COULD, COUNT, FAST, FASTER, FAT, FIT, FOUND, and FOX"},
        {"type":"text","info":"Important Historical Note: The \"Trie\" Data Structure gets its name from retrieval, as is formally pronounced as \"tree\" like the second syllabus in retrieval. However, as Binary Search Trees gained prominence, \"Tries\" became commonly pronounced \"try\" to differentiate them from normal trees."},
        {"type":"text","info":"Other names for a Trie:"},
        {"type":"text","info":"- Digital Search Tree"},
        {"type":"text","info":"- Directed Acyclic Word Graph"},
        {"type":"text","info":"- Suffix Tree"},
        {"type":"text","info":"Amusing Historical Note: Once the Navy upgraded their hardware, they sold their old Datatron 205 to Warner Brothers studios, who used it as a prop for TV shows. The actual computer on which the Trie data structure we will study today was first implemented is the \"Bat Computer\" from the 1960s TV show Batman."},
        {"type":"text","info":"(Batman using search Tries to search for Poison Ivy hiding in Gotham's trees.)"},
        {"type":"video","info":"https://youtu.be/IzaMs5iaX7w"},
        {"type":"subtitle","info":"Setting Up The Logical Representation of a Trie "},
        {"type":"text","info":"In the following video, I show the following problem:"},
        {"type":"text","info":"Given the following dictionary, draw the resulting Trie:"},
        {"type":"text","info":"{aab, aba, acb, acd, bcd, bdf, bfg, d, eaf, efa, efg, Aba, Abb, Abc }"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=4ff39bbf-5d69-41ff-80db-ae530162472b"},
        {"type":"text","info":"Lecture 24 Introduction Question 1: What is the main idea behind a Trie Data Structure?"},
        {"type":"subtitle","info":"Reading 24.2 - Implementing the Trie Data Structure in C++ Code"},
        {"type":"text","info":"Note: Reading 24.2 is a \"skim reading\" section. Nothing we will discuss in this section will be explicitly asked about on a Weekly Survey or Exam. However, one of the most common emerging interview questions is: Design a Trie from Scratch. So I will present my designed solution, as well as several test cases."},
        {"type":"subtitle","info":"Initialize the Trie Node"},
        {"type":"text","info":"The TrieNode, which may be found at TrieNode.h (Links to an external site.), will have its own char so we can print out the values in a traversal. In addition, it will have the following"},
        {"type":"text","info":"- VECTOR <TrieNode *> pointers"},
        {"type":"text","info":"- Have 128 null children"},
        {"type":"text","info":"-> 128 ASCII values"},
        {"type":"text","info":"#define VECTOR std::vector"},
        {"type":"text","info":"#define SIZE_T long unsigned int"},
        {"type":"text","info":"struct TrieNode{"},
        {"type":"text","info":"private:"},
        {"type":"text","info":"     char trie_letter;"},
        {"type":"text","info":"     VECTOR< TrieNode* > child_nodes;"},
        {"type":"text","info":"public:"},
        {"type":"text","info":"     // Default constructor"},
        {"type":"text","info":"     // Must set them to NULL, or you will get a stack overflow"},
        {"type":"text","info":"     TrieNode() : trie_letter(), child_nodes(128, NULL) {}"},
        {"type":"text","info":"     // Constructor with char input"},
        {"type":"text","info":"     TrieNode(const char& char_in) : trie_letter(char_in), child_nodes(128, NULL) {}"},
        {"type":"text","info":"Next, we need to define how to add a character to the Trie. We will first check to ensure the element is in the node (meaning that child is not NULL. Otherwise, we will create a new node, and then update that node's pointer to the new node:"},
        {"type":"text","info":"void addChild( const char& child_char ){"},
        {"type":"text","info":"     if( child_nodes.at( (SIZE_T)child_char ) != NULL )"},
        {"type":"text","info":"         return;"},
        {"type":"text","info":"     TrieNode* temp = new TrieNode(child_char);"},
        {"type":"text","info":"     child_nodes.at( (SIZE_T)child_char ) = temp;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"Next, we need methods to indicate the pointer at a specific char as well as a specific order"},
        {"type":"text","info":"TrieNode* getChildPtr( const char& child_char ){"},
        {"type":"text","info":"     return child_nodes.at( (SIZE_T)child_char );"},
        {"type":"text","info":"}"},
        {"type":"text","info":"TrieNode* getChildPtrOrder( unsigned int order ){"},
        {"type":"text","info":"     return child_nodes.at( order );"},
        {"type":"text","info":"}"},
        {"type":"text","info":"We also have the operators for >, >=, ==, <, and <= to compare the TrieNodes. To review, here is the C++ operator for <:"},
        {"type":"text","info":"bool operator<( const TrieNode& rhs ) const{"},
        {"type":"text","info":"     return trie_letter < rhs.trie_letter;"},
        {"type":"text","info":"}"},
        {"type":"subtitle","info":"Initialize the Trie Object"},
        {"type":"text","info":"The Trie object, which may be Trie.h, uses a recursive function to add the entire string to the Trie data structure. The input value keeps teach of the current index of the string, and we keep adding children as we progress through the string until the word is added."},
        {"type":"text","info":"void addString( TrieNode* theNode, const std::string& word, unsigned int value ){"},
        {"type":"text","info":"     // We haven't reach the end of the word"},
        {"type":"text","info":"     if( value < word.size() ){"},
        {"type":"text","info":"         // Add each character to the word"},
        {"type":"text","info":"         // addChild will not permit duplicates"},
        {"type":"text","info":"         theNode->addChild( word[value] );"},
        {"type":"text","info":"         // Get the TrieNode correlating to the char"},
        {"type":"text","info":"         TrieNode* nextLevel = theNode->getChildPtr( word[value] );"},
        {"type":"text","info":"         // Recursively call the next level"},
        {"type":"text","info":"         addString( nextLevel, word, value + 1);"},
        {"type":"text","info":"     }"},
        {"type":"text","info":"     // If we have reached the end of the word"},
        {"type":"text","info":"     else if( value == word.size() ){"},
        {"type":"text","info":"         // Add a star indicating this is a valid word"},
        {"type":"text","info":"         theNode->addChild( '*' );"},
        {"type":"text","info":"         return;"},
        {"type":"text","info":"     }"},
        {"type":"text","info":"}"},
        {"type":"text","info":"Additionally, we have a similar program to implement a contains method. We pass the current TrieNode pointer, and keep track of the current index. If the value is not found, we return false. If we get to the end (meaning we have exceeded the size of the string and we found all the previous values, we return true."},
        {"type":"text","info":"bool contains( TrieNode* theNode, const std::string& word, unsigned int value ) const {"},
        {"type":"text","info":"     // We haven't reach the end of the word"},
        {"type":"text","info":"     if( value < word.size() ){"},
        {"type":"text","info":"         if( theNode->getChildPtr( word.at(value) ) == NULL )"},
        {"type":"text","info":"             return false;"},
        {"type":"text","info":"         else"},
        {"type":"text","info":"             // Recursively call using the child pointer"},
        {"type":"text","info":"             return contains( theNode->getChildPtr( word.at(value) ), word, value+1 );"},
        {"type":"text","info":"     }"},
        {"type":"text","info":"     // If we have reached the end of the word"},
        {"type":"text","info":"     else{ // if( value == word.size() ){"},
        {"type":"text","info":"         // Add a star indicating this is a valid word"},
        {"type":"text","info":"         if( theNode->getChildPtr( '*' ) == NULL )"},
        {"type":"text","info":"             return false;"},
        {"type":"text","info":"         return true;"},
        {"type":"text","info":"     }"},
        {"type":"text","info":"     return false;"},
        {"type":"text","info":"}"},
        {"type":"subtitle","info":"Testing the Trie"},
        {"type":"text","info":"In the code provided online, I have several tests"},
        {"type":"text","info":"Trie theTrie;"},
        {"type":"text","info":"STRING BAT(\"BAT\");"},
        {"type":"text","info":"STRING BAT_CAVE(\"BAT-CAVE\");        STRING BAT_COMPUTER(\"BAT-COMPUTER\");"},
        {"type":"text","info":"STRING BAT_DANCE(\"BAT-DANCE\");        STRING BAT_DIAMOND(\"BAT-DIAMOND\");"},
        {"type":"text","info":"STRING BAT_PHONE(\"BAT-PHONE\");        STRING BAT_SHARK(\"BAT-SHARK\");"},
        {"type":"text","info":"STRING BAT_SIGNAL(\"BAT-SIGNAL\");    STRING BAT_TASER(\"BAT-TASER\");"},
        {"type":"text","info":"STRING BAT_TRACER(\"BAT-TRACER\");    STRING BATARANG(\"BATARANG\");"},
        {"type":"text","info":"STRING BATGIRL(\"BATGIRL\");            STRING BATMAN(\"BATMAN\");"},
        {"type":"text","info":"STRING BATMOBILE(\"BATMOBILE\");"},
        {"type":"text","info":"In the video, I show the compilation process and test for the Trie Data Structure."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=c2297005-db13-4f5f-8ca2-ae530169a9c9"},
        {"type":"text","info":"In Lecture, we will work on an advanced problem commonly known as Word Search (Links to an external site.), which implements Depth-First Search and Trie data structures together. You will see in that example that we are able to rapidly insert the entire English dictionary and play the Word Search game"},
        {"type":"text","info":"Lecture 24 Introduction Question 2: Describe the approach behind designing a Trie Data Structure from scratch in C++?"},
        {"type":"subtitle","info":"Reading 24.3 - Introduction to Approximation Algorithms"},
        {"type":"text","info":"Note: Reading 24.3 is a \"skim reading\" section. Nothing we will discuss in this section will be explicitly asked about on a Weekly Survey or Exam. However, this section will provide motivation for studying Bloom Filters in section 24.4, as well as the A* Algorithm we will study in Lecture 28."},
        {"type":"text","info":"Furthermore, I link and allude to many concepts you will study in future courses."},
        {"type":"text","info":"In the CSE 40133 Design and Analysis of AlgorithmsLinks to an external site. course, you will study \"Techniques for designing efficient computer algorithms and for analyzing computational costs of algorithms.\" You will cover many of the same data structures and algorithms we have discussed in this course, except you will approach them with greater mathematical rigor."},
        {"type":"text","info":"- Discrete Math is not a pre-requisite for Data Structures, but it is for CSE 40133"},
        {"type":"text","info":"- Data Structures is a pre-requisite for virtually every other class in the CSE curriculum"},
        {"type":"text","info":"To this point in your CS/CPEG careers, you have learned about problems with an exact solution"},
        {"type":"text","info":"- Allocating an exact amount of memory in a static array"},
        {"type":"text","info":"- Re-allocating double the previous memory for a Dynamic Array"},
        {"type":"text","info":"- Key to Location mapping using Hash Tables and a Dynamic Array"},
        {"type":"text","info":"- Performing insertions, deletions, and traversals in Binary Search Trees give the same results, depending on the type of tree."},
        {"type":"text","info":"- Even the C/C++ random number generator (Links to an external site.) is dependent upon an equation and the current clock in the computing device."},
        {"type":"text","info":"-> Remember the Year 2038 (Links to an external site.) error!"},
        {"type":"text","info":"But not every problem on a computer will give the same solution, even with the same inputs."},
        {"type":"text","info":"- Deterministic - An algorithm that, given a particular input, will always produce the same output, with the underlying machine always passing through the same sequence of states"},
        {"type":"text","info":"- Non-Deterministic - An algorithm that, even for the same input, can exhibit different behaviors on different runs. Even on the same machine!"},
        {"type":"text","info":"-> Operating Systems preview: You will need to keep track of race conditions in multi-threaded programs to reduce nondeteministic operation."},
        {"type":"text","info":"-> The way many Operating Systems keep track of multiple threads, since they are commonly built upon the C programming language, are void pointers"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=08a48c3b-5d4d-42e0-8af2-ae5500f17dea"},
        {"type":"text","info":"Interesting Note: Many of my TAs who have taken Operating Systems express gratitude for the void pointers review they get here, because they are really important in that class."},
        {"type":"text","info":"In the Algorithms course, you will learn that not every problem can be solved on a modern computing device given a set of reasonable resources. An approximation algorithm is an efficient algorithm that find approximate solutions to optimization problems."},
        {"type":"text","info":"- In the CSE 30151 Theory of ComputingLinks to an external site. course, you will learn about P and NP (Links to an external site.), which represent classes of solvable problems"},
        {"type":"text","info":"-> P is \"Solvable, Deterministic and Polynomial Time\""},
        {"type":"text","info":"--> O(N), O(N2), O(N3), and so on"},
        {"type":"text","info":"-> NP is \"Non-deterministic problems with solutions that are efficiently verifiable\""},
        {"type":"text","info":"--> Typically reduced to \"yes/no\" problems"},
        {"type":"text","info":"--> O(2N), O(3N)"},
        {"type":"text","info":"Examples of problems in P:"},
        {"type":"text","info":"- Is this array sorted?"},
        {"type":"text","info":"- Does this array have duplicates?"},
        {"type":"text","info":"Examples of problems in NP:"},
        {"type":"text","info":"- In graph G, does there exist a path from s to t of weight > k?"},
        {"type":"text","info":"- In graph G, does there exist a path that visits each vertex exactly once? "},
        {"type":"text","info":"-> Known as a Hamiltonian Path"},
        {"type":"text","info":"Comparing the runtime of P and NP:"},
        {"type":"text","info":"- P: If the runtime for a O(N) problem with 100 elements takes one second"},
        {"type":"text","info":"-> O(N2) will take 100 seconds (a little less than 2 minutes)"},
        {"type":"text","info":"-> O(N3) will take 166 minutes (a little less than 3 hours)"},
        {"type":"text","info":"-> O(N4) will take 11.54 days"},
        {"type":"text","info":"- NP:"},
        {"type":"text","info":"-> O(2N) will take 4.01 * 1020 years"},
        {"type":"text","info":"--> Literally one trillion eons!"},
        {"type":"text","info":"Examples of problems not in NP:"},
        {"type":"text","info":"- Is this the best chess move I can make next?"},
        {"type":"text","info":"-> Hard to verify."},
        {"type":"text","info":"- What is the longest path?"},
        {"type":"text","info":"-> Not a yes/no question."},
        {"type":"subtitle","info":"NP Completeness and Computing"},
        {"type":"text","info":"A form of NP problem you will encounter in your career is known as \"NP Complete\". Formally, this means \"nondeterministic polynomial-time complete\". At this stage in your career, it is sufficient to understand NP Complete in two parts:"},
        {"type":"text","info":"- A brute-force search algorithm can find a solution by trying all possible solutions"},
        {"type":"text","info":"- Once a solution is found, the correctness of each solution can be verified quickly."},
        {"type":"text","info":"What we've learned this semester through our study of complete search and search tree pruning is that using Brute Force to determine a solution is computationally expensive. Depending on the computational resources available to you, they may even be prohibitively expensive."},
        {"type":"text","info":"Optional Reading: Complexity of n-Queens Completion"},
        {"type":"text","info":"Optional Readings: The lectures from the Theory of Computing course on:"},
        {"type":"text","info":"- P and NP"},
        {"type":"text","info":"- NP Completeness"},
        {"type":"subtitle","info":"Heuristics and Approximation Algorithms"},
        {"type":"text","info":"In one of these prohibitively expensive scenarios, what if we don't need an “exact” solution?"},
        {"type":"text","info":"For example,"},
        {"type":"text","info":"- What if the need for performance is high and the memory cost is prohibitive?"},
        {"type":"text","info":"- And what if we have an allowable margin for error?"},
        {"type":"text","info":"Basically, if we sacrifice 3% accuracy, but get the problem from O(2N) down to O(N2),"},
        {"type":"text","info":"- We've potentially reduced the run time from 4.01 * 1020 years to 100 seconds!"},
        {"type":"text","info":"- Definitely enough difference in time to check the solution and re-run our approximation algorithm until we get a correct answer."},
        {"type":"text","info":"For example, Notre Dame alumnus Marty Rose, who is a Senior Software Developer at Google, described a project he worked on:"},
        {"type":"text","info":"- \"I worked for a project that applied machine learning to online advertising.  I would often need to count the number of unique cookies (millions out of billions of records) that reached each stage of our advertising funnel to do some analysis.\""},
        {"type":"text","info":"Heuristic algorithms are designed to solve a problem in a faster and more efficient fashion than traditional methods"},
        {"type":"text","info":"- Sacrificing optimality, accuracy, precision, or completeness for speed."},
        {"type":"text","info":"As we will see in reading 24.4 about Bloom Filters, we can quantify the amount of optimality we are sacrificing in trading off for performance. Here is the rest of Marty's quote on the Advertising problem he worked on at Google:"},
        {"type":"text","info":"- \"I would use bloom filters to do this.  I would check if I had see the cookie before.  If so, I would increment a counter.  Although not perfect, it gave reasonably accurate numbers while also being very memory efficient.\""},
        {"type":"text","info":"Because we are determining an approximate solution, we often refer to heuristics as approximation algorithms."},
        {"type":"subtitle","info":"Optional: P = NP?"},
        {"type":"text","info":"One of the most popular unsolved problems is the P=NP problem. In fact, many consider it the most important open problem in all of computer science."},
        {"type":"text","info":"- The main idea behind P problems is that creating the proof has the same complexity as proving the solution to the proof."},
        {"type":"text","info":"- The main idea behind NP problems is that checking the solution is easy, but creating the proof is hard."},
        {"type":"text","info":"So P = NP would imply that the apparently hard problems actually have relatively easy solutions."},
        {"type":"text","info":"The idea of P=NP was first postulated by mathematician John Nash (who you may know as the man portrayed by Russell Crowe in the movie A Beautiful Mind (Links to an external site.)) and is famous for his contributions to Game Theory."},
        {"type":"text","info":"Here are his comments in his \"Letter to the National Security Agency (Links to an external site.)\""},
        {"type":"text","info":"- “Now my general conjecture is as follows: for almost all sufficiently complex types of enciphering, especially where the instructions given by different portions of the key interact complexly with each other in the determination of their ultimate effects on the enciphering, the mean key computation length increases exponentially with the length of the key, or in other words, the information content of the key ... The nature of this conjecture is such that I cannot prove it, even for a special type of ciphers. Nor do I expect it to be proven.” —John Nash"},
        {"type":"text","info":"If P=NP, then every mathematical proof can be automated!"},
        {"type":"text","info":"- P=NP would mean checking a proof is roughly as easy as creating the proof in every case."},
        {"type":"text","info":"- \"The mental effort of the mathematician in the case of yes-or-no questions could be completely replaced by machines\" - Scott Aaronson"},
        {"type":"text","info":"While the yes/no solution to the P=NP problem is not known, the prevailing wisdom is that P ≠ NP"},
        {"type":"text","info":"- An argument in favor of P ≠ NP: If P = NP, then the world would be a profoundly different place than we usually assume it to be. There would be no special value in \"creative leaps,\" no fundamental gap between solving a problem and recognizing the solution once it's found."},
        {"type":"text","info":"- An argument in favor of P = NP:"},
        {"type":"subtitle","info":"Optional: Millennium Prize Problems"},
        {"type":"text","info":"In 2000, the Clay Mathematics Institute set up $1,000,000 \"Millennium Prize Problems\" for the solution of each of seven problems. (Links to an external site.) What I want you to take away is that there are many problems that have not yet been formally solved, which means that there are problems that are not yet solvable on a computer."},
        {"type":"text","info":"- Hodge Conjecture (Links to an external site.)"},
        {"type":"text","info":"- Poincare Conjecture (Solved by Grigoriy Perelman (Links to an external site.))"},
        {"type":"text","info":"- Riemann hypothesis"},
        {"type":"text","info":"- Yang-Mills existence and mass gap"},
        {"type":"text","info":"- Navier-Stokes existence and smoothness"},
        {"type":"text","info":"- Birch and Swinnerton-dyer conjecture (Links to an external site.)"},
        {"type":"text","info":"- P=NP"},
        {"type":"text","info":"-> If true, proof might allow you to trivially solve all of these problems."},
        {"type":"text","info":"Lecture 24 Introduction Question 3: What is a Heuristic and what are the benefits of using a heuristic to solve a problem in a computer?"},
        {"type":"subtitle","info":"Reading 24.4 - Bloom Filters"},
        {"type":"text","info":"A bloom filter is a space efficient, probabilistic data structure that is used to tell whether a member is in a set."},
        {"type":"text","info":"In the diagram below is an example of a Bloom Filter"},
        {"type":"text","info":"- x,y,z are hash functions"},
        {"type":"text","info":"- When a value is put in the bloom filter, all three are marked as 1"},
        {"type":"text","info":"-> w is the value being verified in the Bloom Filter"},
        {"type":"text","info":"- If all three elements are true, then the element is in the Filter"},
        {"type":"text","info":"Bloom filters have a space advantage over other data structures"},
        {"type":"text","info":"- Use a \"yes/no\" approach"},
        {"type":"text","info":"-> Use std::bitset to implement in C++"},
        {"type":"text","info":"-> Meaning we can reduce to a polynomial problem"},
        {"type":"text","info":"- Most of these require storing at least the data items themselves"},
        {"type":"text","info":"- Linked structures incur an additional linear space overhead for pointers."},
        {"type":"text","info":"A Bloom filter with 1% error and an optimal value of k"},
        {"type":"text","info":"- Requires only about 9.6 bits per element — regardless of the size of the elements."},
        {"type":"text","info":"Important Note: No Deletion from a Bloom Filter"},
        {"type":"text","info":"- Use multiple hash functions to determine which bits to mark"},
        {"type":"text","info":"-> Two values can generate a '1' for one of the hash functions"},
        {"type":"text","info":"Erase is not possible with bitset since that would introduce false negatives"},
        {"type":"text","info":"- Search is probabilistic:"},
        {"type":"text","info":"- Returns false if definitely not in set"},
        {"type":"subtitle","info":"Determining the number of hash functions in a Bloom Filter"},
        {"type":"text","info":"The accuracy of the Bloom Filter is dependent upon the number of Hash Functions we look up."},
        {"type":"text","info":"- The more Hash Functions, the more bits we require"},
        {"type":"text","info":"Intuitively, this makes sense. Since we are trading accuracy for space efficiency, then the more accurate we make the Bloom Filter, the more memory it will consume."},
        {"type":"text","info":"Given a desired error rate (e) and an anticipated number of elements (n), we can find the optimal settings of m, the size of the table, and k, the number of hash functions:"},
        {"type":"text","info":"e = desired error rate"},
        {"type":"text","info":"n = number of elements"},
        {"type":"text","info":"k = -log2(e)  # number of hash functions"},
        {"type":"text","info":"m = kn/ln(2)  # number of bits"},
        {"type":"text","info":"Example Problem:"},
        {"type":"text","info":"Given a desired error rate (6.25%) and an anticipated number of elements of 1000 signed integers, state how many hash functions and bits would be required in the Bloom Filter and the improvement in memory."},
        {"type":"text","info":"Solution:"},
        {"type":"text","info":"k = -log2(0.0625) = log2( 1 / 0.0625 ) = log2( 16 ) = 4"},
        {"type":"text","info":"- Therefore, we will need four separate Hash Functions"},
        {"type":"text","info":"m = kn/ln(2) = 4*1000 / ln(2) = 5770.78"},
        {"type":"text","info":"- Therefore, we need 5771 bits in the Bloom Filter"},
        {"type":"text","info":"- Therefore, we will need 5771 bits"},
        {"type":"text","info":"1000 signed integers requires 1000*4*8 bits = 32,000 bits"},
        {"type":"text","info":"The improvement in memory is 1 - ( 5771 / 32000 ) = 0.81965625"},
        {"type":"text","info":"- Therefore, we have an 81.965% improvement in memory"},
        {"type":"text","info":"This Bloom Filter gives"},
        {"type":"text","info":"- An improvement in memory of 81.965% "},
        {"type":"text","info":"- An improvement in search from O(N) to O(1)"},
        {"type":"text","info":"-> Four hash calculations instead of an average of 1000/2 comparisons"},
        {"type":"text","info":"- In exchange for a 6.25% reduction in accuracy."},
        {"type":"text","info":"Lecture 24 Introduction Question 4: What is a Bloom Filter and how do we calculate the size and number of Hash Functions in the Bloom Filter?"}
        ]},

    {"unique_id":"7-1","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},
    {"unique_id":"7-2","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},
    {"unique_id":"7-3","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},
    {"unique_id":"7-4","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},

    {"unique_id":"8-1","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},
    {"unique_id":"8-2","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},
    {"unique_id":"8-3","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},
    {"unique_id":"8-4","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]}

]



