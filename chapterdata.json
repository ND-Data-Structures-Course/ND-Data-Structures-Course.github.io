[
    
    {"unique_id":"1-1","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},
    {"unique_id":"1-2","content":[
        {"type":"subtitle","info":"Section 2.1 - Writing and Compiling Basic Programs"},
        {"type":"text","info":"A challenge many students have when beginning the Data Structures course is that they struggle with the idea that the computer is actually a physical machine, and not a nebulous device where magically fairies fight pointer demons. The first part of the course will drive home the idea that we must learn structure before we can master the use of data. "},
        {"type":"text","info":"So we will start with a seemingly simple piece of code:"},
        {"type":"code","info":"https://raw.githubusercontent.com/mmorri22/sp22-cse-20312/main/Lec02_Reading/nothing.c"},
        {"type":"text","info":"This piece of code takes in no inputs, (seemingly) performs no tasks, and then returns nothing on the output. However, C is a brace procedure language, meaning that tasks are divided up by using braces."},
        {"type":"text","info":"Consider the TV show Avatar: The Last Airbender. For those of you not familiar with the show, the Avatar confronts a character named King Bumi. Bumi appears to have allowed the Fire Nation to conquer his city without a fight. However, Bumi uses this as an opportunity to teach the Avatar about options in fighting. Bumi actually elected to do nothing until the time was right, which allowed him to attack from the inside. A computer is very much the same way: you must first learn that you need act on inputs or deliver the expected outputs, you need to know that they are. So you must learn to code nothing before you can learn to code something."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=e8f33aad-b1e0-4b1e-a363-ae1301491289&start=11.653175"}
        ]},

    {"unique_id":"2-1","content":[
        {"type":"subtitle","info":"Pointer Syntax Review"},
        {"type":"text","info":"In the Lecture 2 reading, we made an analogy between computing memory and the way our brain remembers information. To review, that analogy was"},
        {"type":"text","info":"Registers, like our working memory, are limited, fast, and control how we process information"},
        {"type":"text","info":"Stack, like the Hippocampus, is slightly slower, and \"crams and forgets\" information"},
        {"type":"text","info":"Heap, like the Neocortex, is the slowest, but can be used to structure and store long-term information and data."},
        {"type":"text","info":"So why is knowing memory locations important?"},
        {"type":"text","info":"Registers are extremely limited, and we must use them effectively"},
        {"type":"text","info":"Stack are static - must be known at compile time"},
        {"type":"text","info":"Heap is dynamic - Can reallocate whenever we want"},
        {"type":"text","info":"In this section, we are going to learn about pass by reference, where you pass pointers to information to a function in order to perform a task. In order to master this concept, let's briefly review the syntax of C pointers."},
        {"type":"text","info":"Each pointer contains three elements:"},
        {"type":"text","info":"An initial location (origin)"},
        {"type":"text","info":"Typically the address of a register"},
        {"type":"text","info":"A destination"},
        {"type":"text","info":"Stored in the origin register"},
        {"type":"text","info":"A value"},
        {"type":"text","info":"Information at that destination"},
        {"type":"text","info":"In C, we use & and * to represent pointer information:"},
        {"type":"text","info":"The & indicates the address"},
        {"type":"text","info":"The * indicates we are either allocating a pointer or de-referencing a pointer."},
        {"type":"subtitle","info":"C Pointer Review Code Example "},
        {"type":"text","info":"The second syntax definition is often the most confusing to students. So let's review these concepts through code:"},
        {"type":"text","info":"int x = 5;"},
        {"type":"text","info":"int* int_ptr = &x"},
        {"type":"text","info":"So, what does this mean?"},
        {"type":"text","info":"We create a register containing the value 5, and we label this register x"},
        {"type":"text","info":"We create a second register containing the address of x (&x), and we indicate the data in the register is a pointer by using int*."},
        {"type":"text","info":"We have now established a pointer. Just like the neurons in our brain do in order to connect information"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/3-1.png') }}"},
        {"type":"text","info":"So now let's print the information for each of the following"},
        {"type":"text","info":"The address of x"},
        {"type":"text","info":"The data contained in x"},
        {"type":"text","info":"The address of int_ptr"},
        {"type":"text","info":"The data contained in int_ptr"},
        {"type":"text","info":"The data at the address pointed to by int_pointer"},
        {"type":"text","info":"Recall that the output specifier for addresses is %p, which is for pointer. So we specify we want to print the pointer to the address of x."},
        {"type":"text","info":"fprintf( stdout, \"The address of x = %p\n\", &x );"},
        {"type":"text","info":"Next, we use %d to print the data in x"},
        {"type":"text","info":"fprintf( stdout, \"The data contained in x = %d\n\", x );"},
        {"type":"text","info":"The next task is where students are most likely to be confused coming into this course. Remember that pointers are registers that contain data which is an address. This means that the register has an address as well as contains an address. "},
        {"type":"text","info":"fprintf( stdout, \"The address of int_ptr = %p\n\", &int_ptr );"},
        {"type":"text","info":"fprintf( stdout, \"The data contained in int_ptr = %p\n\", int_ptr);"},
        {"type":"text","info":"Watch this video where I explain the difference between the address of the register containing a pointer and the address that the pointer is pointing to:"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=1aaa7423-5344-46b5-881a-ae150105dc15&start=0"},
        {"type":"text","info":"Finally, to obtain the data at the address we are pointing to, we need to de-reference the pointer. We use the same * character that we used to allocate the pointer in order to de-reference the data."},
        {"type":"text","info":"Putting all the pieces together, we see that the following code segment will produce the resulting register addresses and data. "},
        {"type":"text","info":"#include <stdio.h>"},
        {"type":"text","info":"int main()"},
        {"type":"text","info":"{"},
        {"type":"text","info":"int x = 5;"},
        {"type":"text","info":"int* int_ptr = &x;"},
        {"type":"text","info":"fprintf( stdout, \"The address of x = %p\n\", &x );"},
        {"type":"text","info":"fprintf( stdout, \"The address of int_ptr = %p\n\", &int_ptr );"},
        {"type":"text","info":"fprintf( stdout, \"The data contained in int_ptr = %p\n\", int_ptr);"},
        {"type":"text","info":"fprintf( stdout, \"The data at the address pointed to by int_pointer = %d\n\", *int_ptr );"},
        {"type":"text","info":"return 0;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"In the compile and run, I have highlighted which outputs match (meaning they are C \"synonyms\")"},
        {"type":"text","info":"-bash-4.2$ gcc -Wall -Wconversion -Werror ptr_review.c -o ptr_review"},
        {"type":"text","info":"-bash-4.2$ ./ptr_review"},
        {"type":"text","info":"The address of x = 0x7fff93a47f2c"},
        {"type":"text","info":"The data contained in x = 5"},
        {"type":"text","info":"The address of int_ptr = 0x7fff93a47f20"},
        {"type":"text","info":"The data contained in int_ptr = 0x7fff93a47f2c"},
        {"type":"text","info":"The data at the address pointed to by int_pointer = 5"},
        {"type":"subtitle","info":"The Two Pointer Metaphors"},
        {"type":"text","info":"Over the years, I have found that students understand pointers better in office hours when I use one of these two metaphors"},
        {"type":"text","info":"The Pirate Ship"},
        {"type":"text","info":"The Hungry Pupfessor"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=1252cfdd-64ab-4967-8770-ae150109cb69&start=0"},
        
        
        {"type":"subtitle","info":"Static and Dynamic Arrays"},
        {"type":"text","info":"In this section, we will discuss the difference between static and dynamic arrays. But first, let's review what an array actually is:"},
        {"type":"text","info":"An array is a collection of individual data elements that is:"},
        {"type":"text","info":"Ordered -- we can count off the elements 0,1,2,3,..."},
        {"type":"text","info":"Fixed in size"},
        {"type":"text","info":"Homogeneous -- all of the elements have to be of the same type"},
        {"type":"text","info":"In C and C++, each array has two fundamental properties"},
        {"type":"text","info":"the element type -> Data"},
        {"type":"text","info":"the size - > Structure"},
        {"type":"text","info":"But now we are introducing this idea of pointers as the \"conductor\" of the program. And in Lecture 2, we learned how to allocate a block of memory to a specific pointer, as well as performing pointer arithmetic."},
        {"type":"subtitle","info":"Static Arrays"},
        {"type":"text","info":"A static array is allocated in the stack. When we say the array is static, we mean that we know the full size of the array ahead of time. We can initialize the arrays in one of two ways:"},  
        {"type":"text","info":"data_type variable_name[size];"},
        {"type":"text","info":"Example: int int_array[5];"},
        {"type":"text","info":"data_type variable_name[] = { element1, element2, ..., elementN };"},
        {"type":"text","info":"Example: int int_array[] = {-10, 22, -17, 44, 5 };"},
        {"type":"text","info":"Here is an example of a static array in C. In the for loop, we will print the index, the address of the index, as well as the data contained at the address. Compare the code and the output from compilation:"},
        {"type":"text","info":"#include <stdio.h>"},
        {"type":"text","info":"int main(){"},
        {"type":"text","info":"  int i = 0;"},
        {"type":"text","info":"  int sample[] = {10, 22, -17, 44, 5};"},
        {"type":"text","info":"  for(i = 0; i < 5; i++){"},
        {"type":"text","info":"           fprintf( stdout, \"element = %d, address = %p, data = %d\n\", i, &sample[i], sample[i] );"},
        {"type":"text","info":"  }"},
        {"type":"text","info":"   fprintf( stdout, \"\n\");"},
        {"type":"text","info":"   return 0;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"And here is the compiled run:"},
        {"type":"text","info":"-bash-4.2$ gcc -Wall -Wconversion -Werror static_array.c -o static_array "},
        {"type":"text","info":"-bash-4.2$ ./static_array "},
        {"type":"text","info":"element = 0, address = 0x7ffc78a66b10, data = 10 "},
        {"type":"text","info":"element = 1, address = 0x7ffc78a66b14, data = 22 "},
        {"type":"text","info":"element = 2, address = 0x7ffc78a66b18, data = -17 "},
        {"type":"text","info":"element = 3, address = 0x7ffc78a66b1c, data = 44 "},
        {"type":"text","info":"element = 4, address = 0x7ffc78a66b20, data = 5 "},
        {"type":"text","info":"Note: Notice how the addresses increment by 4. The reason why is that signed integers are 32-bits. A byte is 8 bits, and the memory addresses are represented as bytes. Therefore 32/8 = 4, which is why they increment by 4."},
        {"type":"subtitle","info":"Dynamic Arrays"},
        {"type":"text","info":"A dynamic array is an array allocated on the Data Heap. When we say the array is dynamic, we mean that we do not necessarily know the size of the array at compile time. If we have any scenario where the amount of data increases during the program, we will use dynamic memory."},
        {"type":"text","info":"Almost every data structure we will study in this course addresses some variant of the question: \"how do we efficiently store and access dynamic data in X scenario?\""},
        {"type":"text","info":"A void pointer is the fundamental dynamic array, and casting the pointer informs us what type of data we are implementing."},
        {"type":"text","info":"For example, let's allocate a dynamic array of 10 doubles. I am going to go through this code step-by-step and show you how I allocated the dynamic memory."},
        {"type":"text","info":"We need stdlib.h (C standard library ) in order to be able to implement dynamic memory allocation in C."},
        {"type":"text","info":"#include <stdio.h>"},
        {"type":"text","info":"#include <stdlib.h>"},
        {"type":"text","info":"Recall that we use long unsigned integers allocate memory. Also, we cast a void pointer (returned by malloc) to double pointer to give context to the operating system that the memory we are pointing to must be considered as doubles."},
        {"type":"text","info":"int main(){"},
        {"type":"text","info":"    long unsigned int size = 5;"},
        {"type":"text","info":"    double* dbl_array = (double *)malloc( size * sizeof(double) );"},
        {"type":"text","info":"Since the array is dynamic, we must allocate them individually. I am presenting both the array syntax you are familiar with (dbl_array[2]) as well as pointer arithmetic ( *(dbl_array + 3) ) to indicate they are synonyms. C and C++ interpret dynamic arrays dbl_array[1] and *(dbl_array + 1) the exact same way."},
        {"type":"text","info":"    dbl_array[0] = -12.7;"},
        {"type":"text","info":"    *(dbl_array + 1) = 25.1;"},
        {"type":"text","info":"    dbl_array[2] = -3.3;"},
        {"type":"text","info":"    *(dbl_array + 3) = -15.2;"},
        {"type":"text","info":"    dbl_array[4] = 1; "},
        {"type":"text","info":"To re-enforce the fundamental pointer concepts, I am printing the address where the pointer is contained, as well as the address where the pointer is pointing to on the Heap. (Note: I have a video at the bottom where I will review this code and draw out the memory, so you can refer to that video to gain clarity.)"},
        {"type":"text","info":"    fprintf( stdout, \"dbl_array register at %p\n\", &dbl_array );"},
        {"type":"text","info":"    fprintf( stdout, \"Base address of dbl_array in Heap at %p\n\", dbl_array );"},
        {"type":"text","info":"Finally, I am iterating through the array, printing the addresses and values of the dynamic array elements. Then, we free the array"},
        {"type":"text","info":"    long unsigned int i;"},
        {"type":"text","info":"    for(i = 0; i < size; ++i){"},
        {"type":"text","info":"    fprintf( stdout, \"element = %lu, address = %p, data = %lf\n\", i, dbl_array + i, *(dbl_array + i) );"},
        {"type":"text","info":"    }"},
        {"type":"text","info":"    fprintf( stdout, \"\n\");"},
        {"type":"text","info":"    free( dbl_array );"},
        {"type":"text","info":"    return 0;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"Here is the output run, a drawing of the layout based on these addresses, as well as a video where I explain and draw the memory elements."},
        {"type":"text","info":"-bash-4.2$ gcc -Wall -Wextra -Wconversion -Werror dynamic_array.c -o dynamic_array"},
        {"type":"text","info":"-bash-4.2$ ./dynamic_array"},
        {"type":"text","info":"dbl_array register at 0x7ffd4c2205c8"},
        {"type":"text","info":" Base address of dbl_array in Heap at 0x14a9010"},
        {"type":"text","info":"element = 0, address = 0x14a9010, data = -12.700000"},
        {"type":"text","info":"element = 1, address = 0x14a9018, data = 25.100000"},
        {"type":"text","info":"element = 2, address = 0x14a9020, data = -3.300000"},
        {"type":"text","info":"element = 3, address = 0x14a9028, data = -15.200000"},
        {"type":"text","info":"element = 4, address = 0x14a9030, data = 1.000000"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/3-2.png') }}"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=f00210aa-429e-4e9d-a244-ae150123fd9e&start=0"},
        {"type":"subtitle","info":"Comparing Static and Dynamic Arrays"},
        {"type":"text","info":"Let's compare, and then run memory on the stack and the heap. To review:"},        
        {"type":"text","info":"Stack: int static_array[] = {4, 22, 10, 19};"},
        {"type":"text","info":"Fast access"},
        {"type":"text","info":"Limited amount of memory"},
        {"type":"text","info":"Unsafe to statically re-allocate"},
        {"type":"text","info":"C/C++ explicitly forbid static reallocation"},
        {"type":"text","info":"Java: No static memory allocation at all"},
        {"type":"text","info":"Abstracts pointers from the programmer"},
        {"type":"text","info":"Automatically allocated at compile time"},
        {"type":"text","info":"Heap: int* dyn_arr = (int*)malloc(size);"},
        {"type":"text","info":"Slower"},
        {"type":"text","info":"But much more memory"},
        {"type":"text","info":"Where Ideas will be built"},
        {"type":"text","info":"Remember that the memory is one long slab of silicon with different types built in (SRAM, DRAM). The syntax allows you to determine which type of memory you want to use:"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/3-3.png') }}"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/3-4.png') }}"},
        {"type":"text","info":"The crucial concept to take away is that you want to use static and dynamic memory for the specific situation you want:"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/3-5.png') }}"},
        {"type":"text","info":"To conclude this section, I will show a code sample with both static and dynamic memory. After the code segment, I will present a drawing of the layout of the memory. There are two important things I want to note:"},
        {"type":"text","info":"I have highlighted the line of code printing the addresses of the base address of the static memory in red, as well as the corresponding print out in red. Notice how they print the same address on the Stack. This is because the operating system knows where static memory is located at compile time, so the OS tracks the base address without requiring a pointer. (I will explain again in the video below the print outs)"},
        {"type":"text","info":"Do not free statically allocated memory. You will get a "},
        {"type":"text","info":"#include <stdio.h>"},
        {"type":"text","info":"#include <stdlib.h>"},
        {"type":"text","info":"int main(){"},
        {"type":"text","info":"    int int_static[] = {10, 20, -19, 34};"},
        {"type":"text","info":"   long unsigned int length = 4;"},
        {"type":"text","info":"    int* int_dynamic = (int *)malloc( length * sizeof(int) );"},
        {"type":"text","info":"    int_dynamic[0] = 10;"},
        {"type":"text","info":"    int_dynamic[1] = 20;"},
        {"type":"text","info":"    int_dynamic[2] = -19;"},
        {"type":"text","info":"    int_dynamic[3] = 34;"},
        {"type":"text","info":"    fprintf( stdout, \"Static Memory addresses: %p %p\n\", &int_static, int_static );"},
        {"type":"text","info":"    fprintf( stdout, \"Dynamic Memory addresses: %p %p\n\", &int_dynamic, int_dynamic );"},
        {"type":"text","info":"    long unsigned int iter;"},
        {"type":"text","info":"    for( iter = 0; iter < length; ++iter )"},
        {"type":"text","info":"       fprintf( stdout, \"int_static[%lu] = %d at %p and int_dynamic[%lu] = %d at %p\n\","},
        {"type":"text","info":"            iter, int_static[iter], &int_static[iter], iter, int_dynamic[iter], &int_dynamic[iter] );"},
        {"type":"text","info":"    }"},
        {"type":"text","info":"    // Free dynamically allocated memory"},
        {"type":"text","info":"    free( int_dynamic );"},
        {"type":"text","info":"    // Do NOT free statically allocated memory"},
        {"type":"text","info":"    // free( int_static );"},
        {"type":"text","info":"    return 0;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"Compile and run:"},
        {"type":"text","info":"-bash-4.2$ gcc -Wall -Wextra -Wconversion -Werror static_dynamic.c -o static_dynamic "},
        {"type":"text","info":"-bash-4.2$ ./static_dynamic "},
        {"type":"text","info":" Static Memory addresses: 0x7ffebeb6ab40 0x7ffebeb6ab40 "},
        {"type":"text","info":" Dynamic Memory addresses: 0x7ffebeb6ab38 0x244f010 "},
        {"type":"text","info":" int_static[0] = 10 at 0x7ffebeb6ab40 and int_dynamic[0] = 10 at 0x244f010 "},
        {"type":"text","info":" int_static[1] = 20 at 0x7ffebeb6ab44 and int_dynamic[1] = 20 at 0x244f014 "},
        {"type":"text","info":" int_static[2] = -19 at 0x7ffebeb6ab48 and int_dynamic[2] = -19 at 0x244f018 "},
        {"type":"text","info":" int_static[3] = 34 at 0x7ffebeb6ab4c and int_dynamic[3] = 34 at 0x244f01c "},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/3-6.png') }}"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=6c8d1e0a-6420-48bd-a2a2-ae1501308b72&start=0"},


        {"type":"subtitle","info":"Reading 3.3 - Passing Arrays by Reference in C"},
        {"type":"subtitle","info":"Pass by Value vs Pass by Reference"},
        {"type":"text","info":"Helpful to think of functions as a new working memory"},
        {"type":"text","info":"Completely different set of registers"},
        {"type":"text","info":"Completely different scope"},
        {"type":"text","info":"Changes to a copy in foo do not necessarily get reflected in main"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/3-7.png') }}"},
        {"type":"text","info":"Pass by Value passes a copy of the value"},
        {"type":"text","info":"Consider this: int foo( int x );"},
        {"type":"text","info":"Copy of x passed to value"},
        {"type":"text","info":"Return to a different register"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=0b2c27c2-873b-41ce-9b30-ae1501361e52&start=0"},
        {"type":"subtitle","info":"Pass by Reference"},
        {"type":"text","info":"This is a concept that trips up most new programmers…"},
        {"type":"text","info":"Structure: Pointer addresses are passed by value"},
        {"type":"text","info":"Data: The variable at that address is passed by reference"},
        {"type":"text","info":"You de-reference the pointer in the function"},
        {"type":"text","info":"The data is passed by reference"},
        {"type":"text","info":"Changes to pointer value are lost when the function goes out of scope."},
        {"type":"text","info":"Consider this function : void foo( int* x );"},
        {"type":"text","info":"Address of x passed to foo() and de-references the variable"},
        {"type":"text","info":"Updates and then passes the value back"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=039a9efa-b077-4430-90b9-ae15013721c1&start=0"},
        {"type":"text","info":"We will now present code to demonstrate how this works in memory. The code may be found at pass_by_ref.c (Links to an external site.), and performs the same tasks that were presented in the metaphor video. After the code segment, we will present a sample output run, and then a video explaining the program, as well as drawing out the memory:"},
        {"type":"text","info":"#include <stdio.h>"},
        {"type":"text","info":"void foo( int* x ){"},
        {"type":"text","info":"    fprintf( stdout, \"Working memory (register) address of x in foo            : %p\n\", &x);"},
        {"type":"text","info":"    fprintf( stdout, \"Value of the information inside the register x in foo    : %p\n\", x ); "},
        {"type":"text","info":"    fprintf( stdout, \"Working memory (register) address of de-ferenced x in foo: %p\n\", &*x );"},
        {"type":"text","info":"    fprintf( stdout, \"De-referenced value of x in foo prior to addition        : %d\n\", *x );"},
        {"type":"text","info":"    *x += 2;"},
        {"type":"text","info":"    fprintf( stdout, \"De-referenced value of x in foo after the addition       : %d\n\", *x );"},
        {"type":"text","info":"}"},
        {"type":"text","info":"int main( void ){"},
        {"type":"text","info":"    int x = 4;"},
        {"type":"text","info":"    fprintf( stdout, \"Old x data value in the working memory (register) in main: %d\n\", x);"},
        {"type":"text","info":"    fprintf( stdout, \"Working memory (register) address of x in main           : %p\n\", &x);"},
        {"type":"text","info":"    foo( &x );"},
        {"type":"text","info":"    fprintf( stdout, \"New x data value in the working memory (register) in main: %d\n\", x);"},
        {"type":"text","info":"    return 0;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"Here is the compilation and run"},
        {"type":"text","info":"Old x data value in the working memory (register) in main: 4"},
        {"type":"text","info":"Working memory (register) address of x in main           : 0x7ffc03ec94e4"},
        {"type":"text","info":"Working memory (register) address of x in foo            : 0x7ffc03ec94c8"},
        {"type":"text","info":"Value of the information inside the register x in foo    : 0x7ffc03ec94e4"},
        {"type":"text","info":"Working memory (register) address of de-ferenced x in foo: 0x7ffc03ec94e4"},
        {"type":"text","info":"De-referenced value of x in foo prior to addition        : 4"},
        {"type":"text","info":"De-referenced value of x in foo after the addition       : 6"},
        {"type":"text","info":"New x data value in the working memory (register) in main: 6"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=8ebc0d11-279b-4d23-a612-ae15013ae871&start=0"},
        {"type":"subtitle","info":"Passing Static and Dynamic Arrays by Reference"},
        {"type":"text","info":"In C programs, arrays are passed by reference, since the reference is the base address of the array. So all we have to do in order to pass arrays by reference is pass the value of the base address! Simply put, just pass them by reference the exact way you would define them in main:"},
        {"type":"text","info":"int int_static[]"},
        {"type":"text","info":"int* int_dynamic"},
        {"type":"text","info":"To show the effectiveness, we will modify the static_dynamic.c code to pass both arrays by reference to a function when we print them."},
        {"type":"text","info":"#include <stdio.h>"},
        {"type":"text","info":"#include <stdlib.h>"},
        {"type":"text","info":"void print_arrays( int int_static[], int* int_dynamic, long unsigned int length ){"},
        {"type":"text","info":"    fprintf( stdout, \"Static Memory addresses: %p %p\n\", &int_static, int_static );"},
        {"type":"text","info":"    fprintf( stdout, \"Dynamic Memory addresses: %p %p\n\", &int_dynamic, int_dynamic );"},
        {"type":"text","info":"    long unsigned int iter;"},
        {"type":"text","info":"    for( iter = 0; iter < length; ++iter ){"},
        {"type":"text","info":"        fprintf( stdout, \"int_static[%lu] = %d at %p and int_dynamic[%lu] = %d at %p\n\","},
        {"type":"text","info":"            iter, int_static[iter], &int_static[iter], iter, int_dynamic[iter], &int_dynamic[iter] );"},
        {"type":"text","info":"    }"},
        {"type":"text","info":"}"},
        {"type":"text","info":"int main(){"},
        {"type":"text","info":"    int int_static[] = {10, 20, -19, 34};"},
        {"type":"text","info":"    long unsigned int length = 4;"},
        {"type":"text","info":"    int* int_dynamic = (int *)malloc( length * sizeof(int) );"},
        {"type":"text","info":"    int_dynamic[0] = 10;"},
        {"type":"text","info":"    int_dynamic[1] = 20;"},
        {"type":"text","info":"    int_dynamic[2] = -19;"},
        {"type":"text","info":"    int_dynamic[3] = 34;"},
        {"type":"text","info":"    print_arrays( int_static, int_dynamic, length );"},
        {"type":"text","info":"    // Free dynamically allocated memory"},
        {"type":"text","info":"    free( int_dynamic );"},
        {"type":"text","info":"    return 0;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"And here is the program output:"},
        {"type":"text","info":"Static Memory addresses: 0x7ffc6b561768 0x7ffc6b5617a0"},
        {"type":"text","info":"Dynamic Memory addresses: 0x7ffc6b561760 0x55ac3cf142a0"},
        {"type":"text","info":"int_static[0] = 10 at 0x7ffc6b5617a0 and int_dynamic[0] = 10 at 0x3cf142a0"},
        {"type":"text","info":"int_static[1] = 20 at 0x7ffc6b5617a4 and int_dynamic[1] = 20 at 0x3cf142a4"},
        {"type":"text","info":"int_static[2] = -19 at 0x7ffc6b5617a8 and int_dynamic[2] = -19 at 0x3cf142a8"},
        {"type":"text","info":"int_static[3] = 34 at 0x7ffc6b5617ac and int_dynamic[3] = 34 at 0x3cf142ac"}
       

        ]},




    {"unique_id":"2-2","content":[
        {"type":"subtitle","info":"Pointers to Pointers"}, 
        {"type":"text","info":"In this section, we will describe pointers to pointers. The reason we will cover pointers to pointers is that many advanced data structures we will learn about in this course are pointers to pointers, pointers to structs, or pointers to classes. By introducing and practicing these concepts now, you will be set up for success later in the semester, especially when we cover graphs."},
        {"type":"subtitle","info":"Pointers to Pointers"}, 
        {"type":"text","info":"Sometimes, we need to keep track of arrays of arrays of information. For example, let us consider Pascal's Triangle, a triangular arrangement of numbers that gives the coefficients in the expansion of any binomial expression, such as (x + y)n. The first row is one element with the value 1. The second row contains two elements, both of which contain the value 1. After that, the first and last elements in the row are 1, and the triangle can be filled out from the top by adding together the two numbers just above to the left and right of each position in the triangle."},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/4-1.png') }}"},
        {"type":"text","info":"So how could we represent this in a computing device? Let us presume that we have 6 rows as in the triangle above. We know that the last row requires 6 integers, so we could create 6 arrays with 6 integers. But what do you think an issue with this approach might be?"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/4-2.png') }}"},
        {"type":"text","info":"There is a lot of wasted space in this array of arrays! This approach is an inefficient use of the computer's memory resources. Furthermore, what happens if we are inputting the number of rows in real time? We would need to implement dynamic memory allocation."},
        {"type":"text","info":"So how can we reduce the memory usage while simultaneously ensuring we can allocate memory dynamically? Our solution will be to use pointers to pointers, and then only allocate the amount of memory we need! Here is an example of pointers to pointers drawn out for both Pascal of size 4 and Pascal of size 6, which shows the potential of dynamic memory allocation:"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/4-3.jpeg') }}"},
        {"type":"text","info":"The question becomes how do we allocate pointers to pointers? To understand this, let's revisit how we allocated an array of integers:"},
        {"type":"text","info":"int* int_array = (int *)malloc( array_size * sizeof(int) );"},
        {"type":"text","info":"The (int *) in front of malloc gave context to the void pointer that this is an array of integers"},
        {"type":"text","info":"The array_size is a long unsigned int so we can ensure proper allocation of memory"},
        {"type":"text","info":"The sizeof(int) indicates we need to allocate 32 bits (4 bytes) of memory times for each integer"},
        {"type":"text","info":"The int* int_array is the register containing the base address of the array of integers."},
        {"type":"text","info":"We've also learned that pointers are contained in registers, which means they have physical space. Which means they have a size! Now we will combine these concepts and build a pointer to an array of integer pointers. (In the video after the code segment description, I write the code in C and then draw out what we have completed so far."},
        {"type":"text","info":"int** pascal_array = (int **)malloc( array_size * sizeof( int * ) );"},
        {"type":"text","info":"The (int **) in front of malloc gave context to the void pointer that this is an array of integer pointers"},
        {"type":"text","info":"The array_size is a long unsigned int so we can ensure proper allocation of memory"},
        {"type":"text","info":"The sizeof(int *) indicates we need to allocate 64 bits (4 bytes) for each integer pointer"},
        {"type":"text","info":"The int** int_array is the register containing the base address of the array of integer of integer pointers."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=92efbfa1-c0f1-4691-9d3d-ae16010f5cec&start=0"},
        {"type":"subtitle","info":"Allocating Memory to Pointers of Pointers"}, 
        {"type":"text","info":"The next step is to allocate memory to each individual pointers. I will pass the int** pascal to a function in order to demonstrate the effectiveness of pass by reference, and to promote modularity in programming."},
        {"type":"text","info":"Review: Modularity is breaking down programs into the smallest possible tasks. Using functions to promote modularity is a sign of a strong programmer."},  
        {"type":"text","info":"I will also pass the size of the array with the long unsigned int. Notice in the loop that I allocate"},
        {"type":"text","info":"void alloc_mem( int** pascal, long unsigned int pascal_size ){"},
        {"type":"text","info":"    long unsigned int iter;"},
        {"type":"text","info":"    for( iter = 0; iter < pascal_size; ++iter ){"},
        {"type":"text","info":"        pascal[iter] = (int *)malloc( (iter + 1) * sizeof(int) );"},
        {"type":"text","info":"    }"},
        {"type":"text","info":"}"},
        {"type":"text","info":"In the same vein, I will write another function where I free all the memory allocated to those pointers. This approach ensures we pass valgrind and successfully free all the memory in the computing device. In the video below, I write the code and draw the memory layout of the computing system. I also point out in the video that, whenever I am writing code to structure data with pointers, I ensure I've properly made the malloc and free work properly (i.e. set up the structure) before I design the algorithm (i.e. perform data operations)."},
        {"type":"text","info":"void free_mem( int** pascal, long unsigned int pascal_size  ){"},
        {"type":"text","info":"    long unsigned int iter;"},
        {"type":"text","info":"    for( iter = 0; iter < pascal_size; ++iter ){"},
        {"type":"text","info":"        free ( pascal[iter] );"},
        {"type":"text","info":"    }"},
        {"type":"text","info":"}"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=07aa1614-9006-4433-998b-ae1601184fc5&start=0"},
        {"type":"text","info":"I have included the final solution to setting up and printing the Pascal triangle in the code pascal.c I want you to notice the highlighted line in the valgrind statement. I have asked for 5 lines of Pascal, and the valgrind says I have 6 allocs and 6 frees. Why do you think that is? (Answer after the valgrind statement)"},
        {"type":"text","info":"-bash-4.2$ gcc -Wall -Wconversion -Werror pascal.c -o pascal "},
        {"type":"text","info":"-bash-4.2$ valgrind --leak-check=full ./pascal "},
        {"type":"text","info":"==27735== Memcheck, a memory error detector "},
        {"type":"text","info":"==27735== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al. "},
        {"type":"text","info":"==27735== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info "},
        {"type":"text","info":"==27735== Command: ./pascal "},
        {"type":"text","info":"==27735== "},
        {"type":"text","info":"Enter the size of the Pascal Triangle: 5 "},
        {"type":"text","info":"1 "},
        {"type":"text","info":"1 1 "},
        {"type":"text","info":"1 2 1 "},
        {"type":"text","info":"1 3 3 1 "},
        {"type":"text","info":"1 4 6 4 1 "},
        {"type":"text","info":"==27735== "},
        {"type":"text","info":"==27735== HEAP SUMMARY: "},
        {"type":"text","info":"==27735== in use at exit: 0 bytes in 0 blocks "},
        {"type":"text","info":" ==27735== total heap usage: 6 allocs, 6 frees, 100 bytes allocated "},
        {"type":"text","info":"==27735== "},
        {"type":"text","info":"==27735== All heap blocks were freed -- no leaks are possible "},
        {"type":"text","info":"==27735== "},
        {"type":"text","info":"==27735== For lists of detected and suppressed errors, rerun with: -s "},
        {"type":"text","info":"==27735== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)"},
        {"type":"text","info":"The reason is because we allocate the pointer to the pointers (1 alloc), and then allocate 5 pointer arrays (5 allocs), which gives us 6. Furthermore, each pointer in the int* array is 64 bits (8 bytes), so the pointer to pointers array takes up 5*8 bytes = 40 bytes. Then, here is how much memory each array contains:"},
        {"type":"text","info":"pascal[0] = 1 integer = 4 bytes"},
        {"type":"text","info":"pascal[1] = 2 integers = 8 bytes"},
        {"type":"text","info":"pascal[2] = 3 integers = 12 bytes"},
        {"type":"text","info":"pascal[3] = 4 integers = 16 bytes"},
        {"type":"text","info":"pascal[4] = 5 integers = 20 bytes"},
        {"type":"text","info":"Summing the memory together, we get 40 + 4 + 8 + 12 + 16 + 20, which is 100 bytes, precisely the number that valgrind gave us."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=2254b32c-65ed-447e-bea5-ae160122ec6f&start=0"},
        
        
        
        {"type":"subtitle","info":"The Challenges of Floats and Doubles"},
        {"type":"text","info":"In this section, we will discuss an important concept in programming: the difference between accuracy and precision."},
        {"type":"subtitle","info":"When 0.1 Does Not Equal 0.1: Doubles and Floats are Precise Not Accurate"},
        {"type":"text","info":"Consider this simple C code segment double.c What do you expect to happen?"},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec04_Reading/double.c"},
        {"type":"text","info":"Likely, you guessed that it will print that the values match, and that they will print the values. But here is the actual output. It turns out that they don't match! But why does 0.1 not equal 0.1? Look at the output line I've highlighted as a hint:"},
        {"type":"text","info":"-bash-4.2$ gcc -Wall -Wconversion -Werror double.c -o double "},
        {"type":"text","info":"-bash-4.2$ ./double "},
        {"type":"text","info":"0.100000 0.100000 "},
        {"type":"text","info":"They do not match! "},
        {"type":"text","info":"0x1.9999999999998p-4 0x1.999999999999ap-4 "},
        {"type":"text","info":"0.09999999999999997779554 0.10000000000000000555112 "},
        {"type":"text","info":"It turns out that doubles are double precision floating point values. Meaning they are precise approximations of the number. The line highlighted in red is a representation of the actual physical value stored in the register (printed with %la). Look at the last hex number of each. One is 8 and the other is a. Here are the corresponding binary values"},
        {"type":"text","info":"8 = 1000"},
        {"type":"text","info":"a = 1010"},
        {"type":"text","info":"It turns out that doubles are double precision floating point values. Meaning they are precise approximations of the number. The line highlighted in red is a representation of the actual physical value stored in the register (printed with %la). Look at the last hex number of each. One is 8 and the other is a. Here are the corresponding binary values"},
        {"type":"text","info":"8 = 1000"},
        {"type":"text","info":"a = 1010"},
        {"type":"text","info":"They are physically different values. So why does the first line print both values as 0.1000000? Because the linux system is printing their output approximately to 6 decimal places by default. If you look at the last line of code, I print the values to 23 decimal places of precision (%.23lf). You see the different in the precise values in the last line of the output."},
        {"type":"text","info":"An important takeaway is that floats and doubles are precise, but not accurate."},
        {"type":"subtitle","info":"Case Study: The ESA Ariane 5 Disaster"},
        {"type":"text","info":"I will present a seeimgly simple C program using the Production Quality Compilation Flags "},
        {"type":"text","info":"#include"},
        {"type":"text","info":"int main(){"},
        {"type":"text","info":" float the_float = 3.1415926;"},
        {"type":"text","info":" fprintf( stdout, \"%f\n\", the_float );"},
        {"type":"text","info":" return 0;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"Using normal compilation flags, this program will compile without issue. However, using the PQC flags in this course, this code will not compile! Read the compiler error, and see if you can figure out why..."},
        {"type":"text","info":"-bash-4.2$ gcc -Wall -Wconversion -Werror float_error.c -o float_error "},
        {"type":"text","info":"float_error.c: In function 'main': "},
        {"type":"text","info":"float_error.c:5:2: error: conversion to 'float' alters 'double' constant value [-Werror=conversion] "},
        {"type":"text","info":"float the_float = 3.1415926; "},
        {"type":"text","info":"The computer is defining this issue as a type mismatch because 3.1415926 is a double. And this is being enforced by the -Wconversion flag."},
        {"type":"text","info":"The logical follow up question is: Why would this be important? It turns out the C compiler initializes decimal values to double! But we are putting it in a float"},
        {"type":"text","info":"float = Single Precision Floating Point"},
        {"type":"text","info":"32 bits!"},
        {"type":"text","info":"double = Double Precision Floating Point"},
        {"type":"text","info":"64 bits"},
        {"type":"text","info":"Trying to put a 64 bit value in a 32 bit value"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/4-4.png') }}"},
        {"type":"text","info":"So now let's run the same code, but with the decimal casted to float "},
        {"type":"text","info":"float the_float = (float)3.1415926;"},
        {"type":"text","info":"This code tell the C compiler to initialize 3.1415926 to a 32-bit float, not a double, and and we will see that it compiles"},
        {"type":"text","info":"Most Programmer just don't mess with and always choose double… but why the big fuss?"},
        {"type":"text","info":"To see why, let's evaluate a different code segment (float_ariane_5.c ) In this code, we save a large double into a float. In fact, the number is too large to store in the float, and we get overflow if you compile without the PQC flags."},
        {"type":"text","info":"#include <stdio.h>"},
        {"type":"text","info":"int main( void ){"},
        {"type":"text","info":"    // Largest number that can be save in a float"},
        {"type":"text","info":"    double the_double = 0x1.fffffep+127;"},
        {"type":"text","info":"    float the_float = the_double;"},
        {"type":"text","info":"    fprintf( stdout, \"The double and the float = %lf %f\n\", the_double, the_float );"},
        {"type":"text","info":"    fprintf( stdout, \"Now we add 1 to the_double and try to save to the float!\n\" );"},
        {"type":"text","info":"    // One bit greater than can be held in a float"},
        {"type":"text","info":"    the_double = 0x1.ffffffp+127;"},
        {"type":"text","info":"    the_float = the_double;    // Ariane 5 Error!"},
        {"type":"text","info":"    fprintf( stdout, \"The double and the float = %lf %f\n\", the_double, the_float );"},
        {"type":"text","info":"    return 0;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"Here is error with the PQC flags:"},
        {"type":"text","info":"-bash-4.2$ gcc -Wall -Wconversion -Wextra float_ariane_5.c -o float_ariane_5 "},
        {"type":"text","info":"float_ariane_5.c: In function 'main': "},
        {"type":"text","info":"float_ariane_5.c:8:2: warning: conversion to 'float' from 'double' may alter its value [-Wconversion]"}, 
        {"type":"text","info":" float the_float = the_double; "},
        {"type":"text","info":" ^"},
        {"type":"text","info":"float_ariane_5.c:16:2: warning: conversion to 'float' from 'double' may alter its value [-Wconversion] "},
        {"type":"text","info":" the_float = the_double; // Ariane 5 Error! "},
        {"type":"text","info":"And here is the run without the PQC flags. Notice the inf in the output meaning the float overflowed:"},
        {"type":"text","info":"-bash-4.2$ gcc float_ariane_5.c -o float_ariane_5 "},
        {"type":"text","info":"-bash-4.2$ ./float_ariane_5 "},
        {"type":"text","info":"The double and the float = 340282346638528859811704183484516925440.000000 340282346638528859811704183484516925440.000000 "},
        {"type":"text","info":"Now we add 1 to the_double and try to save to the float! "},
        {"type":"text","info":"The double and the float = 340282356779733661637539395458142568448.000000 inf "},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=60fb8831-2d3d-425d-97db-ae16012e215b&start=0"},
        {"type":"text","info":"So why the big fuss? Consider the Case Study of the Ariane 5 European Space Agency Rocket. In this rocket, sensors measured rocket speed and angle, and the trajectory for Ariane 4 and 5 were significantly different. So there was an error that occurred in the sensors that was not anticipated in Ariane 4, but should have been tested in Ariane 5."},
        {"type":"text","info":"Error checking code tried to pass a 64-bit double into a 32-bit float"},
        {"type":"text","info":"Stored last 32 bits only => Filled with all zeros"},
        {"type":"text","info":"The sensor believed the rocket was 90o off course"},
        {"type":"text","info":"The rocket's self-destruct sequence was initiated"},
        {"type":"text","info":"This error resulted from a similar error to the one that I coded in float_ariane_5.c!"},

        {"type":"subtitle","info":"C Structs"},
        {"type":"text","info":"Up to this point, we have allocated memory for homogeneous structures of data (such as integer arrays). But that is not how life works. Consider information for a student:"},
        {"type":"text","info":"Name"},
        {"type":"text","info":"Age"},
        {"type":"text","info":"GPA"},
        {"type":"text","info":"Dorm Room"},
        {"type":"text","info":"Address"},
        {"type":"text","info":"Courses"},
        {"type":"text","info":"All of this information is conveyed in different ways, meaning we need different types of data to represent one student! We can represent a Data Structure using a Struct"},
        {"type":"subititle","info":"C Structs"},
        {"type":"text","info":"Struct: derived data type composed of members that are each fundamental or derived data types"},
        {"type":"text","info":"Helpful for clusters of information"},
        {"type":"text","info":"Struct address is the same as the address of the first variable in the struct, next variables are consecutive in memory"},
        {"type":"text","info":"typedef: keyword that allows you to define your own data type (only needed in C)"},
        {"type":"text","info":"Notice how I have defined the struct as simple both before and after the braces. This ensure we can allocate space when we define the struct. Furthermore, I have put the keyword typedef so we do not need to use the struct keyword in main."},
        {"type":"text","info":"Simply put: if you define your C structs in this format, this approach will make your program process much simpler when you implement them."},
        {"type":"text","info":"typedef struct simple{"},
        {"type":"text","info":"     int the_int;"},
        {"type":"text","info":"     double the_double;"},
        {"type":"text","info":"     float the_float;"},
        {"type":"text","info":"} simple;"},
        {"type":"subtitle","info":"Static C Structs"},
        {"type":"text","info":"In order to access a static C struct, we use a period to access the element"},
        {"type":"text","info":"simple_str.the_float"},
        {"type":"text","info":"We will now build a C struct on the stack. Recall that when we build data on the stack, that we can access the data in real time akin to how we access registers. In this code segment, I have also printed out the addresses of the struct using the &. "},
        {"type":"text","info":"#include <stdio.h>"},
        {"type":"text","info":"// struct definition"},
        {"type":"text","info":"typedef struct simple{"},
        {"type":"text","info":"    int the_int;"},
        {"type":"text","info":"    float the_float;"},
        {"type":"text","info":"    double the_double;"},
        {"type":"text","info":"} simple;"},
        {"type":"text","info":"int main(){"},
        {"type":"text","info":"      //create a struct on the stack"},
        {"type":"text","info":"      simple simple_str = {-14, (float)22.7, 9.2 };"},
        {"type":"text","info":"      fprintf( stdout, \"%p\n\", &simple_str);"},
        {"type":"text","info":"      fprintf( stdout, \"%d %p\n\", simple_str.the_int, &(simple_str.the_int));"},
        {"type":"text","info":"      fprintf( stdout, \"%f %p\n\", simple_str.the_float, &(simple_str.the_float));"},
        {"type":"text","info":"      fprintf( stdout, \"%lf %p\n\", simple_str.the_double, &(simple_str.the_double));"},
        {"type":"text","info":"      return 0;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"And here is the output"},
        {"type":"text","info":"-bash-4.2$ gcc -Wall -Wextra -Wconversion -Werror -std=c11 struct_static.c -o struct_static "},
        {"type":"text","info":"-bash-4.2$ ./struct_static "},
        {"type":"text","info":"0x7ffc19fb20b0 "},
        {"type":"text","info":"-14 0x7ffc19fb20b0 "},
        {"type":"text","info":"22.700001 0x7ffc19fb20b4 "},
        {"type":"text","info":"9.200000 0x7ffc19fb20b8 "},
        {"type":"text","info":" In the video, I use the output addresses to "},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=3f4b13f2-13a5-452f-95d2-ae16014fb21b&start=0"},
        {"type":"subtitle","info":"Dynamic C Structs"},
        {"type":"text","info":"In order to allocate a C struct on the Heap, we need to create a pointer, just like we've done with everything else. "},
        {"type":"text","info":"let's revisit how we allocated an array of integers:"},
        {"type":"text","info":"simple* dynamic_struct = (simple *)malloc( sizeof(simple) );"},
        {"type":"text","info":"The (simple *) in front of malloc gave context to the void pointer that this is a pointer to a struct on the Heap"},
        {"type":"text","info":"The sizeof(simple) indicates we need to allocate 128 bits ( 32 + 32 + 64 bytes) of memory times for the int, float, and double"},
        {"type":"text","info":"The simple* dynamic_struct is the register containing the base address of the array of integers."},
        {"type":"text","info":"In order to access a struct pointer, we use the -> in the place where we would use a . in a statically allocated struct"},
        {"type":"text","info":"dynamic_struct->the_int = 45;"},
        {"type":"text","info":"In the file struct_dynamic.c, we have allocated and printed a struct on the Heap, and we have properly freed the memory."},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec04_Reading/struct_dynamic.c"},
        {"type":"text","info":"And here is the output:"},
        {"type":"text","info":"-bash-4.2$ gcc -Wall -Wextra -Wconversion -Werror -std=c11 struct_dynamic.c -o struct_dynamic "},
        {"type":"text","info":"-bash-4.2$ ./struct_dynamic "},
        {"type":"text","info":"0x7ffe07036178 0x15e1010 "},
        {"type":"text","info":"45 0x15e1010 "},
        {"type":"text","info":"-1.100000 0x15e1014 "},
        {"type":"text","info":"45.100000 0x15e1018"},
        {"type":"text","info":" In the video below, I show the output and draw the structure of the data based on the solution:"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=cd924e49-3e51-4041-a74a-ae1601543967&start=0"} 
        ]},



    {"unique_id":"2-3","content":[
        {"type":"subtitle","info":"Recursion"},       
        {"type":"text","info":"In this section, we will describe recursion. The reason we will review recursion early in this course is because many data structures programming techniques, including traversals of lists and trees, as well as sorting algorithms, are strengthened through the use of recursion. The second-most commonly cited concept that students say they struggled to understand is recursion. (The most commonly cited concept is pointers)."},
        {"type":"subtitle","info":"Intro to Recursion"},       
        {"type":"text","info":"Let's compare recursion with an art concept known as the Droste Effect. In this painting by MC Escher, \"Paint Gallery\", the painting has a "},
        {"type":"video","info":"https://www.youtube.com/watch?v=ZMh347hPvzY"},
        {"type":"text","info":"Recursion: The use of a procedure, subroutine, function, or algorithm"},
        {"type":"text","info":"calls itself one or more times"},
        {"type":"text","info":"until a specified condition is met"},
        {"type":"text","info":"the rest of each repetition is processed from last to first."},
        {"type":"text","info":"It is useful to think of the solution to a recursive problem as the elements in a set of solutions."},
        {"type":"text","info":"We will learn an application of recursion to improve computing performance called Dynamic Programming in section 5.2."},
        {"type":"subtitle","info":"Advantages and Disadvantages of Recursion"},
        {"type":"text","info":"Main Advantage:"},
        {"type":"text","info":"For some problems, recursion is much simpler to program"},
        {"type":"text","info":"Implementation and exploration of Binary Trees, Sorting algorithms"},
        {"type":"text","info":"Defining objects that have a repeated similar structural form in C++"},
        {"type":"text","info":"Main Disadvantage:"},
        {"type":"text","info":"Every recursive call is saved to the stack"},
        {"type":"text","info":"Potential for Stack Overflow"},
        {"type":"subtitle","info":"A Fundamental Example: Factorial!"},
        {"type":"text","info":"Consider the Factorial:"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/5-1.png') }}"},
        {"type":"text","info":"Similar to a summation, we can use repetitive multiplications to find a solution."},
        {"type":"text","info":"f(n) = n!"},
        {"type":"text","info":"Ex: f(5) = 5 * 4 * 3 * 2 * 1 = 120"},       
        {"type":"text","info":"Think about this problem as f(n) = n * (n - 1)!, and since f(n - 1) = (n - 1)!,"},       
        {"type":"text","info":"Metaphor: Think of recursive solutions as a Russian Nesting Doll. The doll is not complete without all the smaller dolls inside. Similarly, the answer to 5! is not possible without first finding the answer to 4!, 3!, 2!, 1! and 0!. Any computing problem with dependencies like these lend themselves well to recursion (and eventually dynamic programming)"},       
        {"type":"image","info":"{{ url_for('static', filename='contentImages/5-2.png') }}"},
        {"type":"text","info":"Note: The proof below is a quick refresher on why we may claim that 0! is equal to 1. This is essential to understand for this problem, as we are able to design an efficient base case (which I will describe in a moment)."},       
        {"type":"image","info":"{{ url_for('static', filename='contentImages/5-3.png') }}"},
        {"type":"subtitle","info":"Base and Recursive Cases"},       
        {"type":"text","info":"Base Case: Non-recursively defined values that limit or cut off recursion"},
        {"type":"text","info":"Recursive Step: Recursive definition or reapplication of function on new subset."},
        {"type":"text","info":"The next thing to do is think about the base case, what is the simplest input that the function can just return without doing many operations ? In this case,   n = 0, the function just returns 1."},
        {"type":"text","info":"Let's consider a code example (which may be found at fact.c (Links to an external site.)), which has the base and recursive cases for the Factorial. In this example, i == 0 is the base case, and the recursive case is return i * factorial(i-1);"},
        {"type":"text","info":"unsigned int factorial(unsigned int i){"},
        {"type":"text","info":"  if(i == 0)"},
        {"type":"text","info":"    return 1;"},
        {"type":"text","info":"  return i * factorial(i-1);"},
        {"type":"text","info":"}"},
        {"type":"subtitle","info":"Simple Recursive Trace Example"},
        {"type":"text","info":"A simple way of determining the operation of a recursive function is tracing out its operation. In the video below, I show how the factorial operation works recursively."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=d31228df-e0c3-45df-a5e1-ae18012e29dd&start=0"},
        {"type":"subtitle","info":"Recursion on the Stack"},
        {"type":"text","info":"Let's revisit our metaphor of computing as the mechanization of thought in order to help you better picture recursion in your mind. Since recursive calls are function calls, each call gets its own set of registers. We see in the video that the recursive calls are allocated their own set of registers (octopus), and then when we are done with them, the memory in the registers and stack is freed."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=c7ec4094-a738-4f82-b167-ae18012f65e9&start=0"},
        {"type":"text","info":"Now let's take that metaphor and correlate it to the actual physical device. We run the same recursive function, but now we see that the stack and registers correlates with C code."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=fb1d4165-1abe-49ad-a47f-ae180128a8aa&start=0"},
        {"type":"text","info":"Helping you Visualize: A more complicated recursive trace:"},
        {"type":"text","info":"In this example, we will walk through the code at trace1.c and trace2.c to help you visualize tracking steps in recursive functions. There is one line of code that is different, but this difference is an example of how to trace recursive functions properly. Note: This video is a good example of how I will expect you to perform a recursive trace problem on Exam 1."},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec05_Reading/trace1.c"},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec05_Reading/trace2.c"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=6861a4ed-0c6b-4a1f-accd-ae180155ac14&start=0"},
        {"type":"subtitle","info":"Binary Recursion"},
        {"type":"text","info":"We define binary recursion as a recursive function that calls a recursive function twice. There are several problems where making precisely two calls to the recursive function is advantageous, such as the divide-and-conquer techniques we will encounter in binary search trees."},
        {"type":"text","info":"Consider as an example the Fibonacci sequence"},
        {"type":"text","info":"Recursive Case: Fib(n) = Fib(n-1) + Fib(n-2)"},
        {"type":"text","info":"Base cases: Fib(0) = 1, Fib(1) = 1"},
        {"type":"text","info":"Here is the code fib.c and a video where I show the recursive trace of the program."},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec05_Reading/fib.c"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=df85ce13-4be4-4732-bc80-ae1801413598&start=0"},
       
       
        {"type":"subtitle","info":"Introduction to Dynamic Programming"},
        {"type":"text","info":"You may have noticed an issue with the Fibonacci sequence code I presented in 5.1. We did a lot of redundant work. How much? Well, consider the chart below, which details the number of recursive function calls we would need in order to calculate the nth Fibonacci number. We would need forty billion calls to find the 50th Fibonacci number. "},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/5-4.png') }}"},
        {"type":"text","info":"So if this is true, why even use recursion at all when we can use while loops? It turns out we can significantly improve the number of calls, and strengthen our understanding of effective programming in the process, by learning about dynamic programming and memoization."},
        {"type":"text","info":"Note: We will learn an introduction to dynamic programming in this course. In the Algorithms course, you will learn mathematical and theoretical applications of dynamic programming. In this course, you will gain a fundamental understanding of dynamic programming in order to better understand effective structuring of data in a computing device. The optional reading for this lecture on the Lecture Notes page is an opportunity for those of you who want to push yourself further than the scope of this course."},
        {"type":"subtitle","info":"Dynamic Programming"},
        {"type":"text","info":"Dynamic programming combines the correctness of complete search and the efficiency of greedy algorithms:"},
        {"type":"text","info":"1. Simplified: Caching results of subproblems in memory to avoid repeated computation."},
        {"type":"text","info":"2. Advanced: A method for efficiently solving a particular set of search and optimization problems where greedy algorithms or brute-force would take much too long."},
        {"type":"text","info":"Generally, we can use dynamic programming to solve problems that require:"},
        {"type":"text","info":"1. Finding an optimal solution - Find a solution that is as large or small as possible."},
        {"type":"text","info":"2. Count the number of solutions - Calculate the total number of possible solutions."},
        {"type":"subtitle","info":"Dynamic Programming, Explained to a Four Year Old"},
        {"type":"text","info":"A mom writes down \"1+1+1+1+1+1+1+1 =\" on a sheet of paper*. \"What's that equal to?\""},
        {"type":"text","info":"Her son counts it out and says \"Eight!\""},
        {"type":"text","info":"The mom then writes down another \"1+\" on the left*. \"What about that?\""},
        {"type":"text","info":"Her son quickly replies \"Nine!\""},
        {"type":"text","info":"\"How'd you know it was nine so fast?\""},
        {"type":"text","info":"\"You just added one more\""},
        {"type":"text","info":"\"So you didn't need to recount because you remembered there were eight! \""},
        {"type":"text","info":"Dynamic Programming is just a fancy way to say 'remembering stuff to save time later'"},
        {"type":"subtitle","info":"Caching: Memoizing Computation"},
        {"type":"text","info":"In a recursive algorithm such as complete search or backtracking, we will sometimes repeat a subproblem.  To avoid this unnecessary duplicate computation:"},
        {"type":"text","info":"Identify these overlapping subproblems"},
        {"type":"text","info":"Cache or memoize the previous results in lookup table and check that before computing."},
        {"type":"text","info":"In some problems, the optimal solution can be constructed efficiently from optimal solutions to its subproblems.  These problems usually look something like this:"},
        {"type":"text","info":"1. Let's say we have a collection of objects called A."},
        {"type":"text","info":"2. For each object o in A we have a “cost,” cost(o)"},
        {"type":"text","info":"3. Find the subset of A with the maximum (or minimum) cost, perhaps subject to certain constraints."},
        {"type":"text","info":"Rather than generate all possible subsets O(2n), build a table where at each step we know the best solution thus far."},
        {"type":"text","info":"1. Identify rows and columns: Rows and columns must be discrete units and usually involve the subsets in question."},
        {"type":"text","info":"2. Define recursive relationships: How does one square depend on another?"},
        {"type":"text","info":"Reconstruct solution: Use built tables to identify and generate final solution."},
        {"type":"text","info":"So how can we improve the operation of the Fibonacci sequence? We can use an array to store the previous solutions. In the video below, I walk through the process of making calls to the array. You will see the benefit of looking up previous solutions in the Fibonacci sequence, which is that we will eliminate redundant recursive calls."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=95f26e46-3655-411a-ac77-ae1801469054&start=0"},
        {"type":"text","info":"The code used to implement the memoized version of the Fibonacci sequence may be found at fib_memo.c, and the code is visible below. Note how we see if the values in the array have been initialized (i.e. not equal to 0) before we make a recursive call at all! If the value exists, we simply return it. Otherwise, we make the recursive call and update the array."},
        {"type":"text","info":"Combining Concepts: The amount of memory used by the program is reduced significantly because we pass the arrays by reference instead of making a copy of the entire array every call."},
        {"type":"text","info":"double Fibonacci( int fib_num, double* fib_nums ){"},
        {"type":"text","info":"    if( fib_nums[fib_num] != 0 )"},
        {"type":"text","info":"        return fib_nums[fib_num];"},
        {"type":"text","info":"    if( fib_num == 0 ){"},
        {"type":"text","info":"       fib_nums[0] = 1;"},
        {"type":"text","info":"    }"},
        {"type":"text","info":"    else if( fib_num == 1 ){"},
        {"type":"text","info":"        fib_nums[1] = 1;"},
        {"type":"text","info":"    }"},
        {"type":"text","info":"    else{ "},
        {"type":"text","info":"        fib_nums[fib_num] = Fibonacci( fib_num - 1, fib_nums ) + Fibonacci( fib_num - 2, fib_nums );"},
        {"type":"text","info":"    }"},
        {"type":"text","info":"    return fib_nums[fib_num];"},
        {"type":"text","info":"}"},
        {"type":"text","info":"Now we can compare the number of calls required to calculate the nth Fibonacci number. You can see that we have significantly improved our programming efficiency. In the case of the 50th fibonacci number, we've reduced the number of calls from forty billion down to 99."},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/5-5.png') }}"}

        ]},



    {"unique_id":"2-4","content":[
        {"type":"subtitle","info":"Sorting Introduction"},
        {"type":"text","info":"Sorting is the process of rearranging a sequence of objects so as to put them in some logical order. Sorting plays a major role in commercial data processing and in modern scientific computing. Applications abound in transaction processing, combinatorial optimization, astrophysics, molecular dynamics, linguistics, genomics, weather prediction, and many other fields. "},
        {"type":"subtitle","info":"Sorting Definitions and Models"},
        {"type":"text","info":"An ordering relation < for keys a, b, and c has the following properties:"},
        {"type":"text","info":"Law of Trichotomy: Exactly one of a < b, a = b, b < a is true."},
        {"type":"text","info":"Law of Transitivity: If a < b, and b < c, then a < c."},
        {"type":"text","info":"An ordering relation with the properties above is also known as a “total order”."},
        {"type":"text","info":"A sort is a permutation (re-arrangement) of a sequence of elements that puts the keys into non-decreasing order relative to a given ordering relation."},
        {"type":"text","info":"x1 ≤ x2 ≤ x3≤ ...≤ xN"},
        {"type":"text","info":"Our primary concern is rearranging arrays of items where each item contains a key. The objective is to rearrange the items such that their keys are in ascending order."},
        {"type":"text","info":"Sorting cost model. When studying sorting algorithms, we count compares and exchanges. For algorithms that do not use exchanges, we count array accesses."},
        {"type":"text","info":"Extra memory. The sorting algorithms we consider divide into two basic types: those that sort in place (no extra memory except perhaps for a small function-call stack or a constant number of instance variables), and those that need enough extra memory to hold another copy of the array to be sorted."},
        {"type":"text","info":"In this lecture, we will focus on sorting in place, with an emphasis on using recursion to improve the sorting operations."},
        {"type":"subtitle","info":"Elementary Sorting - Selection Sort"},
        {"type":"text","info":"Suppose we want to sort a one-dimensional array of integers. One of the simpler sorting algorithms"},
        {"type":"text","info":"Find smallest item."},
        {"type":"text","info":"Swap this item to the front and 'fix' it."},
        {"type":"text","info":"Repeat for unfixed items until all items are fixed."},
        {"type":"text","info":"Example: Consider the following array: 32 15 2 17 19 26 41 17 17"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=71324d58-fd4e-4989-b881-ae1801577d5f&start=0"},
        {"type":"text","info":"Here is a visualization aid:"},
        {"type":"code","info":"https://www.hackerearth.com/practice/algorithms/sorting/selection-sort/visualize/"},
        {"type":"subtitle","info":"Our next improvement - Insertion Sort"},
        {"type":"text","info":"Insertion Sort is our first improvement over Selection Sort. Instead of searching the entire array for the smallest element and then moving it, we select a location and then move the data at that location to the left until it is no longer smaller than the data at the previous array location."},
        {"type":"text","info":"We split the array into a sorted part and an unsorted part."},
        {"type":"text","info":"So initially, the value is unsorted, so you begin at array element 0."},
        {"type":"text","info":"The sorted part will go from the beginning of the array to some index, and the rest of the array will form the unsorted part."},
        {"type":"text","info":"We start by saying that only the first element forms the sorted part."},
        {"type":"text","info":"In each step, we take away one element of the unsorted portion of the array and insert it in its place in the sorted part of the array. This increases the length of the sorted part of the array by one."},
        {"type":"text","info":"We are done after n - 1 steps because we increase the length of the sorted part of the array by 1"},
        {"type":"text","info":"Once the length of the sorted part of the array is n, we know that the array is sorted."},
        {"type":"text","info":"Consider the following example: 22 17 10 84 99 7 36 8 15. The video shows the process for Insertion Sort"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=b0600a10-1bc8-42c0-8342-ae1801598da4&start=0"},
        {"type":"text","info":"Here is a visualization aid:"},
        {"type":"code","info":"https://www.hackerearth.com/practice/algorithms/sorting/insertion-sort/visualize/"},
        {"type":"text","info":"I have provided C code for Insertion Sort:"},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec06_Reading/insert_sort.c"},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec06_Reading/insert_sort.h"},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec06_Reading/run_insert.c"},


        {"type":"subtitle","info":"Merge Sort"},
        {"type":"text","info":"The major challenge with an Insertion Sort is that we have a worst case scenario with we have to iterate through all the elements n2 times (specifically, in the case where they are sorted in the exact opposite order."},
        {"type":"text","info":"We can use recursion to remove the dependency of ordering on the efficiency of the sorting algorithm. "},
        {"type":"subtitle","info":"Merge Sort - Using Binary Recursion to Sort"},
        {"type":"text","info":"The algorithms that we consider in this section is based on a simple operation known as merging: combining two ordered arrays to make one larger ordered array. "},
        {"type":"text","info":"The main idea of merge sort is that we recursively divide the array in half. Once we get to the base case, where the subarray length is 1, then we sort the subarrays as we recombine them recursively."},
        {"type":"text","info":"Base Case:"},
        {"type":"text","info":"If the length of the array is 1"},
        {"type":"text","info":"The singular element is the largest element"},
        {"type":"text","info":"Sorted array = array[0];"},
        {"type":"text","info":"Recursive Case:"},
        {"type":"text","info":"The sorted array sorts the two arrays and returns one array"},
        {"type":"text","info":"An Example Sort: In this video, I will show an example of Merge Sort, with an emphasis on how the algorithm proceeds through the machine recursively. "},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=c4805861-a3e7-4fe2-8bf3-ae1900ea8be8&start=0"},
        {"type":"text","info":"Here is a visualization aid:"},
        {"type":"code","info":"https://www.hackerearth.com/practice/algorithms/sorting/merge-sort/visualize/"},
        {"type":"subtitle","info":"Programming Merge Sort"},
        {"type":"text","info":"I will present my process for implementing Merge Sort in C code. (In the in-class lecture, I will begin by reviewing  this code and taking questions.) While you read this description of the code, I want you to observe the process of writing the code. When I write large programs, I often split them up into several steps in order to produce benchmarks for testing."},
        {"type":"text","info":"Step 1: Setting up the arrays as test cases."},
        {"type":"text","info":"In merge1.c, I set up two arrays to run the algorithm. I purposely selected arrays of two different lengths (odd and even) because I want to test the splitting process with odd and even lengths."},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec06_Reading/merge1.c"},
        {"type":"subtitle","info":"Step 2: Initial Recursive Call"},
        {"type":"text","info":"In my next step, I designed the recursive call steps before I perform the swaps. The merge function in merge2.c will print the indices of the recursive splits."},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec06_Reading/merge2.c"},
        {"type":"text","info":"The base case is the if statement max > min + 1"},
        {"type":"text","info":"For each call, we recursively call the left by going from min to (min + max)/2"},
        {"type":"text","info":"Then, we make the right call by going from (min+max)/2 + 1 to max"},
        {"type":"text","info":"The video below shows an animation of how this code recursively splits the arrays."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=9a696784-4169-40e7-ab68-ae1901064fb0&start=0"},
        {"type":"subtitle","info":"Step 3: The cases when min == max and when min == max - 1"},
        {"type":"text","info":"In my next step, I designed the cases where min == max (when the indices are identical) and when they are separated by 1."},
        {"type":"text","info":"I also have a && case where array[max] < array[min], which means the value to the right is larger than the value to the left. You can see the in merge3.c"},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec06_Reading/merge3.c"},
        {"type":"text","info":" The video below shows an animation of how this code swaps the indices at this stage. Note that the algorithm is not completed. We will complete the final merge in step 4."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=eb5a96e1-1b3e-4c60-b729-ae190108a43f&start=0"},
        {"type":"subtitle","info":"Step 4: Merging arrays when max > min + 1"},
        {"type":"text","info":"In the final step, we will iterate between the two sub arrays. These sub arrays are"},
        {"type":"text","info":"min to (min + max)/2"},
        {"type":"text","info":"(min + max)/2 + 1 to max"},
        {"type":"text","info":"We will create two \"pointers\" (which are actually just the indices of the location, start1 and start2). I also print out the subarray so you can see the stages if you choose to use this code to aid your studies."},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/5-6.png') }}"},
        {"type":"text","info":"Next, I will create a temporary array where I will store the elements we are swapping. I will also create an iterator (arrayIter) to keep track of all the elements. We will update the location of the temp array based on which value in the subarray is larger, and then move those pointers as appropriate. (I have a video after the code segments to help you visualize this process)."},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/5-7.png') }}"},
        {"type":"text","info":"Next, I check to see if we have reached the end of the subarrays and update the values. Then I overwrite the array passed by reference with the sorted values."},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/5-8.png') }}"},
        {"type":"text","info":"Finally, I print the sorted subarray so you can see the intermediate steps."},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/5-9.png') }}"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=cb2ac3da-a019-4b92-a6f7-ae19010d633b&start=0"},
        {"type":"subtitle","info":"Core Ideas Review"},
        {"type":"text","info":"Selection sort: Find the smallest item and put it at the front"},
        {"type":"text","info":"Insertion sort: Figure out where to insert the current item."},
        {"type":"text","info":"Merge sort: Merge two sorted halves into one sorted whole."},


        {"type":"subtitle","info":" Quick Sort"},
        {"type":"text","info":"Improving upon Merge Sort"},
        {"type":"text","info":"Merge Sort is a good algorithm for data structures students to study because they get good practice with recursion and pass by reference of arrays. But we can do better!"},
        {"type":"text","info":"Here is a motivating example. suppose we do the following:"},
        {"type":"text","info":"Read 1,000,000 integers from a file into an array of length 1,000,000."},
        {"type":"text","info":"Merge Sort these integers."},
        {"type":"text","info":"Select one integer randomly and change it."},
        {"type":"text","info":"Sort using algorithm X of your choice."},
        {"type":"text","info":"In the worst case, we have 999,999 inversions."},
        {"type":"text","info":"On arrays with a small number of inversions, insertion sort is extremely fast."},
        {"type":"text","info":"One exchange per inversion (and number of comparisons is similar). "},
        {"type":"text","info":"One exchange per inversion (and number of comparisons is similar). "},
        {"type":"text","info":"Less obvious: For small arrays (N < 15 or so), insertion sort is fastest."},
        {"type":"text","info":"More of an empirical fact than a theoretical one."},
        {"type":"text","info":"Theoretical analysis beyond scope of the course."},
        {"type":"text","info":"Rough idea: Divide and conquer algorithms like Merge Sort spends too much time dividing, but insertion sort goes straight to the conquest."},
        {"type":"text","info":"So the question we should be asking is this: is there a way we can gain the benefits of the average case for Merge Sort's divide and conquer approach while gaining the benefits of Insertion Sort's inversion processes?"},
        {"type":"subtitle","info":"Introduction to Quick Sort"},
        {"type":"text","info":"The next sorting algorithm we will study is the Quick Sort algorithm. Quick Sort is often known as Partition Sort, and is popular because it is not difficult to implement, works well for a variety of different kinds of input data, and is substantially faster than any other sorting method in typical applications. It is in-place (uses only a small amount of space on the stack),"},
        {"type":"text","info":"The basic algorithm. Quicksort is a divide-and-conquer method for sorting. It works by partitioning an array into two parts, then sorting the parts independently."},
        {"type":"text","info":"Interview Question Example: Partitioning - Given an array of colors where the 0th element is white, and the remaining elements are red (less) or blue (greater), rearrange the array so that all red squares are to the left of the white square, and all blue squares are to the right. "},
        {"type":"text","info":"Relative order of red and blues does NOT need to stay the same!"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/6-1.png') }}"},
        {"type":"text","info":"Here are two potential solutions:"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/6-2.png') }}"},
        {"type":"text","info":"So how do we partition?"},
        {"type":"text","info":"Consider this example:"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/6-3.png') }}"},
        {"type":"text","info":"5 is “in its place.” Exactly where it'd be if the array were sorted."},
        {"type":"text","info":"Can sort two halves separately, e.g. through recursive use of partitioning."},
        {"type":"subtitle","info":"The Importance of Shuffling in Quick Sort"},
        {"type":"text","info":"Later in this course, we will learn about Big-O notation. And we will learn that Quick Sort runs in O(n * lg(n)) time. For now, all you need to understand is that we have the occasional worst-case scenario of O(n2) time. This means that the average run time is usually proportional to n * lg(n), but there is an occasional worst case of n2 time. "},
        {"type":"text","info":"Consider the case where the size of the array (n) is equal to 100. This means the number of operations required to complete the task is proportional to:"},
        {"type":"text","info":"n = 100, n2 = 100*100 = 10,000"},
        {"type":"text","info":"n = 100 n* lg(n) = 100 * 6.643 = 664.3"},
        {"type":"text","info":"The worst case is when the pivot always lands at beginning of array. It turns out that randomly shuffling the array prior to the Quick Sort is a quick way of ensuring that you really do end up with all cases turning up with equal probability, and therefore that this worst case will be as rare as any other case."},
        {"type":"text","info":"We can make this claim because the random shuffle also shuffles all the subarrays uniformly, giving the array the property that its two subarrays are also in random order. This fact is crucial to the algorithm's predictability."},
        {"type":"text","info":"In quick1.c we have implemented a C function, shuffle, which randomly swaps locations in the array to generate a randomly shuffle. "},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec06_Reading/quick1.c"},
        {"type":"text","info":"And here is the output run three separate times to show the effectiveness of the shuffle"},
        {"type":"text","info":"-bash-4.2$ gcc -Wall -Wextra -Wconversion -Wconversion -std=c11 quick1.c -o quick1 "},
        {"type":"text","info":"-bash-4.2$ ./quick1 "},
        {"type":"text","info":"Initial Array 1: 22 13 33 44 -10 55 88 27 "},
        {"type":"text","info":"Shuffled Array 1: -10 55 27 33 22 88 13 44 "},
        {"type":"text","info":"Initial Array 2: 14 99 42 77 2 66 1 8 44 "},
        {"type":"text","info":"Shuffled Array 2: 1 14 42 99 2 77 44 8 66 "},
        {"type":"text","info":"-bash-4.2$ ./quick1 "},
        {"type":"text","info":"Initial Array 1: 22 13 33 44 -10 55 88 27 "},
        {"type":"text","info":"Shuffled Array 1: 33 -10 22 44 27 55 13 88 "},
        {"type":"text","info":"Initial Array 2: 14 99 42 77 2 66 1 8 44 "},
        {"type":"text","info":"Shuffled Array 2: 8 14 99 1 77 42 44 66 2 "},
        {"type":"text","info":"-bash-4.2$ ./quick1 "},
        {"type":"text","info":"Initial Array 1: 22 13 33 44 -10 55 88 27 "},
        {"type":"text","info":"Shuffled Array 1: 44 22 55 88 27 -10 13 33 "},
        {"type":"text","info":"Initial Array 2: 14 99 42 77 2 66 1 8 44 "},
        {"type":"text","info":"Shuffled Array 2: 44 14 99 2 42 1 66 77 8 "},
        {"type":"subtitle","info":"The Partitioning Algorithm"},
        {"type":"text","info":"We will now determine the process of partitioning the array. To start, we set the left most value as the pivot. We then set two iterators i and j. "},
        {"type":"text","info":"We scan left, meaning we move i until either array[i] > array[pivot] OR i == j - 1"},
        {"type":"text","info":"If j != i + 1, then we move j until either array[j] < array[pivot] OR i == j - 1"},
        {"type":"text","info":"We then swap array[i] and array[j] if array[i] > array[j]"},
        {"type":"text","info":"At the end of this iteration, make a final exchange where we swao array[pivot] and array[i]."},
        {"type":"text","info":"Here is an example from the last shuffled. You will see that the all the values to the left of array[i] are less than array[i], and all the elements to the right of array[i] are greater than array[i]. This property means that array[i] is at the correct final location of the sort! We solved the interview question above."},
        {"type":"text","info":"Operation                pivot i  j   array values"},
        {"type":"text","info":"Initial Values           0     1  7   44 14 99 2 42 1 66 77"},
        {"type":"text","info":"Scan left, Scan Right    0     2  5   44 14 99 2 42 1 66 77"},
        {"type":"text","info":"Swap?                    0     2  5   44 14 1 2 42 99 66 77"},
        {"type":"text","info":"Scan left, Scan Right    0     4  3   44 14 1 2 42 99 66 77"},
        {"type":"text","info":"Swap?                    0     4  3   44 14 1 2 42 99 66 77"},
        {"type":"text","info":"Final Exchange           0     4  3   42 14 1 2 44 99 66 77"},
        {"type":"text","info":"Comparison                            42 14 1 2 44 99 66 77"},
        {"type":"subtitle","info":"Recursive Steps"},
        {"type":"text","info":"Now we can recursively call Quick Sort on the subarray to the left of i (0 to i-1) and then on the subarray to the right of i (i+1 to j). In the next set of steps, I show the first left recursive call for indices 0 through 3 on the left."},
        {"type":"text","info":"Note: By randomly shuffling the array, we are more likely to reduce the number of required recursive calls. "},
        {"type":"text","info":"Operation                pivot i  j   array values"},
        {"type":"text","info":"Initial Values           0     1  3   42 14 1 2 44 99 66 77"},
        {"type":"text","info":"Scan left, Scan Right    0     3  2   42 14 1 2 44 99 66 77"},
        {"type":"text","info":"Swap?                    0     3  2   42 14 1 2 44 99 66 77"},
        {"type":"text","info":"Final Exchange           0     3  2   2 14 1 42 44 99 66 77"},
        {"type":"text","info":"Comparison                            2 14 1 42 44 99 66 77"},
        {"type":"text","info":"In the video below, I go through the entire set of steps to solve the presented array."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=55256139-838d-4657-b936-ae1b011a6d97&start=0"}

        ]},

    {"unique_id":"3-1","content":[
        {"type":"subtitle","info":"Singly Linked List Introduction"},
        {"type":"text","info":"In this section, we will build our first advanced Data Structure, a Singly Linked List. In short, a linked list is a data structure where each node contains data as well as at least one pointer to the element. The crucial difference between a linked list and an array is that the order of the linked lists is not determined by their location in memory."},
        {"type":"text","info":"The drawing below shows a valid array as well as a valid Singly Linked List. Notice how the order of the linked list is not physically in order, but is ordered by following the trace of the pointers."},
        {"type":"text","info":"- Hint: I am purposely using the same word \"trace\" that I used in my description of a recursive trace, since operations of singly linked lists often use recursion."},
        {"type":"image","info":""},
        {"type":"subtitle","info":"Motivation: A Brief Historical Overview"},
        {"type":"text","info":"Sometimes, understanding the history of the data structure will help you understand how to develop and implement that data structure, and linked lists are a perfect example. Linked Lists were first developed in 1956 at the RAND Corporation to implement their Information Processing Language (IPL), which was an early artificial intelligence program, including general problem solving and chess. The crucial aspect of the IPL is that it leveraged pointers between information to represent connections in logic."},
        {"type":"text","info":"So in many ways, the way we think and remember is similar to linked lists! Think of linked lists as connected, ordered ideas."},
        {"type":"image","info":""},
        {"type":"text","info":"Optional Reading: The scientists who invented Linked Lists, Allen Newell and Herbert Simon, won the ACM Turing Award in 1975 for having \"made basic contributions to artificial intelligence, the psychology of human cognition, and list processing\". Turing Award Lecture"},
        {"type":"subtitle","info":"A Modern Motivation: Segmentation in Operating Systems"},
        {"type":"text","info":"In the Operating Systems course, you will learn about several challenges in memory management. For now, all you need to know is that storing memory elements can be challenging because of the different types of memory leads to external fragmentation. This means that there are variable sized segments in memory, leading to small holes of unused memory. Compacting segments is computationally expensive, so the OS needs to find available places in memory."},
        {"type":"image","info":""},
        {"type":"text","info":"A simple way this is done is with free-list memory management. While the mechanizations and algorithms behind segmentation and free-list memory management are outside the scope of this course, you can see in the simple diagram below that linked lists (and void pointers, as you will learn in OS), are fundamental building blocks in memory management."},
        {"type":"image","info":""},
        {"type":"text","info":"Optional Reading: The basics of Segmentation in an OS"},
        {"type":"text","info":"Optional Reading: The basics of Free List Memory Management"},
        {"type":"subtitle","info":"How we initialize a Linked List"},
        {"type":"text","info":"Since we want the ability to add and remove nodes from the Linked List, we are going to dynamically allocate memory to the Data Heap. In our first linked list, we will code a homogeneous list of integers."},
        {"type":"text","info":"Before we link the register containing the base address with the linked list, we should create a C struct with the base unit of the link list: the linked list node. We will call the the struct sll_node, and the struct will contain"},
        {"type":"text","info":"- An integer"},
        {"type":"text","info":"- A pointer to the next sll_node"},
        {"type":"text","info":"One aspect of C structs is that you must use the struct keyword when defining a pointer to a struct of the same type."},
        {"type":"subtitle","info":"Showing the Benefit of Linking Nodes"},
        {"type":"text","info":"To show the benefit of linked data elements, I will present four sll_nodes with dynamic memory allocation with values 10, -20, 15, and 4. Since they are pointers, we will dereference the pointer to update the data element on the heap using the -> operator."},
        {"type":"text","info":"- sll_node* node_0 = (sll_node*)malloc( sizeof(sll_node) );"},
        {"type":"text","info":"- node_0->data = 10;"},
        {"type":"text","info":"Here is the memory layout of node_0 based on the two lines of code above. Just like a dynamic array, we see that a dynamically allocated C struct has a register pointer pointing to dynamically allocated memory on the Heap. In this case, we have an integer with the value 10 and then a pointer which can be used to point to the next data element. In this case the pointer is pointing to NULL since we do not have another node yet."},
        {"type":"image","info":""},
        {"type":"text","info":"Next, will update the next pointer to point at the last to the next one in this order, and set the last to NULL. In this code snippet, I set node0's next pointer equal to node1. Since node1 is also a pointer, we do not need to do any additional de-referencing. In the second line of code, I show the example of setting node3's next pointer equal to NULL, which tell us where the linked list ends."},
        {"type":"text","info":"- node_0->next_node = node_1;"},
        {"type":"text","info":"- node_3->next_node = NULL;"},
        {"type":"text","info":"Finally, since the are dynamically allocated, we must free all the elements. The code below shows the creation and freeing of the entire linked list."},
        {"type":"subtitle","info":"Iterating through a Singly Linked Lists"},
        {"type":"text","info":"In order show the benefit of linked data elements and help you visualize them, I have added a set of print statements to print out how the data in a singly linked list is structured. In the code segment below, I have created a register pointer sll_node* curr_ptr, which will allow us to iterate through the linked list."},
        {"type":"text","info":"- Setting curr_ptr = node_0 means they are now both pointing to the same address on the data heap."},
        {"type":"text","info":"- We iterate by using the next_node pointer in the sll_node struct to update where curr_ptr is pointing to on the data heap."},
        {"type":"text","info":"Consider the diagrams below. On the left, we see that curr_ptr is pointing to the same address and node_0. Notice how that struct contains a next_node which is pointing to the same location as node_0 in red. The blue arrow represents curr_ptr->next_node, which works because we are asking to"},
        {"type":"text","info":"1. Go to the structure at the location pointed to by curr_ptr"},
        {"type":"text","info":"2. Get the address that is pointed to by next_node"},
        {"type":"text","info":"3. Update the register value at curr_ptr with the address at curr_ptr->next_node."},
        {"type":"image","info":""},
        {"type":"text","info":"In the code segment below, we use curr_ptr to iterate through the entire list by continuing until curr_ptr == NULL. In each loop, we print:"},
        {"type":"text","info":"1. Address of the node"},
        {"type":"text","info":"2. The address of the int in the struct"},
        {"type":"text","info":"3. The value of the int data"},
        {"type":"text","info":"4. The address of the next_node ptr in the struct"},
        {"type":"text","info":"5. The address pointed to by the next node"},
        {"type":"text","info":"The full code segment is available at sll_node.c. I have included an image with the layout in memory, as well as a video where I explain how this memory layout derives from the code"},
        {"type":"subtitle","info":"Sample Run:"},
        {"type":"subtitle","info":"Memory Layout Drawing based on Sample Run Output Memory Locations"},
        {"type":"subtitle","info":"Video Explaining Sample Run Drawing"},
        {"type":"text","info":"Lecture 7 Introduction Question 1: What is a Linked List, and what are some motivations behind using them in computing systems?"},
        {"type":"text","info":"Lecture 7 Introduction Question 2: What is the general idea behind a Singly Linked List, and how is a Singly Linked List node struct stored in memory?"},
        {"type":"subtitle","info":"Next: Go to Reading 7.2 - Encapsulating the Singly Linked List"},

        {"type":"subtitle","info":"Encapsulating the Singly Linked List"},
        {"type":"text","info":"In this section, we will learn about encapsulation, and how we can use encapsulation to improve the memory management of data structures."},
        {"type":"subtitle","info":"Motivation: Inefficient use of Registers"},
        {"type":"text","info":"Let us review the diagram I drew in Reading 7.1. I want you to notice how we use a register for every single node in addition to a pointer on the heap to point to all the subsequent nodes in the Singly Linked List. This is inefficient and redundant, especially since we never used the registers to iterate through the elements in the first place."},
        {"type":"image","info":""},
        {"type":"text","info":"So how can we make better use of memory?"},
        {"type":"text","info":"Encapsulation is defined as the structuring of data under a single unit. We will see in C structs, as well as in C++ classes, that we can improve memory operation, as well as the security of the data, by using one register to point to the location on the Data Heap, and then perform all the remaining data allocations on the data heap."},
        {"type":"text","info":"We will encapsulate the Singly Linked List by using a pointer to point to an initial head pointer. We are designing the Singly Linked List this way for two reasons"},
        {"type":"text","info":"1. So we can point at an initially empty list"},
        {"type":"text","info":"2. So we can update the list in the event we want to delete the first node"},
        {"type":"text","info":"We will create a struct slllist that only contains a sll_node pointer, which we will call head_node."},
        {"type":"text","info":"typedef struct sll_node{"},
        {"type":"text","info":"    int data;"},
        {"type":"text","info":"    struct sll_node* next_node;"},
        {"type":"text","info":"}sll_node;"},
        {"type":"text","info":"typedef struct sllist{"},
        {"type":"text","info":"    struct sll_node* head_node;"},
        {"type":"text","info":"}sllist;"},
        {"type":"text","info":"When we allocate an sllist pointer, we will allocate 64 bits on the heap for a pointer. But the pointer is initially NULL because we have not allocated any memory to that pointer."},
        {"type":"text","info":"Here is a code example, and how the memory is laid out after executing that code."},
        {"type":"text","info":"sllist* the_list = (sllist *)malloc( sizeof( sllist ) );"},
        {"type":"text","info":"the_list->head_node = NULL;"},
        {"type":"image","info":""},
        {"type":"subtitle","info":"Combining Concepts - Allocating and Freeing the pointer, Encapsulation, and Pass by Reference"},
        {"type":"text","info":"To improve the modularity of our code, we can write functions that allow us to allocate and free the memory automatically, so we can use multiple Singly Linked Lists in the same program without having to copy-and-paste the code each time."},
        {"type":"text","info":"We will use a function called constructor. In this function, we will allocate"},
        {"type":"text","info":"The reason we call this function constructor is because C++ classes are created with a method called a constructor, so I am preparing you for that future concept."},
        {"type":"text","info":"sllist* constructor(){"},
        {"type":"text","info":"sllist* temp_node = (sllist *)malloc( sizeof(sllist) );"},
        {"type":"text","info":"return temp_node;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"To free the memory, we will create a function called destructor (again, the term used in C++ classes) to free the memory"},
        {"type":"text","info":"void destructor( sllist* delete_list ){"},
        {"type":"text","info":"free( delete_list );"},
        {"type":"text","info":"}"},
        {"type":"text","info":"The code to perform this task is available at sll_encap.c (Links to an external site.). We can see in main that we can construct and destruct the memory for a Singly Linked List. We have encapsulated the linked lists. This code is an initial example of the benefit of understanding pass by reference in the Data Structures course"},
        {"type":"text","info":"int main()"},
        {"type":"text","info":"{"},
        {"type":"text","info":"     sllist* list_1 = constructor();"},
        {"type":"text","info":"     sllist* list_2 = constructor();"},
        {"type":"text","info":"     destructor( list_2 );"},
        {"type":"text","info":"     destructor( list_1 );"},
        {"type":"text","info":"     return EXIT_SUCCESS;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"And here is the output with valgrind. Note that we allocated two registers with 8 bytes each, so the valgrind output indicates we allocated and freed 16 bytes in this program."},
        {"type":"text","info":"An interesting note: If you run sll_encap.c with valgrind including the -O2 flag, you will notice something interesting, that it says 0 allocs and 0 frees! Why do you think this is?"},
        {"type":"text","info":"It turns out that, since we don't use the list1 or list2 variables anywhere else in the code, that the -O2 flag just removes them from the program and never allocates them! Hopefully, you can see the benefit of including -O2 flag in your C and C++ code in the future."},
        {"type":"subtitle","info":"Inserting an Element to the back of the Singly Linked List"},
        {"type":"text","info":"Since we are not going to track each node with a register, we are going to allocate the memory directly to the next_node pointer on the Data Heap. In order to complete this process, we will iterate while the next_node is not null."},
        {"type":"text","info":"First, we create a sll_node pointer to temporarily point to the location on the Data Heap."},
        {"type":"text","info":"sll_node* insert_node = (sll_node*)malloc( sizeof(sll_node) );"},
        {"type":"text","info":"Then, we will set the node's data to the value being passed to the function, and then the next node equal to NULL"},
        {"type":"text","info":"insert_node->data = the_value;"},
        {"type":"text","info":"insert_node->next_node = NULL;"},
        {"type":"text","info":"The third step is to check if the head node is equal to NULL in order to account for the case when the list is empty.  If the list is empty, we just the list's head node pointer to point to the insert node. When we go out of scope, the temporary pointer insert_node goes out of scope."},
        {"type":"text","info":"Professor Morrison's Golden Rule of Pointers: Before you attempt to access data at the pointer, always check to make sure the pointer is actually pointing to something. Just like you, the computer can't remember something it never learned in the first place."},
        {"type":"text","info":"if( the_list->head_node == NULL ){"},
        {"type":"text","info":"     // Set the head node equal to insert_node"},
        {"type":"text","info":"     the_list->head_node = insert_node;"},
        {"type":"text","info":"     // And return"},
        {"type":"text","info":"     return;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"The final step is to iterate through the linked list until we find a node where the next_node is NULL. That is the end of the list. We have that node point to our insert_node, and then we go out of scope again."},
        {"type":"text","info":"     // Otherwise, create a curr_ptr equal to the head_node"},
        {"type":"text","info":"     sll_node* curr_ptr = the_list->head_node;"},
        {"type":"text","info":"     // Iterate until the next_node is NULL"},
        {"type":"text","info":"     while( curr_ptr->next_node != NULL ){"},
        {"type":"text","info":"         curr_ptr = curr_ptr->next_node;"},
        {"type":"text","info":"     }"},
        {"type":"text","info":"     // Set curr_ptr's next_node equal to insert_node"},
        {"type":"text","info":"     curr_ptr->next_node = insert_node;"},
        {"type":"text","info":"In this vide below, I walk through this process by inserting 10, -20, 34, 27 into the Singly Linked List. I have included a diagram with the final Singly Linked List."},
        {"type":"image","info":""},
        {"type":"image","info":""},
        {"type":"subtitle","info":"Combining Concepts: Recursion and Destructing the Singly Linked List"},
        {"type":"text","info":"Now that we have a complete linked list, we must be able to destruct the entire linked list. Let's consider a scenario where we delete the head node first, and then try to delete the rest of the linked list. It turns out that we would lose track of the rest of the list, and we would lose the rest of the memory."},
        {"type":"text","info":"- Once the pointer is gone, we lose our ability to find the remaining data!"},
        {"type":"image","info":""},
        {"type":"text","info":"So how do we delete the rest of the Singly Linked List? The approach would require finding the end of the singly linked list, and then working backwards."},
        {"type":"text","info":"It turns out we can do this by recursively deleting the linked list! We can set the base case as the NULL pointer at the end of the list, and then recursively work backwards, freeing the elements one by one."},
        {"type":"text","info":"I have presented the code for recursively destructing the linked list, and have included a video where I help you visualize how the data is destructed on the Heap."},
        {"type":"text","info":"void destructor( sll_node* curr_ptr ){"},
        {"type":"text","info":"     if( curr_ptr == NULL )"},
        {"type":"text","info":"         return;"},
        {"type":"text","info":"     destructor( curr_ptr->next_node );"},
        {"type":"text","info":"     free( curr_ptr );"},
        {"type":"text","info":"}"},
        {"type":"image","info":""},
        {"type":"subtitle","info":"Exam-Type Question: Drawing the Layout"},
        {"type":"text","info":"On an Exam, you will be expected, based on some code and a print out of addresses, to be able to draw the entire structure of the data in memory. Review the code available at sllist.c (Links to an external site.). This code converts command line inputs to integers, inserts them into a Singly Linked List, and then prints all the addresses and data of the command line arguments and Singly Linked List. I have included a sample output run as well as a video where I describe and draw the layout of the data in memory."},
        {"type":"text","info":"- Problem Objective: If you can draw the memory layout of this output based on the code segments, then you have demonstrated a strong understanding of how the data is structured in the computing device."},
        {"type":"text","info":"Code Output Run"},
        {"type":"text","info":"First, here is the drawing of the structure of the data based on this code output:"},
        {"type":"image","info":""},
        {"type":"text","info":"And here is the video explanation of how I derived this memory layout:"},
        {"type":"image","info":""},
        {"type":"subtitle","info":"Lecture 7 Introduction Question 3: How do we encapsulate a Singly Linked List, and what is the major benefit?"},
        {"type":"subtitle","info":"Lecture 7 Introduction Question 4: What is the process of inserting an element into a Singly Linked List?"},
        {"type":"subtitle","info":"Lecture 7 Introduction Question 5: What is the purpose and process of destructing a Singly Linked List?"},
        {"type":"subtitle","info":"Next: Go to Reading 7.3 - Introduction to Stacks"},

        {"type":"subtitle","info":"Introduction to Stacks"},
        {"type":"text","info":"We will learn another programming paradigm called aggregation in this section. Specifically, how we can learn to aggregate upon the idea of a Singly Linked List to build another fundamental Data Structure known as a Stack."},
        {"type":"subtitle","info":"Motivation: Last-In, First-Out Operations"},
        {"type":"text","info":"In a computing system, there are several operations that require us to keep track of the data, but perform them in \"last in, first out.\" Think of last-in first-out (acronym: LIFO) like a stack of plates. As you are washing the plates, you will put them one on top of the other. When you use them, you like likely use the top plate first."},
        {"type":"text","info":"For example, the entertainer Red Panda is able to stack bowls on top of her head by kicking them off her feet, She puts bowls on top of her feet and then kicks them on top of her head. Notice how the last bowl that she places on her feet ends up being the first bowl that ends up on top of her head."},
        {"type":"image","info":""},
        {"type":"text","info":"Understanding LIFO is useful in software, hardware, operating systems, and algorithms."},
        {"type":"text","info":"In graphing algorithms, we will use stacks to keep track of the next node to evaluate when performing Depth-First Search and Topological Sorting."},
        {"type":"text","info":"In hardware, we call the static memory the Instruction Stack because the memory locations decrease as well add static memory and instruction calls. As a result, the instructions appear to be added like a stack of plates. Recursive calls stack on top of each other like plates."},
        {"type":"text","info":"- This is why excessive recursive calls are known as a Stack Overflow (Links to an external site.)."},
        {"type":"text","info":"Optional Reading: A common security vulnerability is known as a stack smashing attack (Links to an external site.)."},
        {"type":"subtitle","info":"Aggregation: Building Stacks from Singly Linked Lists"},
        {"type":"text","info":"In a computing system, there are several operations that \"build upon each other\". This process is known as aggregation. For example, we will learn that:"},
        {"type":"text","info":"- Stacks aggregates upon Singly Linked Lists"},
        {"type":"text","info":"- Queues and Deques aggregate upon Doubly Linked Lists"},
        {"type":"text","info":"- Hash Tables and Graphs aggregate upon Vectors"},
        {"type":"text","info":"- Red-Black and Splay Trees aggregate upon Binary Search Trees"},
        {"type":"text","info":"So how does a Stack aggregate upon a Singly Linked List? We will modify the Singly Linked List by limiting access to the list to two operations:"},
        {"type":"text","info":"- Push: Inserting the element at the front of the Singly Linked List"},
        {"type":"text","info":"- Pop: Removing the element from the front of the Singly Linked List"},
        {"type":"text","info":"In lecture, we will work together to program these operations into a Stack struct, and then we will learn how to use recursion to perform Stack related tasks (such as the classic Towers of Hanoi (Links to an external site.) problem). For now, I will provide a brief video where I describe the process of pushing and popping three elements from a Stack in order to set you up for success in the In-Class coding."},
        {"type":"image","info":""},
        {"type":"subtitle","info":"Lecture 7 Introduction Question 6: What are the processes of \"push\" and \"pop\" on a Stack?"},
        {"type":"subtitle","info":"To be prepared for Lecture 7:"},
        {"type":"subtitle","info":"- Have your answers to the three \"Introduction Questions\" prepared. I will be asking those questions to start lecture. The objective is to start a class discussion on these topics to lead into In-Class Coding Opportunities and Problems."},
        {"type":"subtitle","info":"- Next, have a set of questions to concepts you do not understand or would like more clarity on. The next step for me to start every lecture will be for me to ask if anyone had additional questions on the reading. This is an opportunity for you to get assistance, and for me to go into depth to help set you up for success"}
    ]},

    {"unique_id":"3-2","content":[
        {"type":"subtitle","info":"Doubly Linked Lists and Insertion"},
        {"type":"text","info":"There are a few drawbacks to using Singly Linked Lists, which we will address through the introduction of Doubly Linked Lists."},
        {"type":"text","info":"1. We can only access the front element in the Singly Linked List"},
        {"type":"text","info":"2. To insert at the end, we need to iterate all the way through the list"},
        {"type":"text","info":"3. Since the nodes only have next_node pointers, we can only traverse in one direction"},
        {"type":"text","info":"4. We only know the location of the previous node through the use of recursion or excessive pointers"},
        {"type":"subtitle","info":"How we initialize a Doubly Linked List"},
        {"type":"text","info":"Since we want the ability to add and remove nodes from the Doubly Linked List, we are going to dynamically allocate memory to the Data Heap. In our first linked list, we will code a homogeneous list of integers."},
        {"type":"text","info":"Before we link the register containing the base address with the linked list, we should create a C struct with the base unit of the link list: the linked list node. We will call the the struct dll_node, and the struct will contain"},
        {"type":"text","info":"- An integer"},
        {"type":"text","info":"- A pointer to the next dll_node"},
        {"type":"text","info":"- A pointer to the previous dll_node"},
        {"type":"text","info":"typedef struct dll_node{"},
        {"type":"text","info":"     int data;"},
        {"type":"text","info":"     struct dll_node* prev;"},
        {"type":"text","info":"     struct dll_node* next;"},
        {"type":"text","info":"}dll_node;"},
        {"type":"subtitle","info":"Encapsulating the Doubly Linked List"},
        {"type":"text","info":"We will encapsulate the Double Linked List by using a pointer to point to an initial head pointer as well as a tail pointer that will point to the last node in the Double Linked List. We are designing the Doubly Linked List this way for two reasons"},
        {"type":"text","info":"1. So we can point at an initially empty list"},
        {"type":"text","info":"2. So we can update the list in the event we want to delete the first node or we want to delete the last node"},
        {"type":"text","info":"We will create a struct dlllist that only contains a dll_node pointer, which we will call head_node, as well as another pointer we will call"},
        {"type":"text","info":"typedef struct dll_node{"},
        {"type":"text","info":"     int data;"},
        {"type":"text","info":"     struct dll_node* prev;"},
        {"type":"text","info":"     struct dll_node* next;"},
        {"type":"text","info":"}dll_node;"},
        {"type":"text","info":"typedef struct dllist{"},
        {"type":"text","info":"     struct dll_node* head_node;"},
        {"type":"text","info":"     struct dll_node* head_node;"},
        {"type":"text","info":"}dllist;"},
        {"type":"text","info":"When we allocate an dllist pointer, we will allocate 128 bits on the heap for both pointers. But the pointer are initially NULL because we have not allocated any memory to those pointers."},
        {"type":"text","info":"Here is a code example, and how the memory is laid out after executing that code."},
        {"type":"text","info":"dllist* the_list = (dllist *)malloc( sizeof( dllist ) );"},
        {"type":"text","info":"the_list->head_node = NULL;"},
        {"type":"text","info":"the_list->tail_node = NULL;"},
        {"type":"text","info":"CONTINUE HERE"},
        {"type":"subtitle","info":"Inserting an Element in the Front of the Doubly Linked List"},
        {"type":"subtitle","info":"Inserting an Element in the Back of the Doubly Linked List"},
        {"type":"subtitle","info":"Lecture 8 Introduction Question 1: What is the process of pushing to the front of a Doubly Linked List?"},
        {"type":"subtitle","info":"Lecture 8 Introduction Question 2: What is the process of pushing to the back of a Doubly Linked List?"},
        {"type":"subtitle","info":"Next: Go to Reading 8.2 - Deletion from a Doubly Linked List"},

        {"type":"subtitle","info":"Deletion from a Doubly Linked List"},
        {"type":"subtitle","info":"The Pop Front Method"},
        {"type":"subtitle","info":"The Pop Back Method"},
        {"type":"subtitle","info":"The Destructor"},
        {"type":"subtitle","info":"Lecture 8 Introduction Question 3: What is the process of popping from the front of a Doubly Linked List?"},
        {"type":"subtitle","info":"Lecture 8 Introduction Question 4: What is the process of popping from the back of a Doubly Linked List?"},
        {"type":"subtitle","info":"Next: Go to Reading 8.3 - Deques, Queues, and Priority Queues"},

        {"type":"subtitle","info":"Deques, Queues, and Priority Queues"},
        {"type":"subtitle","info":"The Deque"},
        {"type":"subtitle","info":"The Queue"},
        {"type":"subtitle","info":"The Priority Queue"},
        {"type":"subtitle","info":"Lecture 8 Introduction Question 5: How do we aggregate upon Doubly Linked Lists to implement Deques, Queues, and Priority Queues?"},
        {"type":"subtitle","info":"To be prepared for Lecture 8:"},
        {"type":"subtitle","info":"- Have your answers to the five \"Introduction Questions\" prepared. I will be asking those questions to start lecture. The objective is to start a class discussion on these topics to lead into In-Class Coding Opportunities and Problems."},
        {"type":"subtitle","info":"- Next, have a set of questions to concepts you do not understand or would like more clarity on. The next step for me to start every lecture will be for me to ask if anyone had additional questions on the reading. This is an opportunity for you to get assistance, and for me to go into depth to help set you up for success"}
    ]},

    {"unique_id":"3-3","content":[
        {"type":"subtitle","info":"Introduction to Binary Search Trees"},
        {"type":"subtitle","info":"Motivation: A Brief Historical Overview"},
        {"type":"subtitle","info":"Binary Search Tree: Definitions and Example"},
        {"type":"subtitle","info":"Setting up the Binary Search Tree: Encapsulation"},
        {"type":"subtitle","info":"Binary Search Tree Insertion"},
        {"type":"subtitle","info":"Completing the Insertion Process"},
        {"type":"subtitle","info":"Insertion Summary"},
        {"type":"subtitle","info":"Lecture 9 Introduction Question 1: What is a Binary Search Tree, and what are some motivations behind using them in computing systems?"},
        {"type":"subtitle","info":"Lecture 9 Introduction Question 2: What is the benefit of understanding pointers to pointers and recursion when performing BST insertion?"},
        {"type":"subtitle","info":"Lecture 9 Introduction Question 3: What is the process of inserting a node into a Binary Search Tree?"},
        {"type":"subtitle","info":"Next: Go to Reading 9.2 - Binary Search Tree Traversals"},

        {"type":"subtitle","info":"Basic BST Traversals"},
        {"type":"subtitle","info":"Pre-Order Traversal"},
        {"type":"subtitle","info":"In-Order Traversal"},
        {"type":"subtitle","info":"Post-Order Traversal"},
        {"type":"subtitle","info":"Lecture 9 Introduction Question 4: How do we perform a pre-order traversal on a Binary Search Tree, and what is the benefit?"},
        {"type":"subtitle","info":"Lecture 9 Introduction Question 5: How do we perform an in-order traversal on a Binary Search Tree, and what is the benefit?"},
        {"type":"subtitle","info":"Lecture 9 Introduction Question 6: How do we perform a post-order traversal on a Binary Search Tree, and what is the benefit?"},
        {"type":"subtitle","info":"Go to Reading 9.3 - BST Level Order Traversal"},

        {"type":"subtitle","info":"BST Level Order Traversal"},
        {"type":"subtitle","info":"Level-Order Traversal"},
        {"type":"subtitle","info":"Lecture 9 Introduction Question 7: How do we perform a level-order traversal on a Binary Search Tree, and what is your theory as to which data structure we should use?"},
        {"type":"subtitle","info":"To be prepared for Lecture 9:"},
        {"type":"subtitle","info":"- Have your answers to the seven \"Introduction Questions\" prepared. I will be asking those questions to start lecture. The objective is to start a class discussion on these topics to lead into In-Class Coding Opportunities and Problems."},
        {"type":"subtitle","info":"- Next, have a set of questions to concepts you do not understand or would like more clarity on. The next step for me to start every lecture will be for me to ask if anyone had additional questions on the reading. This is an opportunity for you to get assistance, and for me to go into depth to help set you up for success"}
    ]},

    {"unique_id":"4-1","content":[
        {"type":"subtitle","info":"C++ Introduction"},
        {"type":"subtitle","info":"Why are we using C++ for the rest of the course?"},
        {"type":"subtitle","info":"Motivation for Object Oriented Programming"},
        {"type":"subtitle","info":"Compiling C++ programs"},
        {"type":"subtitle","info":"Hello, World in C++"},
        {"type":"subtitle","info":"Memory Allocation in C++"},
        {"type":"subtitle","info":"Lecture 11 Introduction Question 1: What is the purpose of Object Oriented Programming, and what are the crucial benefits?"},
        {"type":"subtitle","info":"Lecture 11 Introduction Question 2: How do we write data to the standard output in C++, and what are the differences between the procedural (C version) and object-oriented (C++ version) approaches to command line operations?"},
        {"type":"subtitle","info":"Lecture 11 Introduction Question 3: How do we write allocate and free memory in C++, and what are the differences between the procedural (C version) and object-oriented (C++ version) approaches to memory allocation?"},
        {"type":"subtitle","info":"Next: Go to Reading 11.2 - Call by Reference and Function Templates"},

        {"type":"subtitle","info":"Call by Reference and Function Templates"},
        {"type":"subtitle","info":"Pass By Reference vs. Call By Reference"},
        {"type":"subtitle","info":"Function Templates"},
        {"type":"subtitle","info":"Lecture 11 Introduction Question 4: What is the purpose of C++ Call By Reference, and what are the potential benefits and drawbacks?"},
        {"type":"subtitle","info":"Lecture 11 Introduction Question 5: What is a C++ template, and how do we use C++ templates to reduce the complexity of writing programs?"},
        {"type":"subtitle","info":"Next: Go to Reading 11.3 - Fundamental C++ Collections and Set Operators"},

        {"type":"subtitle","info":"Fundamental C++ Collections and Set Operations"},
        {"type":"subtitle","info":"C++ Collections"},
        {"type":"subtitle","info":"Combining Concepts: Object Oriented Programming, Levels of Abstraction, and Memory Allocation"},
        {"type":"subtitle","info":"Lecture 11 Introduction Question 6: In your own words, describe why we have six allocs and frees in the C++ implementation of the vector.cpp that was presented, even though the code did not have any new/delete programmed into the code."},
        {"type":"subtitle","info":"To be prepared for Lecture 11:"},
        {"type":"subtitle","info":"- Have your answers to the siz \"Introduction Questions\" prepared. I will be asking those questions to start lecture. The objective is to start a class discussion on these topics to lead into In-Class Coding Opportunities and Problems."},
        {"type":"subtitle","info":"- Next, have a set of questions to concepts you do not understand or would like more clarity on. The next step for me to start every lecture will be for me to ask if anyone had additional questions on the reading. This is an opportunity for you to get assistance, and for me to go into depth to help set you up for success"}
    ]},

    {"unique_id":"4-2","content":[
        {"type":"subtitle","info":"Encapsulation with C++ Structs"},
        {"type":"subtitle","info":"C++ Objects"},
        {"type":"subtitle","info":"Lecture 12 Introduction Question 1: What is the purpose of C++ methods and how are they created in a C++ struct?"},
        {"type":"subtitle","info":"Next: Go to Reading 12.2 - C++ Private Members and Methods"},

        {"type":"subtitle","info":"C++ Private Members and Methods"},
        {"type":"subtitle","info":"Private Methods and Members"},
        {"type":"subtitle","info":"Challenges with C++ Struct security"},
        {"type":"subtitle","info":"Lecture 12 Introduction Question 2: What is the purpose and benefit of the \"private\" keyword in C++?"},
        {"type":"subtitle","info":"Next: Go to Reading 12.3 - C++ Constructors and Destructors with Dynamic Memory"},

        {"type":"subtitle","info":"C++ Constructors and Destructors with Dynamic Memory"},
        {"type":"subtitle","info":"Constructors and the \"this\" keyword"},
        {"type":"subtitle","info":"Overloaded Constructors"},
        {"type":"subtitle","info":"Example 1: Animal"},
        {"type":"subtitle","info":"Example 2: Dynamic Array"},
        {"type":"subtitle","info":"Destructor"},
        {"type":"subtitle","info":"Lecture 12 Introduction Question 3: What is the purpose and format of a C++ constructor, and what is the format of a PQC Member Initialization List?"},
        {"type":"subtitle","info":"Lecture 12 Introduction Question 4: What is the purpose and format of a C++ destructor?"},
        {"type":"subtitle","info":"Next: Go to Reading 12.4 - C++ Templated Objects"},

        {"type":"subtitle","info":"C++ Templated Objects"},
        {"type":"subtitle","info":"C++ Templates"},
        {"type":"subtitle","info":"Calling a Templated Object in Main"},
        {"type":"subtitle","info":"Putting the Pieces Together"},
        {"type":"subtitle","info":"Lecture 12 Introduction Question 5: What is the purpose, benefits, and drawbacks of templates objects in C++"},
        {"type":"subtitle","info":"To be prepared for Lecture 12:"},
        {"type":"subtitle","info":"- Have your answers to the five \"Introduction Questions\" prepared. I will be asking those questions to start lecture. The objective is to start a class discussion on these topics to lead into In-Class Coding Opportunities and Problems."},
        {"type":"subtitle","info":"- Next, have a set of questions to concepts you do not understand or would like more clarity on. The next step for me to start every lecture will be for me to ask if anyone had additional questions on the reading. This is an opportunity for you to get assistance, and for me to go into depth to help set you up for success"}
    ]},

    {"unique_id":"4-3","content":[
        {"type":"subtitle","info":"Introduction to Complete Search"},
        {"type":"subtitle","info":"Generating subsets"},
        {"type":"subtitle","info":"Bit Representation"},
        {"type":"subtitle","info":"Lecture 13 Introduction Question 1: What is the main idea behind \"Complete Search\", and how can we leverage this approach to find solutions to complex problems?"},
        {"type":"subtitle","info":"Lecture 13 Introduction Question 2: How can we use bit shifting to reduce computational complexity in solving complete search algorithms?"},
        {"type":"subtitle","info":"iNext: Go to Reading 13.2 - Backtracking and Pruning the Search Tree"},

        {"type":"subtitle","info":"Backtracking and Pruning the Search Tree"},
        {"type":"subtitle","info":"Improving the Search Time: Pruning the Search Tree"},
        {"type":"subtitle","info":"Basic algorithm"},
        {"type":"subtitle","info":"Optimization 1"},
        {"type":"subtitle","info":"Optimization 2"},
        {"type":"subtitle","info":"Optimization 3"},
        {"type":"subtitle","info":"Optimization 4"},
        {"type":"subtitle","info":"Lecture 13 Introduction Question 3: What is the main idea behind \"Pruning the Search Tree\", and how does this improve Backtracking Algorithms?"},
        {"type":"subtitle","info":"Next: Go to Reading 13.3 - Advanced Example: The N-Queens Problem"},

        {"type":"subtitle","info":"Advanced Example - The N-Queens Problem"},
        {"type":"subtitle","info":"To be prepared for Lecture 13:"},
        {"type":"subtitle","info":"- Have your answers to the three \"Introduction Questions\" prepared. I will be asking those questions to start lecture. The objective is to start a class discussion on these topics to lead into In-Class Coding Opportunities and Problems."},
        {"type":"subtitle","info":"- Next, have a set of questions to concepts you do not understand or would like more clarity on. The next step for me to start every lecture will be for me to ask if anyone had additional questions on the reading. This is an opportunity for you to get assistance, and for me to go into depth to help set you up for success"}
    ]},

    {"unique_id":"4-4","content":[
        {"type":"subtitle","info":"Quantifying Computing Performance"},
        {"type":"subtitle","info":"Towards Quantifying Complexity"},
        {"type":"subtitle","info":"Comparing Linear and Quadratic Time"},
        {"type":"subtitle","info":"Lecture 14 Introduction Question 1: What is the main idea behind Big-O Notation, and how can we use this notation to improve our programs?"},
        {"type":"subtitle","info":"Lecture 14 Introduction Question 2: What is the difference between constant, linear, and quadratic operations?"},
        {"type":"subtitle","info":"Go to the next section: Reading 14.2 - Corner Cases and Big-O Formal Definition"},

        {"type":"subtitle","info":"Corner Cases and Big-O Formal Definition"},
        {"type":"subtitle","info":"Formal Big-O Notation"},
        {"type":"subtitle","info":"Big-O Formal Definition:"},
        {"type":"subtitle","info":"Big-O \"Approximations\""},
        {"type":"subtitle","info":"Lecture 14 Introduction Question 3: What is the formal definition of Big-O notation, and what is the importance of each of the five parts? (Those five parts being O(g(x)), g(x), f(x), c, and n0)"},
        {"type":"subtitle","info":"Go to the next section: Reading 14.3 - Logarithmic Operations in Big-O Notation"},

        {"type":"subtitle","info":"Logarithmic Operations in Big-O Notation"},
        {"type":"subtitle","info":"Logarithmic Analysis and Big-O Notation"},
        {"type":"subtitle","info":"Combined Example: Logarithmic and Linear for Log-Linear Time."},
        {"type":"subtitle","info":"Lecture 14 Introduction Question 4: What is the unique consideration we must take with respect to determining the Big-O notation and logarithmic operations (hint: consider the starting location)?"},
        {"type":"subtitle","info":"To be prepared for Lecture 14:"},
        {"type":"subtitle","info":"- Have your answers to the four \"Introduction Questions\" prepared. I will be asking those questions to start lecture. The objective is to start a class discussion on these topics to lead into In-Class Coding Opportunities and Problems."},
        {"type":"subtitle","info":"- Next, have a set of questions to concepts you do not understand or would like more clarity on. The next step for me to start every lecture will be for me to ask if anyone had additional questions on the reading. This is an opportunity for you to get assistance, and for me to go into depth to help set you up for success"}
    ]},

    {"unique_id":"4-5","content":[
        {"type":"subtitle","info":"Introduction to Hashing"},
        {"type":"subtitle","info":"Issues We've Seen So Far"},
        {"type":"subtitle","info":"Determining Valid Keys"},
        {"type":"subtitle","info":"Developing a Hash Function"},
        {"type":"subtitle","info":"Lecture 15 Introduction Question 1: What is the main idea behind Hash Tables?"},
        {"type":"subtitle","info":"Lecture 15 Introduction Question 2: Why must the Key in a Key-Value pair be deterministic?"},
        {"type":"subtitle","info":"Go to the next section: Reading 15.2 - Linear Probing and Rehashing"},

        {"type":"subtitle","info":"Collision Resolution and Linear Probing"},
        {"type":"subtitle","info":"Collision Resolution - Linear Probing"},
        {"type":"subtitle","info":"Re-Hashing and Prime Numbers"},
        {"type":"subtitle","info":"Lecture 15 Introduction Question 3: What is the purpose and procedure of Linear Probing?"},
        {"type":"subtitle","info":"Lecture 15 Introduction Question 4: What is the process of re-hashing, and why do we choose prime numbers for hash sizes?"},
        {"type":"subtitle","info":"Go to the next section: Reading 15.3 - C++ Unordered Map and Advanced Thinking with Hash Tables"},

        {"type":"subtitle","info":"C++ Unordered Map and Advanced Thinking using Hashing"},
        {"type":"subtitle","info":"C++ Standard Template Library Hash Table"},
        {"type":"subtitle","info":"Search and Memory Tradeoffs with Hash Tables"},
        {"type":"subtitle","info":"Advanced Thinking: Palindromic Permutations"},
        {"type":"subtitle","info":"Hashing Example: Detect a Cycle in a Linked List"},
        {"type":"subtitle","info":"Lecture 15 Introduction Question 5: When should you use a Hash Table to solve a Computational Problem? And when shouldn't you use a Hash Table?"},
        {"type":"subtitle","info":"To be prepared for Lecture 15:"},
        {"type":"subtitle","info":"Have your answers to the four \"Introduction Questions\" prepared. I will be asking those questions to start lecture. The objective is to start a class discussion on these topics to lead into In-Class Coding Opportunities and Problems."},
        {"type":"subtitle","info":"Next, have a set of questions to concepts you do not understand or would like more clarity on. The next step for me to start every lecture will be for me to ask if anyone had additional questions on the reading. This is an opportunity for you to get assistance, and for me to go into depth to help set you up for success"}
    ]},

    {"unique_id":"4-6","content":[
        {"type":"subtitle","info":"Introduction to Heaps"},
        {"type":"subtitle","info":"What is a Heap?"},
        {"type":"subtitle","info":"Heap Insertion"},
        {"type":"subtitle","info":"Heap Deletion"},
        {"type":"subtitle","info":"Example Insertion"},
        {"type":"subtitle","info":"Lecture 16 Introduction Question 1: What is the main idea behind a Minimum Heap?"},
        {"type":"subtitle","info":"Lecture 16 Introduction Question 2: What is the process of inserting and deleting from a Minimum Heap?"},
        {"type":"subtitle","info":"Go to the next section: Reading 16.2 - Maximum Heap Insertion and Deletion"},

        {"type":"subtitle","info":"Maximum Heaps"},
        {"type":"subtitle","info":"Maximum Heap Insertion and Deletion"},
        {"type":"subtitle","info":"Lecture 16 Introduction Question 3: What is the process of inserting and deleting from a Maximum Heap?"},
        {"type":"subtitle","info":"Go to the next section: Reading 16.3 - Binomial Heaps"},

        {"type":"subtitle","info":"Binomial Heaps"},
        {"type":"subtitle","info":"A New Way of Thinking: Adding Binary"},
        {"type":"subtitle","info":"Deleting the Minimum"},
        {"type":"subtitle","info":"Packet Representation"},
        {"type":"subtitle","info":"Binomial Heap Insertion"},
        {"type":"subtitle","info":"Extract the Minimum"},
        {"type":"subtitle","info":"Lecture 16 Introduction Question 4: What is the main idea behind a Binomial Heap?"},
        {"type":"subtitle","info":"Lecture 16 Introduction Question 5: How do you perform insertion and extract min with a Binomial Heap?"},
        {"type":"subtitle","info":"To be prepared for Lecture 16:"},
        {"type":"subtitle","info":"- Have your answers to the five \"Introduction Questions\" prepared. I will be asking those questions to start lecture. The objective is to start a class discussion on these topics to lead into In-Class Coding Opportunities and Problems."},
        {"type":"subtitle","info":"- Next, have a set of questions to concepts you do not understand or would like more clarity on. The next step for me to start every lecture will be for me to ask if anyone had additional questions on the reading. This is an opportunity for you to get assistance, and for me to go into depth to help set you up for success"}
    ]},

    {"unique_id":"5-1","content":[
        {"type":"subtitle","info":"Section 17.1 - Introduction to Graphs"},
        {"type":"subtitle","info":"Graphs: The Problem that Drives Modern Computing"},
        {"type":"text","info":"The Association of Computing Machinery is the global scientific and educational organization dedicated to advancing the art, science, engineering, and application of computing. (ACM Student Memberships are valuable in obtaining jobs, and particularly helpful in getting into Grad School.)"},
        {"type":"text","info":"Recently, the Communications of the ACM - the top ACM journal - ran the following headline \"The Future is Big Graphs\". As the growth of interconnected data explodes, we need students who understand the importance of graph processing, including memory management, processing efficiency, and reliability."},
        {"type":"text","info":"Graphs are also useful to study at this point in the semester because they are a strong \"2/3rds Capstone.\" To fully understand graphs, you will need to employ the following concepts you've learned so far in this course:"},
        {"type":"text","info":"- Pointers and Memory Allocations, which are extension of tree data structures."},
        {"type":"text","info":"- C++ Structs and Standard Template Libraries for Graph Abstraction"},
        {"type":"text","info":"- Vectors for Storing Node Locations in a Adjacency List"},
        {"type":"text","info":"- Complete Search and Recursion for Graph Traversals"},
        {"type":"text","info":"- Stacks - and by extension, Singly Linked Lists - for Depth-First Search"},
        {"type":"text","info":"- Queues - and by extension, Doubly Linked Lists - for Breadth-First Search"},
        {"type":"text","info":"- Priority Queues - and by extension, Heaps - for Shortest Path Algorithms"},
        {"type":"text","info":"Because graphs serve as an excellent review of material covered to this point, students often find that a previous concept they struggled with will \"click\" during this set of lectures."},
        {"type":"text","info":"- This is an example of why the Exam Clobbering Policy is pedagogically consistent with the Mission of Notre Dame. Because you can grow throughout the course of the semester, the policy will ensure that my final grade evaluation is more aligned with your growth during the semester, as opposed to allowing one Exam to drag down your overall score."},
        {"type":"subtitle","info":"Brute Force vs. Complete Search vs. Algorithmic Approaches"},
        {"type":"text","info":"Consider this common puzzle: Can you trace every line in this graph without lifting your pencil?"},
        {"type":"text","info":"- How would you go about this problem?"},
        {"type":"text","info":"- What techniques would you use to figure this out?"},
        {"type":"text","info":"Our first attempt: Brute Force"},
        {"type":"text","info":"In the video below, I show an attempt where I keep trying approaches and see if they work."},
        {"type":"text","info":"- Little-to-no technique"},
        {"type":"text","info":"- No guarantee you will find the solution"},
        {"type":"text","info":"- Even if one exists!"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=088dbe7d-c8b8-44bd-8819-ae4901046b7f"},
        {"type":"subtitle","info":"Complete Search"},
        {"type":"text","info":"In the next video, I show how we would apply a Complete Search to solving the problem. As we have previously studied, Complete Search will exhaustively determine a solution. However, these solutions may be computationally expensive. As graph sizes grow significantly, we will see the benefit of \"pruning the search tree\", like we did in the N-Queens Problem."},
        {"type":"text","info":"- Optional Growth Opportunity - After you study these graph algorithms in Lectures 17-19, it is common for a student to revisit the N-Queens problem we studied in Reading 13.3 and understand the concept much more clearly."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=5569e1dc-52ac-412a-b324-ae49010f35cb"},
        {"type":"subtitle","info":"Algorithmic: Bridges of Koningsberg Problem"},
        {"type":"text","info":"In 1786, Leohnard Euler was commissioned to solve the “Seven Bridges of Konigsberg” problem"},
        {"type":"text","info":"- Does there exist a route that allowed a person to cross all seven bridges in Konigsberg without crossing any bridge twice?"},
        {"type":"text","info":"- To this point, Everyone else is trying the Greedy approach"},
        {"type":"text","info":"- A Google Maps drawing of the 7 Bridges is shown below"},
        {"type":"text","info":"Euler realized that where a person starts is irrelevant to the solution! He translated the islands and bridges into locations"},
        {"type":"text","info":"- Locations are Nodes (in graph theory, nodes are more commonly referred to a Vertices)"},
        {"type":"text","info":"- Bridges are Edges"},
        {"type":"text","info":"Then, Euler combined common nodes into one node with several incoming and outgoing edges. Consider the diagram below:"},
        {"type":"text","info":"- 1, 7, and 8 on the left are the same island"},
        {"type":"text","info":"-> Combined into Node 1 on the right"},
        {"type":"text","info":"- 4, 5, and 6 on the left are the same island"},
        {"type":"text","info":"-> Combined into Node 3 on the right"},
        {"type":"text","info":"He also realized that, to get to an island, you can do one of three things:"},
        {"type":"text","info":"- Leave and never come back"},
        {"type":"text","info":"- Reach the island and leave the island"},
        {"type":"text","info":"- Arrive to the island, which is where you finish"},
        {"type":"text","info":"Therefore, he realized that if two nodes have an odd number of bridges and the rest have an even number, then the problem is solvable."},
        {"type":"text","info":"- Since more than two nodes have an odd number of bridges, the problem is not solvable!"},
        {"type":"text","info":"- Optional: From Wikipedia: Two of the seven original bridges did not survive the bombing of Königsberg in World War II. Two others were later demolished and replaced by a modern highway. The three other bridges remain, although only two of them are from Euler's time (one was rebuilt in 1935). Thus, as of 2021, five bridges exist at the same sites that were involved in Euler's problem. In terms of graph theory, two of the nodes now have degree 2, and the other two have degree 3. Therefore, an Eulerian path is now possible, but it must begin on one island and end on the other."},
        {"type":"text","info":"So now let's apply this logic to our puzzle from above:"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=5d142cad-8002-40a1-abd1-ae4901170fcf"},
        {"type":"text","info":"As we learned in the Complete Search discussion, algorithms should scale to much larger problems. In this case, the solution to the bridges of Koningsberg and the original maze puzzle scales to a more-complicated version of the puzzle."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=35986580-203f-421f-befd-ae49011b6654"},
        {"type":"text","info":"In the next section, we will build the foundations of a graph data structure."},
        {"type":"text","info":"Optional: A significant challenge in modern computing - all the way from determine a proper silicon layout of a chip device all the way to mapping the human genome - is determining a Hamiltonian Cycle of a graph, which is finding a path through an undirected or directed graph that visits each vertex exactly once."},
        {"type":"text","info":"Lecture 17 Introduction Question 1: What are the three approaches to solving Computing problems discussed in Section 17.1"},
        {"type":"text","info":"Lecture 17 Introduction Question 2: What are the major components of a Graph, and how did construction a graph in this manner help Euler solve the Bridges of Koningsberg problem?"},
        {"type":"subtitle","info":"17.2 - Building Edges and Vertices for a Graph Data Structure"},
        {"type":"subtitle","info":"Understanding \"Data\" and \"Structure\" in a Graph"},
        {"type":"text","info":"A graph is an abstract data type"},
        {"type":"text","info":"- Must define the vertex's location in the graph"},
        {"type":"text","info":"Must define the data it contains."},
        {"type":"text","info":"Consider the graph below. We have node locations highlighted in red, and the data contained in their locations inside the vertex. Understanding this difference, while seemingly intuitive, is a common issue when students start studying graphs. Just like an array, linked list, queue, stack, ect., the difference between data and structure is essential to implementing an effective graph:"},
        {"type":"text","info":"- Location of the array element on the heap is ( (char *)array + 1 )"},
        {"type":"text","info":"- De-referenced data of the array element is *( (char *)array + 1 )"},
        {"type":"text","info":"So how can we represent this difference? First we use an Edge struct to represent adjacency, which is a property of graphs where two vertices are connected by an edge."},
        {"type":"subtitle","info":"Representing an Edge"},
        {"type":"text","info":"In the code presented below, we will represent an edge as a C++ struct with public members. We will do this to reduce coding complexity within the Vertex struct and the Graph struct. We have the destination of the edge, as well as the edge's weight."},
        {"type":"text","info":"- Note: In the Algorithms course, you will study advanced graphs with negative edge weights. To set you up for success in that course, we will define the edge weight as a signed integer. However, we will only investigate graphs with positive edge weights in the course."},
        {"type":"text","info":"We will also introduce our first C++ operator. An operator is a method we can use to perform tasks with objects we have created. For example, we have defined an operator== which allows us to compare the weight of an edge, and return true/false. Instead of having to write methods that pass the weight to the user and then requiring the user to call and compare, we can reduce the coding complexity by allowing the programmer to simply call == on two edges."},
        {"type":"text","info":"- The format for the C++ operator for == is bolded and highlighted in maroon in the Code Example below, which also may be found at Edge.h"},
        {"type":"code","info":"https://raw.githubusercontent.com/mmorri22/sp22-cse-20312/main/Lec17_Reading/include/Edge.h"},
        {"type":"subtitle","info":"Adjacency List vs Adjacency Matrix"},
        {"type":"text","info":"The first approach is to represent each vertex as a cell in a vector, and each vertex contains a list of outgoing edges. This is known as an Adjacency List."},
        {"type":"text","info":"- Space-efficient, when G is sparse, meaning the number of edges between vertices are small."},
        {"type":"text","info":"- Easy modification for variants."},
        {"type":"text","info":"However, the adjacency list has some disadvantages"},
        {"type":"text","info":"- Determining whether an edge exists between two vertices requires a search through all the outgoing edges from both nodes"},
        {"type":"text","info":"The diagram below shows our initial graph, as well as the corresponding Adjacency List."},
        {"type":"text","info":"The second approach is to represent each vertex as an n by n matrix, where he outgoing edge and weight are represented in each cell. This is known as an Adjacency Matrix."},
        {"type":"text","info":"- Can immediately find whether an edge exists between two vertices in O(1) time."},
        {"type":"text","info":"- Space: O(V2)."},
        {"type":"text","info":"- Not memory efficient for large graphs. Worse for sparse graphs."},
        {"type":"text","info":"The diagram below shows our initial graph, as well as the corresponding Adjacency Matrix. For simplicity at this stage, we assume all edge weights are equal to 1."},
        {"type":"text","info":"Design Choice: Because of the relative simplicity to implement, as well as lower memory overhead and reinforcement of previous course concepts, we will be implementing an adjacency list representation of a graph in this course."},
        {"type":"subtitle","info":"Representing a Vertex"},
        {"type":"text","info":"Next, we will design a vertex struct which will be used in the entire Vertex struct we will present below is available at Vertex.h"},
        {"type":"text","info":"Constructors and Destructor"},
        {"type":"text","info":"In the Vertex, we will have three private members,"},
        {"type":"text","info":"- a VECTOR of Edges to represent the outgoing edges."},
        {"type":"text","info":"- The data element itself"},
        {"type":"text","info":"- A boolean to represent whether the boolean is valid."},
        {"type":"text","info":"Why do you think we need that boolean? Take a moment to consider, and the solution is after the presented code. (Hint: Think Hash deletion)"},
        {"type":"text","info":"template<class T>"},
        {"type":"text","info":"class Vertex{"},
        {"type":"text","info":"     private:"},
        {"type":"text","info":"         VECTOR< Edge > edges;"},
        {"type":"text","info":"         T data;"},
        {"type":"text","info":"         bool valid; // Valid Vertex"},
        {"type":"text","info":"The reason we keep track of a boolean is that, just like a Hash Table, the values inserted rely on the index of the previous values. If we delete an element from the vector, then all of the edge locations after that deleted element are now off by one. We will see later that we will mark the vertex as invalid and then delete all the outgoing and incoming edges in the Graph."},
        {"type":"text","info":"Next, we create a default constructor for no data value input, and an overloaded constructor where we have a data value. For the destructor, we leave it empty, and the destructor will automatically call the destructor in std::vector Standard Template Library."},
        {"type":"text","info":"Vertex( ) : edges(), data( ), valid( true ) {}"},
        {"type":"text","info":"Vertex( const T& dataIn ) : edges(), data( dataIn ), valid( true ) {}"},
        {"type":"text","info":"~Vertex(){ }"},
        {"type":"text","info":"Next, we will create methods to get and set the vertex data value. These methods are also presented to help review the use of const in C++ methods and Call by Reference."},
        {"type":"text","info":"- Remember that any method in a C++ struct that does not change a private member should be labeled as const"},
        {"type":"text","info":"- Remember that we call by reference in the event the templated type is significantly larger than an int, as it often will be in graphs. The call be reference reduces the memory by creating a pointer to the original object instead of making a copy."},
        {"type":"text","info":"- The const in set_vertex_value allows us to create an object directly in the method call without having to save to an intermediate register."},
        {"type":"text","info":"T get_vertex_value() const{"},
        {"type":"text","info":"     return data;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"void set_vertex_value(const T& dataIn){"},
        {"type":"text","info":"     data = dataIn;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"In the method add_edge, we will pass the destination index and the weight, and then call the Edge constructor in the push_back method"},
        {"type":"text","info":"- Calling the constructor in push_back is an example of why we use const T& in the templated type."},
        {"type":"text","info":"- Notice in the C++ STL that the call for push_back is void push_back( const value_type& val ) for this exact reason"},
        {"type":"text","info":"- Since unsigned ints and ints are smaller than the 64 bit pointer, I pass by value since the memory is lower."},
        {"type":"text","info":"void add_edge( unsigned int destin, int weight ){"},
        {"type":"text","info":"     // If not, put the edge on the back of the array"},
        {"type":"text","info":"     edges.push_back( Edge(destin, weight) );"},
        {"type":"text","info":"}"},
        {"type":"text","info":"In the method get_edge_value, we use call by reference to return the weight, and a bool to check if the edge exists in the graph. Since this is an adjacency list representation, we must iterate through all the edges and compare destin with the value in the edge."},
        {"type":"text","info":"In the if-statement where we determine if the element is true, we set edgeFound to true, and then update weight to return with the call by reference"},
        {"type":"text","info":"The boolean allows us to tell the user if the edge does not exist, meaning we do not implement the resulting code, allowing us to employ the graph cleanly and safely."},
        {"type":"text","info":"// Pass the destination, return weight with call be reference, bool if found"},
        {"type":"text","info":"bool get_edge_value( unsigned int destin, int& weight ) const{"},
        {"type":"text","info":"     bool edgeFound = false;"},
        {"type":"text","info":"     for( unsigned int i = 0; i < edges.size(); i++){"},
        {"type":"text","info":"         if( edges[i].destin == destin ){"},
        {"type":"text","info":"             edgeFound = true;"},
        {"type":"text","info":"             weight = edges[i].weight;"},
        {"type":"text","info":"         }"},
        {"type":"text","info":"     }"},
        {"type":"text","info":"     return edgeFound;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"We have two more crucial methods, which involve deletion for the edge and for the vertex. For the edge, we need to find the destination in the outgoing edge, and then call the std::vector erase method. Just like with the other methods, we use a boolean to return to the user whether the requested edge was found and deleted:"},
        {"type":"text","info":"bool remove_edge( unsigned int edgeLoc ){"},
        {"type":"text","info":"     bool deleted = false;"},
        {"type":"text","info":"     for(unsigned int i = 0; i < edges.size(); i++){"},
        {"type":"text","info":"         if( edges[i].destin == edgeLoc ){"},
        {"type":"text","info":"             edges.erase( edges.begin() + i);"},
        {"type":"text","info":"             deleted = true;"},
        {"type":"text","info":"             break;"},
        {"type":"text","info":"         }"},
        {"type":"text","info":"     }"},
        {"type":"text","info":"     return deleted;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"Finally, for marking the vertex as deleted, and then we delete all the outgoing edges"},
        {"type":"text","info":"void lazy_delete(){"},
        {"type":"text","info":"     valid = false;"},
        {"type":"text","info":"     while( edges.size() > 0 ){"},
        {"type":"text","info":"         // Remove the front edge"},
        {"type":"text","info":"         edges.erase( edges.begin() );"},
        {"type":"text","info":"     }"},
        {"type":"text","info":"}"},
        {"type":"text","info":"In the code testVert2.cpp, we create a Graph where the data are std::string values that represent the banks and islands in the Bridges of Koningsberg problem."},
        {"type":"text","info":"- The printout format for the edges is { destination, weight }"},
        {"type":"text","info":"- We also delete the edge going from 2 -> 1 and then print the vertices again."},
        {"type":"text","info":"- We are able to perform all these tasks and pass valgrind."},
        {"type":"text","info":"-bash-4.2$ make testVert2"},
        {"type":"text","info":"g++ -m64 -std=c++11 -O2 -g -Wall -Wextra -Wconversion -Wshadow -Werror -c src/testVert2.cpp -o objects/testVert2.o"},
        {"type":"text","info":"g++ -m64 -std=c++11 -O2 -g -Wall -Wextra -Wconversion -Wshadow -Werror -o exe/testVert2 objects/testVert2.o"},
        {"type":"text","info":"-bash-4.2$ valgrind --leak-check=full exe/./testVert2"},
        {"type":"text","info":"==12470== Memcheck, a memory error detector"},
        {"type":"text","info":"==12470== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al."},
        {"type":"text","info":"==12470== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info"},
        {"type":"text","info":"==12470== Command: exe/./testVert2"},
        {"type":"text","info":"==12470=="},
        {"type":"text","info":"0: [Top River Bank: {1, 1} {1, 1} {3, 1} ]"},
        {"type":"text","info":"1: [Left Island: {0, 1} {0, 1} {2, 1} {2, 1} {3, 1} {1, 1} ]"},
        {"type":"text","info":"2: [Bottom River Bank: {1, 1} {3, 1} ]"},
        {"type":"text","info":"3: [Right Island: {2, 1} {0, 1} ]"},
        {"type":"text","info":"Deleting Edge {2, 1} from Graph"},
        {"type":"text","info":"0: [Top River Bank: {1, 1} {1, 1} {3, 1} ]"},
        {"type":"text","info":"1: [Left Island: {0, 1} {0, 1} {2, 1} {3, 1} {1, 1} ]"},
        {"type":"text","info":"2: [Bottom River Bank: {1, 1} ]"},
        {"type":"text","info":"3: [Right Island: {2, 1} {0, 1} ]"},
        {"type":"text","info":"==12470=="},
        {"type":"text","info":"==12470== HEAP SUMMARY:"},
        {"type":"text","info":"==12470== in use at exit: 0 bytes in 0 blocks "},
        {"type":"text","info":"==12470== total heap usage: 18 allocs, 18 frees, 658 bytes allocated"},
        {"type":"text","info":"==12470=="},
        {"type":"text","info":"==12470== All heap blocks were freed -- no leaks are possible"},
        {"type":"text","info":"==12470=="},
        {"type":"text","info":"==12470== For lists of detected and suppressed errors, rerun with: -s"},
        {"type":"text","info":"==12470== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)"},
        {"type":"text","info":"Lecture 17 Introduction Question 3: What are the differences between an adjacency list and an adjacency matrix?"},
        {"type":"text","info":"Lecture 17 Introduction Question 4: How do we implement an Edge and a Vertex in an Adjacency List Representation of a Graph?"},
        {"type":"subtitle","info":"Reading 17.3 - Making the Graph Data Structure"},
        {"type":"subtitle","info":"Creating the Graph Struct"},
        {"type":"text","info":"In the file Graph.h, we will create the vector of vertices to represent the Adjacency List."},
        {"type":"text","info":"template< typename T > struct Graph{ private: VECTOR< Vertex< T > > vertices;    // Adjacency List public: // Constructor Graph( ) : vertices() {} // Destructor ~Graph( ) { }"},
        {"type":"text","info":"Next, we will create methods to add an initial vertex as well as an edge to the Graph using our previously defined Edge and Vertex methods. Notice how, in the Graph add_edge method, I check the origin and destination to ensure the locations are valid, and then we call add_edge from the Vertex."},
        {"type":"text","info":"// Add a vertex prior to any edges void add_vertex( const T& vertexData ){ Vertex<T> theVertex( vertexData ); vertices.push_back( theVertex ); } // Add Edge from Origin to Destination, with weight void add_edge(unsigned int origin, unsigned int destin, int weight ){ if( origin < vertices.size() && destin < vertices.size() ){vertices[origin].add_edge( destin, weight );}}"},
        {"type":"text","info":"We implemented the follow methods that use the same approach as vertex, except we go to the index indicated by the vertex value"},
        {"type":"text","info":"bool get_vertex_value( const unsigned int vertex, T& value )"},
        {"type":"text","info":"bool set_vertex_value( const unsigned int vertex, T& value )"},
        {"type":"text","info":"bool get_edge_value( const unsigned int origin, const unsigned int destin, int& weight)"},
        {"type":"text","info":"bool set_edge_value( const unsigned int origin, const unsigned int destin, const int weight)"},
        {"type":"text","info":"To delete an edge at the Graph level, we need the origin (to find it in the Adjacency List vector) and the destination (to find it in the list of outgoing edges). Notice how we still use the bool to ensure safe operation by informing the user whether the edge was actually deleted r not"},
        {"type":"text","info":"bool remove_edge( unsigned int origin, unsigned int destin){ // If the origin and destination are valid if( origin < vertices.size() && destin < vertices.size() ){ // From the Origin vertex, remove the destination vertex return vertices[origin].remove_edge( destin ); } return false;}"},
        {"type":"text","info":"Finally, for deleting a vertex, we mark the element at the index as deleted. Then, we iterate through all the other vertices and remove outgoing edges that point to the marked vertex. This allows us to reduce memory overhead consumed by edges going to a vertex that is no longer part of the graph while simultaneously allowing us to preserve the original location of all the edges, preventing indexing errors throughout the graph."},
        {"type":"text","info":"void remove_vertex( unsigned int vertVal ){ // First, perform Lazy Deletion on the vertex vertices[ vertVal ].lazy_delete(); // Next, go through each vertex and remove all edges with the destination to the vertex for( unsigned int iter = 0; iter < vertices.size(); iter++ ){ int jter = 0; // While the increment is less than the number of edges while( jter < vertices[iter].num_edges() ){ // If the destination of the edge is the vertex we are removing if( vertices[iter].get_edge( jter ).destin == vertVal ){ // Remove that edge vertices[iter].remove_edge( vertVal ); } else{ // Only increment jter is there is not any deletion jter++; } } } }"},
        {"type":"text","info":"In the file testGraph1.cpp (Links to an external site.), we test a robust Graph test where we insert, remove, and print elements. Notice how we tested the graph at various stages, include the edges, vertices, and then the final Graph. This design process will serve you well as a Computer Scientist or Computer Engineer, because modularity in design reduces coding and testing complexity."},
        {"type":"text","info":"-bash-4.2$ make testGraph1 g++ -m64 -std=c++11 -O2 -g -Wall -Wextra -Wconversion -Wshadow -Werror -c src/testGraph1.cpp -o objects/testGraph1.o g++ -m64 -std=c++11 -O2 -g -Wall -Wextra -Wconversion -Wshadow -Werror -o exe/testGraph1 objects/testGraph1.o -bash-4.2$ valgrind --leak-check=full exe/./testGraph1 ==30408== Memcheck, a memory error detector ==30408== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al. ==30408== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info ==30408== Command: exe/./testGraph1 ==30408== 0: [Top River Bank: {1, 1} {1, 1} {3, 1} ] 1: [Left Island: {0, 1} {0, 1} {2, 1} {2, 1} {3, 1} ] 2: [Bottom River Bank: {1, 1} {1, 1} {3, 1} ] 3: [Right Island: {2, 1} {0, 1} ] ==30408== ==30408== HEAP SUMMARY: ==30408== in use at exit: 0 bytes in 0 blocks ==30408== total heap usage: 19 allocs, 19 frees, 690 bytes allocated ==30408== ==30408== All heap blocks were freed -- no leaks are possible ==30408== ==30408== For lists of detected and suppressed errors, rerun with: -s  ==30408== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)"}
        ]},
    {"unique_id":"5-2","content":[
        {"type":"subtitle","info":"Reading 18.1 - Topological Sorting"},
        {"type":"subtitle","info":"Pruning the Graph"},
        {"type":"text","info":"In our study of Complete Search, we learned about the benefits of \"pruning the search tree\" in order to minimize the required search time for a specific task. For example, we used a mathematical approach in the N-Queens problem to find the placed Queens instead of searching every possible location a Queen could be, which significantly reduced the run time."},
        {"type":"text","info":"In this lecture, we will cover two methods of pruning a Graph to improve search time."},
        {"type":"text","info":"- Topological Sorting, which builds upon Depth-First Search"},
        {"type":"text","info":"- Minimum Spanning Tree, which builds upon Breadth-First Search and accounts for edge weights."},
        {"type":"subtitle","info":"Topological Sorting"},
        {"type":"text","info":"The main idea of Topological Sorting is that we perform an exhaustive Depth-First Search, meaning that we determine the path from the origin to every reachable node in the Graph. The end result is that the result of a Depth-First Search from the origin to any other node is determined in the Topologically Sorted graph. The difference is that all the edges that are not directly traversed in a DFS from the original graph are removed, in effect pruning the search tree."},
        {"type":"text","info":"The algorithm for DFS is the same, except we do not have a \"destination\" to terminate the algorithm."},
        {"type":"text","info":"- Start at the origin of the search"},
        {"type":"text","info":"- Create arrays for bool visited_verts and unsigned int visited_edges"},
        {"type":"text","info":"- For each outgoing edge E in the current Vertex V"},
        {"type":"text","info":"-> If the destination edge Vdest in E in visited_verts is false"},
        {"type":"text","info":"--> Set visited_verts[Vdest] = true"},
        {"type":"text","info":"-> Recursively call DFS with Vdest as the new edge origin"},
        {"type":"text","info":"- Increment visited_edges[ V ]"},
        {"type":"text","info":"Consider the following Example:"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=806047fd-2a90-462b-954d-ae4b00769444&start=0"},
        {"type":"text","info":"Lecture 18 Introduction Question 1: What is the main idea behind a Topological Sort of a Graph, and how is a Topologically Sorted Graph derived?"},
        {"type":"subtitle","info":"Reading 18.2 - Implementing Topological Sorting in C++ Code"},
        {"type":"text","info":"In our new Graph.h code for this lecture, we will implement the Topological Sorting in out C++ struct that we have been building C++ Lecture 17 In Class and in Lab 08."},
        {"type":"text","info":"You can see that the TopSort method in our updated Graph.h (Links to an external site.) is similar to the method we programmed together in class, with the exception that we do not terminate since we do not have a \"destination\" vertex. We simply run DFS exhaustively until we read every node."},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/raw/main/Lec18_Reading/include/Graph.h"},
        {"type":"text","info":"The primary difference is in the public method that is called by the user.  We create a new graph object, and then make copies of all the vertices. When we run the Topological Sort from the index, we will make a copy of all the edges in the original graph that we encounter into the new graph. What we return is a pruned graph where the edges that are not part of the Topologically Sorted graph are simply not copied into the new graph."},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/raw/main/Lec18_Reading/src/TopSort.cpp"},
        {"type":"text","info":"In the testing function TopSort.cpp (Links to an external site.), you will see that we create an entirely new graph and then copy all the vertices and only the encountered edges into the new graph.  You will see that, when we run the same Depth-First Searches on the original graph (shown above in the diagram), and the Topologically Sorted graph (shown in the bottom diagram), we will always get the same result)."},
        {"type":"text","info":"-bash-4.2$ make TopSort"},
        {"type":"text","info":"g++ -m64 -std=c++11 -O2 -g -Wall -Wextra -Wconversion -Wshadow -Werror -c src/TopSort.cpp -o objects/TopSort.o"},
        {"type":"text","info":"g++ -m64 -std=c++11 -O2 -g -Wall -Wextra -Wconversion -Wshadow -Werror -o exe/TopSort objects/TopSort.o"},
        {"type":"text","info":"exe/./TopSort"},
        {"type":"text","info":"Original Graph:"},
        {"type":"text","info":"0: [4: {1, 1} {2, 1} ]"},
        {"type":"text","info":"1: [20: {3, 1} {4, 1} ]"},
        {"type":"text","info":"2: [5: {3, 1} ]"},
        {"type":"text","info":"3: [10: {5, 1} {2, 1} ]"},
        {"type":"text","info":"4: [30: {5, 1} ]"},
        {"type":"text","info":"5: [18: {4, 1} ]"},
        {"type":"text","info":"The valid DFS path from 0 to 5 is: 0 1 3 5"},
        {"type":"text","info":"The valid DFS path from 0 to 4 is: 0 1 3 5 4 "},
        {"type":"text","info":"The valid DFS path from 0 to 3 is: 0 1 3"},
        {"type":"text","info":"The valid DFS path from 0 to 2 is: 0 1 3 2"},
        {"type":"text","info":"The valid DFS path from 0 to 1 is: 0 1"},
        {"type":"text","info":"The valid DFS path from 0 to 0 is: 0"},
        {"type":"text","info":"Topological Sort Graph:"},
        {"type":"text","info":"0: [4: {1, 1} ]"},
        {"type":"text","info":"1: [20: {3, 1} ]"},
        {"type":"text","info":"2: [5: ]"},
        {"type":"text","info":"3: [10: {2, 1} {5, 1} ]"},
        {"type":"text","info":"4: [30: ]"},
        {"type":"text","info":"5: [18: {4, 1} ]"},
        {"type":"text","info":"The valid DFS path from 0 to 5 is: 0 1 3 5"},
        {"type":"text","info":"The valid DFS path from 0 to 4 is: 0 1 3 5 4"},
        {"type":"text","info":"The valid DFS path from 0 to 3 is: 0 1 3"},
        {"type":"text","info":"The valid DFS path from 0 to 2 is: 0 1 3 2"},
        {"type":"text","info":"The valid DFS path from 0 to 1 is: 0 1"},
        {"type":"text","info":"The valid DFS path from 0 to 0 is: 0"},
        {"type":"text","info":"Lecture 18 Introduction Question 2: How do we implement a Topological Sort in C++, and what are the main differences between a Topological Sort and performing a Depth-First Search in C++?"},
        {"type":"subtitle","info":"Reading 18.3 - Deriving the Minimum Spanning Tree"},
        {"type":"text","info":"Consider the following problem: We are tasked to wire the entire Notre Dame campus. Since we are working in Fitzpatrick Hall, we will originate our power station from the CSE Commons. If we are going to wire the campus we must consider length and cost of all the wires."},
        {"type":"text","info":"Consider a naive approach where all the wires all going from Fitzpatrick Hall to their destination. We require significant, excessive, and redundant wiring across campus. This approach would drive up costs without providing an additional benefits to our customers."},
        {"type":"text","info":"Now let's consider an approach where we reduce the total wire length but setting up wire-routing stations where we strategically split the wiring to reach as many locations on campus as possible. Not only does this reduce wire costs, but makes the process of troubleshooting wire routing issues easier."},
        {"type":"text","info":"To solve this problem, we want to find a graph with a minimum length of wire that connects all the relevant locations on campus."},
        {"type":"text","info":"More formally, we want to find a subgraph of an undirected weighted graph G, such that:"},
        {"type":"text","info":"- it is a tree (i.e., it is acyclic - we do not visit the same node twice)"},
        {"type":"text","info":"- it covers all the vertices V"},
        {"type":"text","info":"-> contains |V| - 1 edges"},
        {"type":"text","info":"A graph G that meets these conditions is known as a Minimum Spanning Tree."},
        {"type":"text","info":"Minimum spanning trees have direct applications in the design of networks, including computer networks, telecommunications networks, transportation networks, water supply networks, and electrical grids"},
        {"type":"subtitle","info":"Prim's Algorithm"},
        {"type":"text","info":"There are several algorithms for finding a Minimum Spanning Tree in a Graph. The Greedy approach is known as Borůvka's algorithm, and the advanced algorithmic approach is known as Kruskal's algorithm. The approach we will study is a pruning search tree approach that utilizes Hash Tables and Priority Queues called Prim's Algorithm."},
        {"type":"text","info":"- At this stage of your Computer Science or Computer Engineering career, think of Prim's Algorithm like Goldilocks: Kruskal's algorithm is too hot. Borůvka's algorithm is too cold. And Prim's Algorithm is just right."},
        {"type":"text","info":"To begin the algorithm, we pick a vertex to be the root, just like in Topological Sorting."},
        {"type":"text","info":"- Create vectors for the weight to reach each node, as well as the parent of each node."},
        {"type":"text","info":"- Start at the root node, and enter all vertices that can be reached by the outgoing edges."},
        {"type":"text","info":"-> In BFS, we put the elements in a queue by the order we encountered them."},
        {"type":"text","info":"-> In Topological Sorting, we sort the elements in a stack by the order we encountered them"},
        {"type":"text","info":"-> We continuously evaluate each vertex, updating the parent and weight values for each location until we have the minimum set of edges."},
        {"type":"text","info":"Note: Graphs can have multiple Minimum Spanning Trees where the total edge weights are the same, but have different edges going to different nodes. On examples in Weekly Surveys and Exam 2, the graph you will be presented is guaranteed to have precisely one Minimum Spanning Tree."},
        {"type":"text","info":"In the video below, I walk through an example of Prim's Algorithm. The example starts with the graph G on the left, and produces the minimum spanning tree on the right:"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=858f52fd-a8a8-45bc-9de3-ae4b0091dd17&start=1.872798"},
        {"type":"text","info":""},
        {"type":"subtitle","info":"Minimum Spanning Tree Example"},
        {"type":"text","info":"Another Minimum Tree Example is presented in the video below. As you review this example, note how the ordering of the inserted node has an impact on which vertices are evaluated next (although, as previously promised, this graph has one unique Minimum Spanning Tree)."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=9bcdaa89-100b-4976-bd5c-ae4b00aace77"},
        {"type":"text","info":"Lecture 18 Introduction Question 3: What is a Minimum Spanning Tree, and what are the benefits of deriving a Minimum Spanning Tree?"},
        {"type":"text","info":"Lecture 18 Introduction Question 4: How do we derive a Minimum Spanning Tree? Specifically, which data structures that we have learned to this point are utilized to perform this algorithmic approach?"}
        ]},
    {"unique_id":"5-3","content":[
        {"type":"subtitle","info":"Reading 19.1 - Finding the Shortest Path in a Graph"},
        {"type":"text","info":"To this point, we have utilized Complete Search and Pruning the Search Tree approaches to performing graph traversals:"},
        {"type":"text","info":"- Complete Search: Breadth-First Search and Depth-First Search"},
        {"type":"text","info":"- Pruning the Search Tree: Minimum Spanning Trees and Topological Sorting"},
        {"type":"text","info":"However, none of these approaches or algorithms return the solution to the shortest path between two locations."},
        {"type":"text","info":"Consider a problem where we want to find the shortest path from  Fitzpatrick Hall to the Hesburgh Library."},
        {"type":"text","info":"Naïve: Long Route around the football and basketball stadiums"},
        {"type":"text","info":"- Technically a correct route"},
        {"type":"text","info":"- But is it a good route? Not in the rain!"},
        {"type":"text","info":"-> BFS or DFS often produce this solution. The goal of BFS and DFS is to determine whether a path exists, not if it is the best path."},
        {"type":"text","info":"-> BFS and DFS are dependent upon the order in which the locations are inserted into the data structure."},
        {"type":"text","info":"-> If a sidewalk is entered into the graph that improves upon the previous solution, DFS definitely will not find it and BFS likely will not find it."},
        {"type":"text","info":"-> Illustrates the importance of understand how the structure of data impacts the computing efficiency."},
        {"type":"subtitle","info":"Using Edge Weights, Priority Queues, and Dynamic Programming to Improve the Search Algorithm"},
        {"type":"text","info":"We can build upon the idea of using edge weights and Priority Queues, like we did in determining the Minimum Spanning Tree, to derive the shortest path."},
        {"type":"text","info":"- Sorting and updating the edges in a priority queue allows us to make an educated guess as to which path we can choose."},
        {"type":"text","info":"- By using a Heap instead of a Doubly Linked List when we aggregate the Priority Queue, we improve the insertion into the priority queue from O(n2) to O(n*lg2(n))"},
        {"type":"text","info":"-> For a graph with a million nodes, here is the Priority Queue improvement"},
        {"type":"text","info":"--> O(n2) is 1,000,000,000,000 operations"},
        {"type":"text","info":"--> O(n*lg2(n)) is 19,931,568 operations"},
        {"type":"text","info":"--> An improvement of 99.998 percent!"},
        {"type":"text","info":"Consider the following graph where there are several paths from the node containing 4 to the node containing 18."},
        {"type":"text","info":"The following path: 4->20->10->18 encounters edges of weights 3 + 4 + 2 = 9"},
        {"type":"text","info":"Meanwhile, the path 4->20->30->18 encounters edges of weights 3 + 2 + 2 = 7"},
        {"type":"text","info":"Also, the path 4->5->10->18 encounters edges of weights 1 + 5 + 2 = 8"},
        {"type":"text","info":"In a simple graph like this, we can tell with our own eyes which is the shortest path. But we need to use effective data structures to scale to a much larger graph, like one we would encounter in a map!"},
        {"type":"text","info":"We can improve upon this approach even further using Dynamic Programming!"},
        {"type":"text","info":"Intuitively: The shortest path between u and v is measured by distance d"},
        {"type":"text","info":"- If d(u,v) < d(u,x) + d(x,v)"},
        {"type":"text","info":"-> Then Edge (u,v) is the shortest path between them"},
        {"type":"text","info":"Therefore, the shortest path for a graph contains the shortest path for the subgraphs that contain that path. Consider the diagram below."},
        {"type":"text","info":"- I claim the path 4->5->10->18 > 4->20->10->18"},
        {"type":"text","info":"- Both paths contain the edge between the vertices containing 10->18"},
        {"type":"text","info":"- Therefore, the shortest path to 10 is now the shortest path between these two paths"},
        {"type":"text","info":"- Now we compare the two paths to the vertex containing 10:"},
        {"type":"text","info":"-> 4->5->10 < 4->20->10"},
        {"type":"text","info":"-> Weights: 3 + 4 < 1 + 5"},
        {"type":"text","info":"-> Weights: 7 < 6"},
        {"type":"text","info":"With this knowledge, we can use dynamic programming to find the Shortest Path in the graph, which we will accomplish in the next section."},
        {"type":"text","info":"Lecture 19 Introduction Question 1: What are the drawbacks to using Breadth-First Search or Depth-First Search to determining a path from one location to another in a graph?"},
        {"type":"text","info":"Lecture 19 Introduction Question 2: How can we use out knowledge of Priority Queues and Dynamic Programming to find the shortest path in a Graph?"},
        {"type":"subtitle","info":"Reading 19.2 - Dijkstra's Algorithm"},
        {"type":"text","info":"In this section, we will study Dijkstra's Algorithm, which will help us determine the Shortest Path between two vertices in a graph using the concepts we studied in Reading 19.1."},
        {"type":"text","info":"In this algorithm we first initialize vectors to distance and parents, as we have done in DFS, BFS, Topological Sort, and Minimum Spanning Trees."},
        {"type":"text","info":"- Distance from all but origin is infinity"},
        {"type":"text","info":"- Parent is currently -1 for all vertices"},
        {"type":"text","info":"Create a Priority Queue to evaluate the next values"},
        {"type":"text","info":"- We put them in when visited"},
        {"type":"text","info":"- Put on the PQ in Edge Weight Order"},
        {"type":"text","info":"If dist[u] + weight < dist [v] of the current vertices we are evaluatin"},
        {"type":"text","info":"- Update dist[v] to dist[u] + weight"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=d5e11a10-d673-4521-a6d1-ae4b00b32c9d&start=5.092727"},
        {"type":"text","info":"Lecture 19 Introduction Question 3: Describe the process for determining the shortest path in a graph using Dijkstra's Algorithm"},
        {"type":"subtitle","info":"Reading 19.3 - Implementing Dijkstra in C++ Object-Oriented Programming"},
        {"type":"text","info":"In this section, we will present the code segment to implement Dijkstra's Algorithm in C++. The code below is a subset of the code presented in Graph.h, which has input checking for origin and destin, and include the same process of using the finalPath stack to print the actual path."},
        {"type":"text","info":"- Note how each parent is initialized to -1"},
        {"type":"text","info":"- Note how each distance is initialized to 2147483647, which is the largest possible signed integer, which will represent infinity in this case"},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/raw/main/Lec19_Reading/include/Graph.h"},
        {"type":"text","info":"Finally, we will compile and run the program. The program run will create a graph and then run Dijkstra's Algorithm (found at Dijkstra.cpp (Links to an external site.)) on several paths in the graph. You will also see that the final graph (provided at Graph.h) implements Breadth-First Search, Depth-First Search, Topological Sorting, Prim's Algorithm for the Minimum Spanning Tree, and Dijkstra's Algorithm for the Shortest Path algorithm. I also run two tests with invalid inputs."},
        {"type":"text","info":"You should now see that Graphs combine all the concepts we have learned up to this point in the semester:"},
        {"type":"text","info":"- Stacks - which aggregate from Singly Linked Lists - and Recursion were used for Depth-First Search, as well as tracking the final paths for all the algorithms"},
        {"type":"text","info":"-> To review trees, Depth-First Search is the graph equivalent of a Pre-Order Traversal in a Binary Search Tree"},
        {"type":"text","info":"- Queues - which aggregate from Doubly Linked Lists - were used for Breadth-First Search"},
        {"type":"text","info":"-> To review trees, Breadth-First Search is the graph equivalent of a Level-Order Traversal in a Binary Search Tree"},
        {"type":"text","info":"- Priority Queues - which aggregate from Heaps - for pruning the search tree via dynamic programming in both Prim's Algorithm and Dijkstra's Algorithm"},
        {"type":"text","info":"- Vectors to track intermediate steps for BFS and DFS, as well as the Adjacency List for the Graph we implemented"},
        {"type":"text","info":"- C and C++ pointers and structs were used for tracking all outgoing edges and vertices"},
        {"type":"text","info":"- C++ Operators, which we used for the Minimum Spanning Tree for implementing object-oriented priority queues."},
        {"type":"text","info":"In Lecture 19, we will review two examples of Dijkstra's Algorithm, and then will spend the rest of the Lecture reviewing for Exam 2."},
        {"type":"text","info":"-bash-4.2$ make Dijkstra"},
        {"type":"text","info":"g++ -m64 -std=c++11 -O2 -g -Wall -Wextra -Wconversion -Wshadow -Werror -c src/Dijkstra.cpp -o objects/Dijkstra.o"},
        {"type":"text","info":"g++ -m64 -std=c++11 -O2 -g -Wall -Wextra -Wconversion -Wshadow -Werror -o exe/Dijkstra objects/Dijkstra.o"},
        {"type":"text","info":"-bash-4.2$ valgrind --leak-check=full exe/./Dijkstra"},
        {"type":"text","info":"==27018== Memcheck, a memory error detector"},
        {"type":"text","info":"==27018== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al."},
        {"type":"text","info":"==27018== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info"},
        {"type":"text","info":"==27018== Command: exe/./Dijkstra"},
        {"type":"text","info":"==27018=="},
        {"type":"text","info":"0: [4: {1, 3} {2, 1} ]"},
        {"type":"text","info":"1: [20: {3, 4} {4, 2} ]"},
        {"type":"text","info":"2: [5: {3, 5} ]"},
        {"type":"text","info":"3: [10: {5, 2} ]"},
        {"type":"text","info":"4: [30: {5, 2} ]"},
        {"type":"text","info":"5: [18: ]"},
        {"type":"text","info":"The valid Dijkstra path from 0 to 5 is: 0 1 4 5 , and the distance is 7"},
        {"type":"text","info":"The valid Dijkstra path from 0 to 4 is: 0 1 4 , and the distance is 5"},
        {"type":"text","info":"The valid Dijkstra path from 0 to 3 is: 0 2 3 , and the distance is 6"},
        {"type":"text","info":"The valid Dijkstra path from 0 to 2 is: 0 2 , and the distance is 1"},
        {"type":"text","info":"The valid Dijkstra path from 0 to 1 is: 0 1 , and the distance is 3"},
        {"type":"text","info":"The valid Dijkstra path from 0 to 0 is: 0 , and the distance is 0"},
        {"type":"text","info":"Invalid Inputs"},
        {"type":"text","info":"Invalid Inputs"},
        {"type":"text","info":"==27018=="},
        {"type":"text","info":"==27018== HEAP SUMMARY:"},
        {"type":"text","info":"==27018== in use at exit: 0 bytes in 0 blocks"},
        {"type":"text","info":"==27018== total heap usage: 58 allocs, 58 frees, 7,816 bytes allocated"},
        {"type":"text","info":"==27018=="},
        {"type":"text","info":"==27018== All heap blocks were freed -- no leaks are possible"},
        {"type":"text","info":"==27018=="},
        {"type":"text","info":"==27018== For lists of detected and suppressed errors, rerun with: -s"},
        {"type":"text","info":"==27018== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)"}
        ]},

    {"unique_id":"6-1","content":[
        {"type":"subtitle","info":"Reading 21.1 - Software Engineering"},
        {"type":"subtitle","info":"Lecture 21: Skim and Learn"},
        {"type":"text","info":"For this lecture, I want you to skim and learn these concepts. I will not be asking you about any of these concepts directly on the Exam or Weekly Surveys. However, these concepts are more important in the context of your final project and careers. Focus your reading on developing questions for class so we can have a robust discussion on software engineering principles."},
        {"type":"subtitle","info":"Building towards larger programs"},
        {"type":"text","info":"In the Fundamentals of Computing class, Professor Ramzi Bualuan tells the students at the beginning of the semester that one of the keys to success is to \"break your bad habits\" from your previous programming. We do the same thing here with the application of Production Quality Compilation rules and strict valgrind passing. You now have a much better understanding of the importance of keeping elements in the bounds of an array than you did one year ago, and that is a good thing!"},
        {"type":"text","info":"Normally, when someone has \"bad habits\", the blame falls right on the person. But this is not your fault! Always working at a “small scale” introduces habits that will cause you great pain later, and many of you have only worked at small or medium scale."},
        {"type":"text","info":"In this lecture, I'll work to give you a sense of how to deal with the “large scale” programming. In the official course description, you may have noticed that one of the course objectives is that a student will be able to \"apply and use data structures in real-world application, employing abstractions to make them work together cleanly and safely.\""},
        {"type":"text","info":"Note: This lecture is heavily inspired by two articles and books."},
        {"type":"text","info":"- \"A Philosophy of Software Design\" by John Ousterhout."},
        {"type":"text","info":"- \"A Spiral Model of Software Development and Enhancement\" by Barry Boehm"},
        {"type":"text","info":"Quick Story Time: The \"PQC rules\" originated from a dinner I had with William Gerstenmaier and Richard Morris, the VPs of Mission Assurance and Production and Launch a SpaceX who have led the development of an impressive software development and testing suite. Software failures are one of the most dominant causes of failures in aerospace mission-critical systems. They lamented modern students lacking fundamental and critical knowledge of secure and reliable computing. This is a complaint you will hear and read from hiring managers, especially from industries where memory and reliability are at a premium:"},
        {"type":"text","info":"Some major aerospace failures resulting from bad software over the years include:"},
        {"type":"text","info":"- Ariane-5 (which we studied in our discussion of floats and doubles) - Unhandled floating point exception"},
        {"type":"text","info":"- Mariner I - Missing Hyphen in code"},
        {"type":"text","info":"- Mars Pathfinder - Priority inversion /scheduling bug"},
        {"type":"text","info":"Mars Climate Orbiter - Navigation system failure, metric to imperial units conversion failure"},
        {"type":"text","info":"In fact, Apollo 11 - the mission that first landed humans on the Moon - had a software error that was nearly catastrophic. Known as the Code 1202 error, the Error 1202 error message started flashing approximately seven minutes prior to landing. Furthermore, the software had not been fully tested and the astronauts had not encountered Error 1202. (Imagine if you encountered a new compiler or valgrind error message you had never seen before while simultaneously trying to land an shuttle on the Moon!)"},
        {"type":"text","info":"It turns out that Error 1202 indicated that the guidance system was overloaded with tasks. So the astronauts had to shut the computer off and reboot the system while 33,000 ft from landing on the Moon."},
        {"type":"text","info":"- Error Code 1202 was essentially a Instruction Stack overflow."},
        {"type":"text","info":"Optional Reading: A recently published article goes over many of the same concepts we will discuss in this lecture: How SpaceX Develops Software"},
        {"type":"subtitle","info":"The Power of Software"},
        {"type":"text","info":"Unlike other engineering disciplines, software is effectively unconstrained by the laws of physics."},
        {"type":"text","info":"- Programming is an act of almost pure creativity!"},
        {"type":"text","info":"The greatest limitation we face in building systems is being able to understand what we're building! Very unlike other disciplines, e.g."},
        {"type":"text","info":"- Chemical engineers have to worry about temperature."},
        {"type":"text","info":"- Material scientists have to worry about how brittle a material is."},
        {"type":"text","info":"- Civil engineers have to worry about the strength of concrete."},
        {"type":"text","info":"Our greatest limitation is simply understanding the system we're trying to build!"},
        {"type":"text","info":"As real programs are worked on, they gain more features and complexity."},
        {"type":"text","info":"- Over time, it becomes more difficult for programmers to understand all the relevant pieces as they make future modifications."},
        {"type":"text","info":"Tools like Tabby, GDB, and valgrind all make it easier to deal with complexity."},
        {"type":"text","info":"But our most important goal is to keep our software simple."},
        {"type":"subtitle","info":"Dealing with Complexity"},
        {"type":"text","info":"There are two approaches to managing complexity:"},
        {"type":"text","info":"- Making code simpler and more obvious."},
        {"type":"text","info":"-> Eliminating special cases"},
        {"type":"text","info":"- Encapsulation into modules, as we have done with C++ structs and methods"},
        {"type":"text","info":"-> In a modular design, creators of one “module” can use other modules without knowing how they work."},
        {"type":"subtitle","info":"The Nature of Coding Complexity"},
        {"type":"text","info":"What is complexity exactly? Ousterhout defines it thus:"},
        {"type":"text","info":"- “Complexity is anything related to the structure of a software system that makes it hard to understand and modify the system.”"},
        {"type":"text","info":"Complexity takes many forms:"},
        {"type":"text","info":"- Understanding how the code works."},
        {"type":"text","info":"- The amount of time it takes to make small improvements."},
        {"type":"text","info":"- Finding what needs to be modified to make an improvement."},
        {"type":"text","info":"- Difficult to fix one bug without introducing another."},
        {"type":"text","info":"“If a software system is hard to understand and modify, then it is complicated. If it is easy to understand and modify, then it is simple”."},
        {"type":"text","info":"For example: Using recursion allowed us to perform advanced backtracking regardless of the size of the problem. Recursion allowed us to simplify the coding"},
        {"type":"text","info":"- If you understand how recursion and backtracking work"},
        {"type":"text","info":"- Then, you can significantly reduce the complexity of code"},
        {"type":"text","info":"- The modularity allows us to easily troubleshoot a bug without unintentionally introducing others."},
        {"type":"subtitle","info":"Symptoms and Causes of Complexity"},
        {"type":"text","info":"Ousterhout describes three symptoms of complexity:"},
        {"type":"text","info":"- Change amplification: A simple change requires modification in many places."},
        {"type":"text","info":"-> Our 2048 was a good example of this."},
        {"type":"text","info":"-> This is why I recommended you get the shift_left function working fully first, so that way logical mistakes you may have made in shift_left would not propagate to the other functions."},
        {"type":"text","info":"- Cognitive load: How much you need to know in order to make a change."},
        {"type":"text","info":"-> Note: This is not the same as number of lines of code. Often MORE lines of code actually makes code simpler, because it is more narrative."},
        {"type":"text","info":"-> You'll see this in code I present in lecture. Sometimes, I could combine several lines of code into fewer lines, but that code is harder to decipher for newer programmers."},
        {"type":"text","info":"- Unknown unknowns: The worst type of complexity. This occurs when it's not even clear what you need to know in order to make modifications!"},
        {"type":"text","info":"-> Common in large databases."},
        {"type":"text","info":"-> Quick Story: Two previous ND Data Structures students, Tara Flannery and Brooke Mackey, were tasked with updating code on a gyroscopic monitoring system for the Navy. They successfully recommended cleaning up the code base because the systems code would frequently fail on several tests. They even used the PQC rules to prove the previously existing code was inefficient and unsafe, putting sailors at risk. Based on their recommendations, Pacific Northwest Naval Labs adopted the PQC coding standards."},
        {"type":"subtitle","info":"Complexity Comes Slowly"},
        {"type":"text","info":"Every software system starts out beautiful, pure, and clean.  As they are built upon, they slowly twist into uglier and uglier shapes. This is almost inevitable in real systems."},
        {"type":"text","info":"- Each complexity introduced is no big deal:"},
        {"type":"text","info":"-> “Complexity comes about because hundreds or thousands of small dependences and obscurities build up over time.”"},
        {"type":"text","info":"- “Eventually, there are so many of these small issues that every possible change is affected by several of them.”"},
        {"type":"text","info":"- This incremental process is part of what makes controlling complexity so hard."},
        {"type":"text","info":"- Ousterhout recommends a zero tolerance philosophy."},
        {"type":"text","info":"For those of you who have attended my office hours, this is why I have the message \"Better is the Enemy of Good Enough\" written in my office."},
        {"type":"text","info":"Lecture 21 Introduction Question 1: What is Programming Complexity?"},
        {"type":"text","info":"Lecture 21 Introduction Question 2: What are the three symptoms and causes of Programming Complexity?"},
        {"type":"subtitle","info":"Reading 21.2 - Strategic vs. Tactical Programming"},
        {"type":"text","info":"To this point in your career, much (or all) of the programming that you've done, Ousterhout would describe as “tactical”."},
        {"type":"text","info":"- “Your main focus is to get something working, such as a new feature or bug fix.”"},
        {"type":"text","info":"This may seem like a silly criticism. Clearly, working code is good. "},
        {"type":"text","info":"The problem with tactical programming is that you don't spend problem thinking about overall design."},
        {"type":"text","info":"- As a result, you introduce tons of little complexities, e.g. making two copies of a method that do something similar."},
        {"type":"text","info":"- Each individual complexity seems reasonable, but eventually you start to feel the weight."},
        {"type":"text","info":"-> Refactoring would fix the problem, but it would also take time, so you end up introducing even more complexity to deal with the original ones."},
        {"type":"text","info":"The objective of the Final Project is for you to get your significant experience working through individual complexity throughout a larger design."},
        {"type":"subtitle","info":"Strategic Programming"},
        {"type":"text","info":"“The first step towards becoming a good software designer is to realize that working code isn't enough.”"},
        {"type":"text","info":"- “The most important thing is the long term structure of the system.”"},
        {"type":"text","info":"- Adding complexities to achieve short term time games is unacceptable"},
        {"type":"text","info":"Many of you experienced this growth as a computer scientist or computer engineer when working with valgrind. The code may appear to have worked, except with a valgrind error. The reality is that your code work for that specific set of inputs only, and even then, it didn't necessarily \"work\". For example, perhaps you successfully read elements outside of the array because no other program was using that memory location. However, the valgrind error exposed an unsafe code condition that meant a potentially serious issue with the long term structure of the system."},
        {"type":"subtitle","info":"Suggestions for Strategic Programming"},
        {"type":"text","info":"Strategic programming requires lots of time investment. But those who can do it well are highly coveted in industry, because too many programmers are simply tactical programmers. The \"strategic\" aspect of programming is what differentiates a true computing scientist."},
        {"type":"text","info":"For each new programming task:"},
        {"type":"text","info":"- Rather than implementing the first idea, try coming up with (and possibly even partially implementing) a few different ideas."},
        {"type":"text","info":"-> In the Final Project, you will see that I show you how to \"ideate and discuss\" different ideas with your groupmates"},
        {"type":"text","info":"- When you feel like you have found something that feels clean, then fully implement that idea."},
        {"type":"text","info":"- In real systems: Try to imagine how things might need to be changed in the future, and make sure your design can handle such changes."},
        {"type":"subtitle","info":"Strategic Programming is Hard"},
        {"type":"text","info":"No matter how careful you try to be, there will be mistakes in your design."},
        {"type":"text","info":"- Avoid the temptation to patch around these mistakes. Instead, fix the design."},
        {"type":"text","info":"-> Example: Don't add a bunch of special cases! Instead, make sure the system gracefully handles the cases you didn't think about."},
        {"type":"text","info":"- Indeed, it is impossible to design large software systems entirely in advance."},
        {"type":"subtitle","info":"Facebook as a Tactical Programming Case Study"},
        {"type":"text","info":"As a startup, Facebook embraced tactical programming."},
        {"type":"text","info":"- “Move fast and break things.”"},
        {"type":"text","info":"- Common for new engineers to push changes to the live site within their first week."},
        {"type":"text","info":"-> Very rapid development process in the short term."},
        {"type":"text","info":"-> Felt empowering!"},
        {"type":"text","info":"- Facebook was very successful, but its codebase was a mess."},
        {"type":"text","info":"-> Ousterhout describe their code as “incomprehensible, unstable, few comments or tests, and painful to work with.”"},
        {"type":"text","info":"- Eventually, Facebook's motto became “Move fast with stable infra.”"},
        {"type":"text","info":"Note: Arguably Facebook's general attitude has done great harm. Will discuss in a future lecture."},
        {"type":"subtitle","info":"Google and VMware as a Strategic Programming Case Studies"},
        {"type":"text","info":"By contrast Google and VMware are known as highly strategic organizations."},
        {"type":"text","info":"- Both companies placed a heavy emphasis on high quality code and good design."},
        {"type":"text","info":"-> Google, for many years, was \"in Beta\" because they were committed to proactively fix their design"},
        {"type":"text","info":"- Both companies built sophisticated products that solved complex problems with reliable software systems."},
        {"type":"text","info":"- The companies' strong technical cultures became well known in Silicon Valley. Few other companies could compete with them to hire the top technical talent."},
        {"type":"text","info":"Real world projects and companies succeed with either approach! "},
        {"type":"text","info":"- … but Ousterhout says it's probably more fun to work somewhere with a nice code base."},
        {"type":"subtitle","info":"The Ledger of Harms"},
        {"type":"text","info":"Why is understanding the difference between Tactical and Strategic Programming as a computing professional so important? Because the same ideas you use to following strategic programming are the same you will use when making ethical decisions."},
        {"type":"text","info":"- “I think we have created tools that are ripping apart the social fabric of how society works.” - Chamath Palihapitiya (early executive at Facebook)"},
        {"type":"text","info":"- “The technologies we were most excited about 10 years ago are now implicated in just about every catastrophe of the day.” - Farhad Manjoo (technology journalist)"},
        {"type":"text","info":"The reality is that technology companies do inflict significant negative externalities upon society."},
        {"type":"text","info":"- Most of them are still a net positive, e.g. I personally use and enjoy Facebook."},
        {"type":"text","info":"My personal sense is that these are largely unintended consequences by well intentioned people."},
        {"type":"text","info":"- Yes, there are some bad actors, but I don't think they are common."},
        {"type":"text","info":"- Workers and executives at these companies do care."},
        {"type":"text","info":"-> … but money does skew people's perspective in strange ways."},
        {"type":"text","info":"So why does this matter in Data Structures and in programming? For many of you, this semester was the first time you truly had to confront how the code you write impacts the operation of the computing machinery."},
        {"type":"text","info":"- You shouldn't just understand that saving intermediate steps in registers and stack memory is a performance improvement over dynamic memory. You should also understand that safety device chips in automobiles require efficient, secure, and fast processing , and that your understanding of these mechanisms can literally be the difference between life and death."},
        {"type":"text","info":"- You shouldn't just understand that hashing provides faster insertion and look-up time. You should also understand that financial and medical environments using hashing for fast decision making and cryptography, so that your understanding of these mechanisms can improve decision times for stock broking and time critical decisions in emergency rooms."},
        {"type":"text","info":"Lecture 21 Introduction Question 3: Describe Tactical and Strategic Programming. Why should a computer scientist or a computer engineer employ Strategic Programming instead of Tactical Programming"},
        {"type":"subtitle","info":"Reading 21.3 - Modularity in Software Engineering"},
        {"type":"text","info":"So far in Fundamentals of Computing and Data Structures, we have promoted modularity as the use of functions to divide computing into small, re-usable tasks. However, as you grow as a computer scientist or computer engineer, you will need to perform advanced modularity"},
        {"type":"text","info":"In the Programming Paradigms course, you will apply these concepts to"},
        {"type":"text","info":"- Quickly learn a new language that supports imperative, functional, object-oriented, and logic paradigms."},
        {"type":"text","info":"- Evaluate the right combination of programming languages to solve a given problem. Provide a convincing argument."},
        {"type":"text","info":"Studying programming paradigms will help you be better at your job, make more money, and be a happier, more fulfilled and more informed citizen, because you'll learn to: choose the most appropriate language for a given task. You will be able to quickly learn a new language that supports imperative, functional, object-oriented, and logic paradigms."},
        {"type":"text","info":"- Imperative programming is a programming paradigm that uses statements that change a program's state."},
        {"type":"text","info":"- Procedural programming is a type of imperative programming in which the program is built from one or more procedures"},
        {"type":"text","info":"-> C is a procedural programming language"},
        {"type":"text","info":"- Object-oriented is a programming paradigm based on the concept of \"objects\", which can contain data and code: data in the form of fields (often known as attributes or properties), and code, in the form of procedures"},
        {"type":"text","info":"-> C++, Java, and Python are object-oriented languages with procedural aspects"},
        {"type":"text","info":"To understand which programming paradigm you would choose, you need to understand modularity at a deeper level."},
        {"type":"subtitle","info":"Hiding Complexity through Modularity and Abstraction"},
        {"type":"text","info":"Modularity is the idea of building components that can be re-used; and abstraction is the idea that after constructing a module (be it software or circuits or gears), most of the details of the module construction can be ignored and a simpler description used for module interaction (the module computes the square root, or doubles the voltage, or changes the direction of motion)."},
        {"type":"text","info":"Given basic modules, one can move up a level of abstraction and construct a new module by putting together several previously-built modules, thinking only of their abstract descriptions, and not their implementations. And, of course, this process can be repeated over many stages. This process gives one the ability to construct systems with complexity far beyond what would be possible if it were necessary to understand each component in detail."},
        {"type":"text","info":"In an ideal world, system would be broken down into modules, where every module would be totally independent."},
        {"type":"text","info":"- Here, “module” is an informal term referring to a struct, class, a package, or other unit of code."},
        {"type":"text","info":"- Not possible for modules to be entirely independent, because code from each module has to call other modules."},
        {"type":"text","info":"-> e.g. need to know signature of methods to call them."},
        {"type":"text","info":"In modular design, our goal is to minimize dependencies between modules."},
        {"type":"subtitle","info":"Graphs as an Example of Modular Design"},
        {"type":"text","info":"Our study of graphs is an good example of modular design. During that lecture series, we:"},
        {"type":"text","info":"- Built the graph in pieces, selecting an adjacency list, and then designed and tested Edge and Vector structs"},
        {"type":"text","info":"- Then we implemented BFS and DFS traversals."},
        {"type":"text","info":"-> We used C++ libraries of data structures we had already learned, such as vectors, stacks, queues, priority queues, and hash tables,"},
        {"type":"text","info":"- Then we studied Dijsktra and Prim's Algoritm"},
        {"type":"text","info":"-> Built upon the \"Pruning the Search Tree\" approach we learned during Complete search"},
        {"type":"text","info":"At each stage, once we completed the design at a lower level of abstraction, we were able to move higher and build upon that work."},
        {"type":"subtitle","info":"Interface vs. Implementation"},
        {"type":"text","info":"A common phrase you will hear in your career is: the more complicated the Data Structure, the simpler the algorithm. Ousterhout said “The best modules are those whose interfaces are much simpler than their implementation.” You have experienced this in our course! It was much simpler to just use the push_back() method in a vector than design the underlying code we covered in class."},
        {"type":"text","info":"- A simple interface minimizes the complexity the module can cause elsewhere. If you only have a getNext() method, that's all someone can do."},
        {"type":"text","info":"- If a module's interface is simple, we can change an implementation of that module without affecting the interface."},
        {"type":"subtitle","info":"Modules Should Be Deep"},
        {"type":"text","info":"The best modules are those that provide powerful functionality yet have simple interfaces. These are known as deep modules."},
        {"type":"text","info":"For example, the Graph we covered in class is a deep module."},
        {"type":"text","info":"- Simple interface:"},
        {"type":"text","info":"-> insert, search, delete."},
        {"type":"text","info":"-> Nothing informal that user needs to know (e.g. user doesn't have to specify or know the adjacency list or which operations)"},
        {"type":"text","info":"- Powerful functionality:"},
        {"type":"text","info":"-> Operations are efficient."},
        {"type":"text","info":"-> Graph ordering is maintained using sophisticated, subtle rules."},
        {"type":"subtitle","info":"Generic Classes are Deeper"},
        {"type":"text","info":"- Should new classes be general-purpose or special-purpose?"},
        {"type":"text","info":"-> Special-purpose: just do exactly what's needed today"},
        {"type":"text","info":"-> General-purpose: solve a range of problems that may in the future"},
        {"type":"text","info":"- My advice: make classes somewhat generic:"},
        {"type":"text","info":"-> Overall capabilities reflect current needs"},
        {"type":"text","info":"-> Design an interface that is generic enough to be used for other purposes besides today's needs"},
        {"type":"text","info":"-> Result: simpler and deeper interface than special-purpose approach"},
        {"type":"text","info":"- Questions to ask yourself:"},
        {"type":"text","info":"-> What is the simplest API that will cover all of my current needs?"},
        {"type":"text","info":"-> In how many situations will this method be used?"},
        {"type":"text","info":"-> Is this API convenient to use for my current needs?"},
        {"type":"subtitle","info":"Information Hiding"},
        {"type":"text","info":"- First proposed by David Parnas in the paper \"On the Criteria To Be Used in Decomposing Systems into Modules\""},
        {"type":"text","info":"-> More than 40 years old, but still one of the most important papers in all of computing systems."},
        {"type":"text","info":"- Each module (class) should encapsulate certain knowledge or design decisions:"},
        {"type":"text","info":"-> The knowledge/design decisions are only known to the one module"},
        {"type":"text","info":"-> The interface does not reflect this information (much)"},
        {"type":"text","info":"- Benefits:"},
        {"type":"text","info":"-> Simpler interface (deeper class)"},
        {"type":"text","info":"-> Can modify the implementation without impacting other classes"},
        {"type":"text","info":"-> This is the single most important idea in software design; will revisit it over and over throughout the rest of your career at Notre Dame"},
        {"type":"subtitle","info":"Information Leakage"},
        {"type":"text","info":"The opposite of information hiding is information leakage."},
        {"type":"text","info":"- Implementation details exposed, other classes depend on them"},
        {"type":"text","info":"- Anything in the interface is leaked"},
        {"type":"text","info":"- Back-door leakage: not visible in the interface"},
        {"type":"text","info":"Ousterhout:"},
        {"type":"text","info":"- “Information leakage is one of the most important red flags in software design.”"},
        {"type":"text","info":"- “One of the best skills you can learn as a software designer is a high level of sensitivity to information leakage.”"},
        {"type":"text","info":"Lecture 21 Introduction Question 4: Describe the importance of reducing complexity through modularity and abstraction"},
        {"type":"subtitle","info":"Reading 21.4 - Spiral Software Development"},
        {"type":"text","info":"In the Final Project for this course, you will conduct a 4-week long project in a group of 4. The research project for CSE 20312 will serve as a capstone for the course. It's a way for you to run wild with a topic and discover something interesting."},
        {"type":"text","info":"You'll choose a data structure, an algorithm pertaining to a specific data structure, or a theoretical result about data structures that will serve as the focus of your project. You'll spend the remainder of the semester doing your best to become an expert on the topic. To do that, you'll probably read several research papers, blog posts, book chapters, etc. to see what you find. "},
        {"type":"text","info":"One of the benefits of this assignment is to provide you with experience you can quantify on a resume to position you for better internships and jobs. I strongly recommend you work on a project in an area you want to work in when you graduate, such as Machine Learning, Cryptography, Design, Testing, ect. The more you are excited about the project, the more likely you will be to enjoy your work on this assignment."},
        {"type":"text","info":"Two other reasons for this assignment:"},
        {"type":"text","info":"- Get practice working on a team."},
        {"type":"text","info":"- Get more creativity into the project since it's so open ended."},
        {"type":"text","info":"- Get practice with strategic programming instead of purely tactical programming you have done up to now."},
        {"type":"subtitle","info":"Why Software Development Models?"},
        {"type":"text","info":"All software construction involves two task types: (Source, The Mythical Man-Month: Essays on Software Engineering)"},
        {"type":"text","info":"- Essential tasks, the fashioning of the complex conceptual structures that compose the abstract software entity"},
        {"type":"text","info":"-> In Data Structures, the essential tasks have been designing and implementing the various structures in C and C++"},
        {"type":"text","info":"- Accidental tasks, the representation of these abstract entities in programming languages and the mapping of these onto machine languages within space and speed constraints."},
        {"type":"text","info":"-> In Data Structures, the accidental tasks involve use of Production Quality Compilation to map to the x86_64 architecture on the Notre Dame server machines."},
        {"type":"text","info":"-> By implementing PQC, we limit how much \"accident\" translates into the accidental tasks."},
        {"type":"text","info":"In Reading 21.2, we mentioned the three symptoms and causes of complexity. To review, those were:"},
        {"type":"text","info":"- Change amplification"},
        {"type":"text","info":"- Cognitive load"},
        {"type":"text","info":"- Unknown unknowns"},
        {"type":"text","info":"Once you graduate and reach the \"real world\", you will encounter these issues far more frequently. In Fundamentals of Computing and Data Structures, we only have 15 weeks to teach you the expected material. As a result, most of the focus on code design is tactical and focuses on strengthening your understanding of change amplification and cognitive load."},
        {"type":"text","info":"But the final project will be a deep dive into using your understanding of Data Structures dealing with unknown unknowns."},
        {"type":"subtitle","info":"Incremental Development"},
        {"type":"text","info":"Incremental development - or progressive refinement - is one where every day you are measurably and visibility closer to the goal of shipping your product by building your product one step at a time."},
        {"type":"text","info":"Typically, you will have many sub-release phases or versions (say, version 0.1, 0.2, and so on) where each phase implements more function (i.e., covers more requirement or specification items)."},
        {"type":"text","info":"The idea of inchstones fits well with incremental development. The idea of iterating between the spec/design and implementation fits will with incremental development."},
        {"type":"text","info":"The major flaw with incremental development is the lack of feedback into the design process, meaning how you address unknown unknowns as they evolve into known unknowns."},
        {"type":"subtitle","info":"Waterfall Development"},
        {"type":"text","info":"The waterfall model is a breakdown of project activities into linear sequential phases, where each phase depends on the deliverables of the previous one and corresponds to a specialization of tasks. In software development, the progress flows in largely one direction (\"downwards\" like a waterfall) through the phases of conception, initiation, analysis, design, construction, testing, deployment and maintenance."},
        {"type":"text","info":"Waterfall tends to be among the less iterative and flexible approaches, and designers may not be aware of future difficulties when designing a new software product or feature."},
        {"type":"text","info":"It is better to revise the design than persist in a design that does not account for any newly discovered constraints, requirements, or problems."},
        {"type":"text","info":"Some organizations, such as the United States Department of Defense, now have a stated preference against waterfall-type methodologies, which encourages evolutionary acquisition and Iterative and Incremental Development."},
        {"type":"subtitle","info":"Spiral Software Development"},
        {"type":"text","info":"The Spiral model was presented in 1988 by Barry Boehm, and was specifically designed to help the Department of Defense manage increasingly large software projects, and was a direct response to the challenges they encountered with waterfall development models."},
        {"type":"text","info":"High-level view: continuously perform the following four tasks"},
        {"type":"text","info":"- Identify Objectives - Consider the win conditions of all success-critical stakeholders."},
        {"type":"text","info":"- Identify Risks and Alternatives - Identify and evaluate alternative approaches for satisfying the win conditions"},
        {"type":"text","info":"- Product Development - Perform the tasks based on the assessment of objectives, risks, and alternatives"},
        {"type":"text","info":"- Plan the next phase - Until project release, consider the results from testing and development, and develop an amended set of win conditions."},
        {"type":"text","info":"“Spiral” reflects increasing costs (y axis)"},
        {"type":"subtitle","info":"The six invariants of spiral model"},
        {"type":"text","info":"Sequentially defining the key artifacts for a project often increases the possibility of developing a system that meets stakeholder \"win conditions\" (objectives and constraints)."},
        {"type":"text","info":"This invariant excludes “hazardous spiral look-alike” processes that use a sequence of incremental waterfall passes in settings where the underlying assumptions of the waterfall model do not apply. Boehm lists these assumptions as follows:"},
        {"type":"text","info":"1. The requirements are known in advance of implementation."},
        {"type":"text","info":"2. The requirements have no unresolved, high-risk implications, such as risks due to cost, schedule, performance, safety, user interfaces, or organizational impacts"},
        {"type":"text","info":"3. The nature of the requirements will not change very much during development or evolution."},
        {"type":"text","info":"4. The requirements are compatible with all the key system stakeholders' expectations, including users, customer, developers, maintainers, and investors."},
        {"type":"text","info":"5. The right architecture for implementing the requirements is well understood."},
        {"type":"text","info":"6. There is enough calendar time to proceed sequentially."},
        {"type":"text","info":"In situations where these assumptions do apply, it is a project risk not to specify the requirements and proceed sequentially. The waterfall model thus becomes a risk-driven special case of the spiral model."},
        {"type":"subtitle","info":"Risk determines level of effort"},
        {"type":"text","info":"For any project activity (e.g., requirements analysis, design, prototyping, testing), the project team must decide how much effort is enough. In authentic spiral process cycles, these decisions are made by minimizing overall risk."},
        {"type":"text","info":"For example, investing additional time testing a software product often reduces the risk due to the marketplace rejecting a shoddy product. However, additional testing time might increase the risk due to a competitor's early market entry. From a spiral model perspective, testing should be performed until the total risk is minimized, and no further."},
        {"type":"text","info":"\"Hazardous spiral look-alikes\" that violate this invariant include evolutionary processes that ignore risk due to scalability issues, and incremental processes that invest heavily in a technical architecture that must be redesigned or replaced to accommodate future increments of the product."},
        {"type":"subtitle","info":"Risk determines Programming Complexity"},
        {"type":"text","info":"For any project artifact (e.g., requirements specification, design document, test plan), the project team must decide how much detail is enough. In authentic spiral process cycles, these decisions are made by minimizing overall risk."},
        {"type":"text","info":"Considering requirements specification as an example, the project should precisely specify those features where risk is reduced through precise specification (e.g., interfaces between hardware and software, interfaces between prime and sub-contractors). Conversely, the project should not precisely specify those features where precise specification increases the risk (e.g., graphical screen layouts, the behavior of off-the-shelf components)."},
        {"type":"text","info":"Lecture 21 Introduction Question 5: Describe the Spiral Software Development Model, as well as the four continuously performed tasks"}
        ]},
    {"unique_id":"6-2","content":[
        {"type":"subtitle","info":"Reading 22.1 - B-Tree Motivation"},
        {"type":"text","info":"Reading Note: This section is a \"skim\" section, which is used to motivate and explain the importance of the B-Tree data structure we will cover in depth in the subsequent sections. No material from this section will be on the Final Exam, but it is useful in helping you understand why we are studying this specific B-Tree Data Structure."},
        {"type":"subtitle","info":"Databases and Disk Structure"},
        {"type":"text","info":"In the Database Systems Concepts course (commonly taught by Prof. Tim Weninger) or the Advanced Database Projects (Links to an external site.) (commonly taught by Prof. Ramzi Bualuan), you will learn the fundamentals of using and implementing relational database management systems (DBMS). You will also will study data representation, indexing, query optimization and processing, transaction processing, and large scale “big-data” processing systems."},
        {"type":"text","info":"With the advent and growth of cloud computing and version control systems like GitHub, understanding how to structure data within a Database is increasingly important for Computer Scientists and Computer Engineers."},
        {"type":"text","info":"- You have been introduced to this concept through the use of GitHub in this course as well as Systems Programming. Me and Professor Peter Bui use different techniques, but we both ensure you understand that pushing objects and executables to Git consumes significant memory and should be avoided."},
        {"type":"text","info":"Optional Reading: From IBM, \"What is a Cloud Database? (Links to an external site.)\""},
        {"type":"text","info":"Optional Reading: From Git, \"What is Git? (Links to an external site.)\", where they discuss how Git is a relational database."},
        {"type":"text","info":"When students try to learn B-Trees (and B+ Trees in the Database Concepts course), they often simply try to understand the balancing mechanisms of the B-Tree. But that doesn't give students a robust understanding of why they work the way that they do. In previous lectures, I've asked you to draw both the logical layout as well as the physical layout so you understand both the idea of the Data Structure, as well as how the Operating System contributes  to how the data is structured. (I assessed this understanding with the Priority Queue question on Exam 1)."},
        {"type":"text","info":"Not only did I teach the material in that manner to set you up for success in your future OS course, but also to set you up for success in understanding B-Trees, as well as Red-Black Trees in Lecture 23. Please be sure to ask questions if you were unsure about those concepts, and we will be happy to help strengthen your understanding."},
        {"type":"text","info":"So what is a Disk Structure?"},
        {"type":"text","info":"A memory disk consists of tracks and sectors. Think of the tracks as circles, and the sectors like a slice of pie"},
        {"type":"text","info":"- Tracks are logical circles. Each \"circle\" goes from the outside to the inside represents a track from 0 to n-1."},
        {"type":"text","info":"- Sectors are logical slices. Each \"slice\" going counter clockwise represents a sector from 0 to m-1."},
        {"type":"text","info":"- Each intersection of a track and a sector is known as a block"},
        {"type":"text","info":"-> Therefore, there are n*m blocks of memory per disc."},
        {"type":"text","info":"-> Any address on the disk can be reached if you know the track number and the sector number."},
        {"type":"text","info":"For this example, we will assume that a block is 512 bytes. (This number changes based on the manufacturer of the disk.) Whenever we read or write to a disc, we always write in terms of blocks"},
        {"type":"text","info":"- We write the entire 512 bytes per write"},
        {"type":"text","info":"- We read the entire 512 bytes per read"},
        {"type":"text","info":"In that block, each byte has its own address, which we call the offset."},
        {"type":"text","info":"- This is known as byte addressing, which you will cover in detail in the Computer Architecture courseLinks to an external site.."},
        {"type":"text","info":"Another aspect of disk reading: The disk is mounted on a spindle. By spinning, the sector will change. The header will move to a specified track, which will take us to the exact block we need."},
        {"type":"text","info":"The blocks of memory are brought into the Data Heap, and only then can it be accessed."},
        {"type":"text","info":"- This is why dynamic memory through the Data Heap can store so much more memory than the static memory. The static memory stores precisely what is known at compile time, whereas Dynamic Memory can swap blocks based on which elements of the data structure we can use at any given moment."},
        {"type":"text","info":"We have learned that the purpose of Data Structures is to learn how store data in memory in a way that can be efficiently used by the program."},
        {"type":"text","info":"But now, we can also understand that Operating Systems use data structures to effectively find memory in the disk! A Database Management System (DBMS) is a software system used to manage and manipulate data in a database."},
        {"type":"subtitle","info":"Brief DBMS Overview - How Databases are Stored on Disks"},
        {"type":"text","info":"Let's say we have a database with 100 entries. Each entry in the database contains"},
        {"type":"text","info":"- ID: Unsigned integer - 4 bytes"},
        {"type":"text","info":"- Name:  std::string - Up to 50 characters - 8 bytes for base pointer plus 50 bytes, which is 58 bytes"},
        {"type":"text","info":"- Department: std::string - Up to 12 characters - 8 bytes for base pointer plus 12 bytes, which is 20 bytes"},
        {"type":"text","info":"- Section: std::string - Up to 8 characters - 8 bytes for base pointer plus 10 bytes, which is 18 bytes"},
        {"type":"text","info":"- Additional: std::string  - Up to 50 characters - 8 bytes for base pointer plus 50 bytes, which is 58 bytes"},
        {"type":"text","info":"In total, each Object in the Database takes 156 bytes. Therefore, 100 entries requires 15,600 bytes."},
        {"type":"text","info":"- We can store 512 / 156 = 3.28 records per block."},
        {"type":"text","info":"We can store 512 / 156 = 3.28 records per block."},
        {"type":"text","info":"- Put only 3 records per block, leaving the remaining memory empty."},
        {"type":"text","info":"-> We would require 52 blocks"},
        {"type":"text","info":"-> Consumes more memory, but easier to insert, find and delete data"},
        {"type":"text","info":"- Put all the records consecutively in memory, "},
        {"type":"text","info":"-> We would require 31 blocks"},
        {"type":"text","info":"-> Harder to insert, lookup and delete from the memory"},
        {"type":"text","info":"- The tradeoffs of these approaches are studied in detail in the Operating Systems course."},
        {"type":"text","info":"Optional Reading: Operating Systems preview - Paging vs. Segmentation"},
        {"type":"text","info":"In order to find whether a specific unique ID in a database, we might have to iterate through the entire database array, which would potentially go through several sectors and tracks."},
        {"type":"text","info":"If we use a Hash Table, the memory overhead would be significant in order to prevent collisions, although the lookup time between the key (the ID) and the value (the address of the block on the disk) would be fast."},
        {"type":"text","info":"Binary Search Trees are a good compromise. However, since we are sorting by the ID, we run into a serious possibility that - in order to traverse the Binary Search Tree - we will jump around several blocks, reducing the benefit of the Binary Search Tree."},
        {"type":"text","info":"Ideation: We know the number of records that can be stored per block! So what if we designed a Data Structure that gave us the benefit of Binary Search Trees where each node contains the same number of records that can be stored per block?"},
        {"type":"text","info":"That is the main idea behind the B-Tree."},
        {"type":"text","info":"Lecture 22 Introduction Question 1: How are databases stored on a disk, and how does this impact our ability to search and find data in long-term memory?"},
        {"type":"subtitle","info":"Reading 22.2 - Introduction to Tree Balancing"},
        {"type":"subtitle","info":"The Issue with Search Trees"},
        {"type":"text","info":"To this point in the semester, with respect to trees we have learned:"},
        {"type":"text","info":"- How to program a Binary Search Tree in C,"},
        {"type":"text","info":"- Perform pre-order, in-order, post-order, and level-order traversals"},
        {"type":"text","info":"- Studied LeetCode algorithms for Binary Search Trees to promote advanced computational thinking"},
        {"type":"text","info":"- In C++, we learned that the std::set (Links to an external site.) library is a specific type of Binary Search Tree."},
        {"type":"text","info":"However, we side-stepped a specific issue in Binary Search Trees back in Lecture 9. But now that you understand concepts like Big-O notation, amortized analysis and pruning the search tree, we can now address this issue in detail."},
        {"type":"text","info":"Binary Search Tree balance well when we receive a random order. However, as we learned in Amortized Analysis, as well as our considering of Hash Tables, we won't always be able to insert into a BST in random order. What if our data comes in real-time? Then, we will be forced to insert in the order that data comes to us."},
        {"type":"text","info":"Consider the scenario where we enter the elements 15, 25, 30, 40, and 50 into a Binary Search Tree. The tree as we have defined it to this point looks like this:"},
        {"type":"text","info":"We do not get any of the benefits of the Binary Search Tree! It is actually a glorified Singly Linked List. Plus, we have a stray node pointer in each node, which means we get:"},
        {"type":"text","info":"- The worst-case memory overhead of a Doubly Linked List"},
        {"type":"text","info":"- But we can't search backwards, which incurs all the disadvantages of a Singly Linked List"},
        {"type":"text","info":"- And we don't get any of the searching benefits from the Binary Search Tree"},
        {"type":"text","info":"The difference in runtime between a worst-case tree and best-case tree is very dramatic."},
        {"type":"text","info":"Worst case: O(N)"},
        {"type":"text","info":"Best-case: O(lg2N)"},
        {"type":"subtitle","info":"BST Performance"},
        {"type":"text","info":"Some terminology for BST performance:"},
        {"type":"text","info":"- depth: the number of links between a node and the root."},
        {"type":"text","info":"- height: the lowest depth of a tree."},
        {"type":"text","info":"- average depth: average of the total depths in the tree."},
        {"type":"text","info":"You calculate this by taking: where di is depth and ni is number of nodes at that depth."},
        {"type":"text","info":"The height of the tree determines the worst-case runtime, because in the worst case the node we are looking for is at the bottom of the tree."},
        {"type":"text","info":"The average depth determines the average-case runtime."},
        {"type":"subtitle","info":"An Initial Brute Force Approach - Multiple Data Elements Per Node"},
        {"type":"text","info":"Our ultimate objective is to reduce the amount of time it takes to find a specific element. Now that we understand that databases can be search more efficiently if we store multiple elements per node, let us strategically design a data structure that accomplishes this task!"},
        {"type":"text","info":"Consider the scenario in the video below. Here, we have a tree with two values per node. In the video, the values of 10, 15, 4, 21, 8, and 18 are inserted. We encounter an issue when running into the value 12:"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=9247ebe8-5ac1-4783-8cce-ae4c01234a3a&start=0.869149"},
        {"type":"subtitle","info":"A More Refined Approach to Multi-Value Nodes"},
        {"type":"text","info":"One potential solution would be if we had a node pointer for every possible child path. If we have two values in the nodes, say n1 and n2, then there would be three ranges where a child node could be placed."},
        {"type":"text","info":"- child < n1"},
        {"type":"text","info":"- n1 < child < n2"},
        {"type":"text","info":"- n2 < child"},
        {"type":"text","info":"Next, let's consider a scenario where the node can hold three values, n1, n2, and n3. There would be four ranges where a child node could be placed."},
        {"type":"text","info":"- child < n1"},
        {"type":"text","info":"- n1 < child < n2"},
        {"type":"text","info":"- n2 < child < n3"},
        {"type":"text","info":"- n3 < child"},
        {"type":"text","info":"This pattern will continue for any value of n greater than or equal to 2, there will be n+1 possible ranges for children. So any node with n values should contain n+1 node pointers to reach those locations. Let us revisit the scenario in Video 2, except the nodes containing 2 values have 3 node pointers. Now we can insert 12 into the tree as shown below."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=8ff21ba4-27aa-4c00-bb3c-ae4c0129c4e8&start=0.640373"},
        {"type":"text","info":"Growing the Tree Up instead of Down"},
        {"type":"text","info":"You may have noticed that, in the video above, we encounter another issue, which is that we only divide our original problem in half if we insert the values in a sorted order originally. "},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=c65c9c98-6643-4cbb-9deb-ae4c012b1791&start=1.326088"},
        {"type":"text","info":"The solution is to divide and split the tree up when we encounter a cell overflow. The splitting and catenation processes are initiated at the leaves only and propagate toward the root."},
        {"type":"text","info":"n the video below, I will show this process. The first example is when we insert 4 after inserting 10 and 15. Since 4 is the third value inserted, it would cause an overflow. What you will see is that we will split the 3 values, with 10 being the middle value. Each value will go into their own node, with 4 being the first child of 10, and 15 being the second child of 10."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=2c81d87f-c2e2-41e8-b5b0-ae4c012de590&start=1.107583"},
        {"type":"text","info":"Lecture 22 Introduction Question 2: What is the main drawback of a Binary Search Tree as we have studied to this point?"},
        {"type":"text","info":"Lecture 22 Introduction Question 3: How do \"multi-value\" nodes address this issue, and what is the flaw with the initial attempt we presented at a multi-value node?"},
        {"type":"text","info":"Lecture 22 Introduction Question 4: How does \"splitting and catenating\" from the leaf up to the root address the major issue brought up in Question 2?"},
        {"type":"subtitle","info":"Reading 22.3 - Formally Defining a B-Tree"},
        {"type":"text","info":"In this section, we will formally define the idea of \"multi-value\" nodes as a B Tree."},
        {"type":"text","info":"We will define the number of child pointer nodes as the order of the B Tree."},
        {"type":"text","info":"A B Tree of order m is a tree which satisfies the following properties:"},
        {"type":"text","info":"- Every node has m child pointers"},
        {"type":"text","info":"- Every node has at buckets available for m-1 data elements"},
        {"type":"text","info":"- Every non-leaf node (except root) has at least ⌈m/2⌉ child nodes."},
        {"type":"text","info":"- The root has at least two children if it is not a leaf node."},
        {"type":"text","info":"- All leaves appear in the same level"},
        {"type":"text","info":"Consider a B-Tree of order 3. This means:"},
        {"type":"text","info":"- Every node has 3 child pointers"},
        {"type":"text","info":"- Every node has at buckets available for 2 values data elements."},
        {"type":"text","info":"- Every non-lead node, except the root, has at least  3+1/2 = 2 child nodes."},
        {"type":"text","info":"- The root has at least two children if it is not a leaf node."},
        {"type":"subtitle","info":"Example for B-Tree Insertion for a Degree of 3"},
        {"type":"text","info":"In this video, I present an example of insertion for a B-Tree of degree of 3 with the following insertions: 10, 7, 11, 6, 5, 13, 12, 15"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=e6da0a47-ff9c-4b81-98af-ae4e016c8ba1&start=0.83693"},
        {"type":"subtitle","info":"Example for B-Tree Insertion for a Degree of 4"},
        {"type":"text","info":"The process for inserting and splitting the nodes for an even node and odd node are identical. The difference, and cause of common confusion among students, is where we split the node when we overflow. When the degree is odd, the logic seems simpler: there will be the same number of elements to the left and to the right of the middle element:"},
        {"type":"text","info":"- If we split 7, 10, 11"},
        {"type":"text","info":"-> 10 will be in the middle"},
        {"type":"text","info":"-> 7 will be to the left"},
        {"type":"text","info":"-> 11 will be to the right."},
        {"type":"text","info":"But when we have a degree of 4, the splitting is slightly more complicated. Let's say we have 6, 7, 10, and 11. Where do we split?"},
        {"type":"text","info":"- We could have 7 split up, with 6 to the left in one node, and 10, 11 to the right in another node."},
        {"type":"text","info":"- We could have 10 split up, with 6,7 to the left in one node, and 11 to the right in another node."},
        {"type":"text","info":"The two possible choices are shown below:"},
        {"type":"text","info":"So which do we choose? The solution lies in the idea of an algorithmic approach. The code for the B-Tree splitting must work the same for both even and odd length nodes because we will not know the length until the programmer initializes the B-Tree."},
        {"type":"text","info":"Let's consider the case where the length is odd, and the location to split is obvious:"},
        {"type":"text","info":"- We subtract one from the degree, which is the number of elements in the node, and divide by 2."},
        {"type":"text","info":"-> So (3-1)/2 = 1, so the data element at index 1 is split."},
        {"type":"text","info":"-> Which is why we split 7 up when we split 6, 7, 10"},
        {"type":"text","info":"Performing the same algorithm for an even numbered element, we get the following:"},
        {"type":"text","info":"- We subtract one from the degree, which is the number of elements in the node, and divide by 2."},
        {"type":"text","info":"-> So (4-1)/2 = 1, so the data element at index 1 is split."},
        {"type":"text","info":"-> Which is why we will split 7 up when we split 6, 7, 10, 11"},
        {"type":"text","info":"So the diagram on the left is the approach we will choose."},
        {"type":"text","info":"Design -> Compute -> Then Code"},
        {"type":"text","info":"In this image, I drew out all the possible scenarios for splitting the nodes for orders 3, 4, 5 and 6 to visualize the pattern I would need to program. You can see the benefit of splitting at order / 2 for odd orders and order / 2 - 1 for the even orders here:"},
        {"type":"text","info":"In this video, I present an example of insertion for a B-Tree of degree of 3 with the following same insertions: 10, 7, 11, 6, 5, 13, 12, 15, 16, 17, 18."},
        {"type":"text","info":"- Note: The question \"why do split even sized nodes they way we do?\" is the single most commonly asked question about B-Trees, and I have budgeted time in lecture anticipating that this question will be asked. Likely multiple times."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=7da116db-6483-47f7-bd64-ae4e016f958e&start=0.825646"},
        {"type":"subtitle","info":"Why are B-Trees are often called 2-3 and 2-3-4 Trees?"},
        {"type":"text","info":"Many B-Trees are implements with order = 3 or order = 4 as we've shown in the last two example problems."},
        {"type":"text","info":"B-trees of order m = 4  are also called 2-3-4 trees (or 2-4 trees)."},
        {"type":"text","info":"- “2-3-4” refers to the number of children that a node can have, e.g. a 2-3-4 tree node may have 2, 3, or 4 children."},
        {"type":"text","info":"B-trees of order m = 3 are also called 2-3 trees."},
        {"type":"text","info":"We will note here that the other popular form of B-Trees have higher orders closer to a thousand!"},
        {"type":"text","info":"- Used in practice for databases and filesystems (i.e. systems with very large records)."},
        {"type":"text","info":"- You can learn more about this in the Database Systems Concepts (Links to an external site.) elective course"},
        {"type":"subtitle","info":"Optional: Interesting Historical Note"},
        {"type":"text","info":"There is no formal meaning for the \"B\" in B-Trees. Over the years, many suggestions have been made, including \"Bayer\", \"Boeing\", \"Balanced\", \"Broad\", and \"Bushy.\""},
        {"type":"text","info":"- Based on our study, we could even propose \"Block\" as the meaning of B-Tree since they are design to utilize Disk Blocks."},
        {"type":"text","info":"- Rudolf Bayer once said \"the more you think about what the B in B-trees means, the better you understand B-trees.\""},
        {"type":"text","info":"- He co-invented B-Trees with Edward McCreight, and they wrote in their paper “for reasons clear to American English speakers, the name BM Tree is a non-starter”"},
        {"type":"text","info":"Lecture 22 Introduction Question 5: What is the process for splitting and rising an element into a B-Tree, and what is the design choice we make with even degree node splitting?"},
        {"type":"subtitle","info":"Reading 22.4 - Designing the B-Tree in C++"},
        {"type":"text","info":"Reading Note: This section is a \"skim\" section, which is used to show the design process for the B-Tree in C++. No material from this section will be on the Final Exam, but it is designed to reinforce your understanding of both the material in Reading 22.1-22.3, as well as the Software Engineering principles we covered in Lecture 21."},
        {"type":"text","info":"In this section, I will take you through the process of designing and testing a B-Tree in C++. Throughout this reading, I want you to take away some important approaches to design concepts."},
        {"type":"text","info":"- Notice how I build the B-Tree in pieces. I do not attempt to program the entire Data Structure all at once."},
        {"type":"text","info":"-> Just like modularity in function calls, by breaking the design process into parts, it becomes easier for you to find a logical error later in the design process."},
        {"type":"text","info":"-> This lesson is valuable, even if you never perform work in Databases or use B-Trees, because this approach to programming will save you hours and hours of time troubleshooting coding errors."},
        {"type":"text","info":"-> Notice my approach using Strategic Programming instead of Tactical Programming."},
        {"type":"text","info":"- Notice how I draw the diagrams before I code. (In this reading, I will do it in videos for you.) This approach helps me visualize the pointers when I design the data structure, so I know the exact processes for insertion and deletion prior to coding, which also saves me hours of programming time."},
        {"type":"subtitle","info":"Building the B-Tree Node"},
        {"type":"text","info":"In the code below, which may be found at btree_node1.h (Links to an external site.), I initialize the C++ struct with members order and curr_size. I also initialize vector of data with a size of order_in - 1, and a vector of btree_node pointers with order as the initialize size and all the pointers initialized to NULL."},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/raw/main/Lec22_Reading/include/btree_node1.h"},
        {"type":"text","info":"In its corresponding test suite btree_node1_test.cpp (Links to an external site.), I initialize a btree_node of order 3 and a btree_node of order 4, and test to make sure this node passes valgrind. I template one of them to an int and the other to a std::string, and I do so because I want to ensure my data structure will properly structure the data regardless of templated type."},
        {"type":"text","info":"- The single most common error you will find from code on the internet are data structures that use data and the index of the underlying nodes as the same thing, failing to separate data from structure. The website will claim that the data structure properly templates, but if you template the code to anything other than an integer, the structure literally falls apart inside the machine due to segmentation faults."},
        {"type":"text","info":"-> If you only test with integers, you will only know that your code passes with integers."},
        {"type":"text","info":"-> To paraphrase the TV show \"Game of Throne\" - Code on the internet is dark and full of errors"},
        {"type":"text","info":"- Notice in the B-Tree code above that I do not initialize thee values in data to a specific value. I made this choice so I can use any data type. That line of code initializes everything to the default constructor of the template."},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/raw/main/Lec22_Reading/src/btree_node1_test.cpp"},
        {"type":"subtitle","info":"Initial Insertion: Before Splitting"},
        {"type":"text","info":"Before we split, we need to know that we can insert and re-order valid values in the B-Tree node.  So I design a method insert where I perform an insertion for the case where we insert prior to splitting. In the video, I show the steps for how I will insert 10, 7, and 11 into a B-Tree Node with an order of 4"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=563ca5f0-fd8f-442f-ba55-ae4f00b5348d&start=0.335266"},
        {"type":"text","info":"In my initial coding iteration of the insert method, btree_node2.h (Links to an external site.), I will test for the case where curr_size is less than the order - 1. Just like I did in the video, I will copy the elements over until I find the correct location. In the test suite btree_node2_test.cpp (Links to an external site.), I will insert 10 and then 7 into the integer B-Tree Node, and then I will insert \"Zebra\", \"Aardvark\", and \"Horse\" into the std::string B-Tree Node."},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/raw/main/Lec22_Reading/include/btree_node2.h"},
        {"type":"text","info":"When I run the code and print the contents of the node after each insert, you will see the values are properly sorted:"},
        {"type":"text","info":"-bash-4.2$ make btree_node2_test"},
        {"type":"text","info":"g++ -m64 -std=c++11 -O2 -g -Wall -Wextra -Wconversion -Wshadow -Werror -c src/btree_node2_test.cpp -o objects/btree_node2_test.o"},
        {"type":"text","info":"g++ -m64 -std=c++11 -O2 -g -Wall -Wextra -Wconversion -Wshadow -Werror -o exe/btree_node2_test objects/btree_node2_test.o"},
        {"type":"text","info":"-bash-4.2$ exe/./btree_node2_test"},
        {"type":"text","info":"10"},
        {"type":"text","info":"7 10"},
        {"type":"text","info":"Zebra"},
        {"type":"text","info":"Aardvark Zebra"},
        {"type":"text","info":"Aardvark Horse Zebra"},
        {"type":"subtitle","info":"Initial Encapsulation of the B-Tree Itself"},
        {"type":"text","info":"Eventually, we will be splitting the node in the case where curr_size is equal to order - 1. In order to manage the B-Tree Nodes on the Data Heap, I will encapsulate all the B-Tree Nodes into a B-Tree C++ Struct. Just like the B-Tree Node, I will create an initial test suite to test the construction of the B-Tree Node."},
        {"type":"text","info":"- Creating the initial NULL node: btree1.h (Links to an external site.) and btree1_test.cpp"},
        {"type":"text","info":"In btree2.h (Links to an external site.), we limit the design to the case where the root node is NULL and we insert elements to fill the node. In this case, all we are doing is call the insert that is currently in btree_node2.h (Links to an external site.)."},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/raw/main/Lec22_Reading/include/btree2.h"},
        {"type":"text","info":"Combining Concepts - A Quick Valgrind Note before Split Nodes: When we run make btree2_test, we will create a B-Tree of order 3 and a B-Tree of order 4. We insert 2 elements into the order-3 B-Tree, and we insert 3 elements into the order-4 B-Tree. So we construct and destruct two B-Tree nodes. But if we run valgrind, we get 9 allocs and 9 frees. See if you can think of why this occurs:"},
        {"type":"text","info":"==14395== HEAP SUMMARY:"},
        {"type":"text","info":"==14395== in use at exit: 0 bytes in 0 blocks"},
        {"type":"text","info":"==14395== total heap usage: 9 allocs, 9 frees, 309 bytes allocated "},
        {"type":"text","info":"==14395=="},
        {"type":"text","info":"==14395== All heap blocks were freed -- no leaks are possible"},
        {"type":"text","info":"==14395=="},
        {"type":"text","info":"==14395== For lists of detected and suppressed errors, rerun with: -s"},
        {"type":"text","info":"==14395== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)"},
        {"type":"text","info":"The reason is because of the NULL node pointers when we construct the B-Tree nodes themselves. Remember, just because a pointer is NULL does not mean it is not taking up memory. We still need base pointer blocks to contain the eventual addresses we need to point to."},
        {"type":"text","info":"If they are not pointing to anything, the value inside the pointer is NULL, but it still takes memory to contain the value of NULL, as we see in the diagram below."},
        {"type":"text","info":"- This memory management concept reinforces the concepts of void pointers, casting pointers, and memory allocation on the Data Heap that we learned earlier this semester."},
        {"type":"subtitle","info":"Splitting Nodes from One to Two Levels"},
        {"type":"text","info":"Before implementing the recursive splitting, I worked on getting the split to work from one level to two levels. Once that task was tested, the recursive element builds upon that work."},
        {"type":"text","info":"The code can be found at btree3.h (Links to an external site.). To perform this task, we first need to split the nodes into a parent, and left, and a right node:"},
        {"type":"text","info":"First, the drawing:"},
        {"type":"text","info":"Next, the corresponding code:"},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/raw/main/Lec22_Reading/include/btree3.h"},
        {"type":"text","info":"We will encounter three cases. First, we will have the case that the value we are elevating will be in the left node, the value in the middle, or the in the right node. To determine where the middle should be, I drew out the cases for splitting for cases from Orders 3 through 6."},
        {"type":"text","info":"To set this up, I determined the current middle. We do not have a guarantee that the node will be full, so we divide the current size by two:"},
        {"type":"text","info":"SIZE_T curr_middle;"},
        {"type":"text","info":"// If the order is odd"},
        {"type":"text","info":"if( this->order %2 == 1 )"},
        {"type":"text","info":"     curr_middle    = (this->order) / 2;"},
        {"type":"text","info":"// Else, if the order is even"},
        {"type":"text","info":"else"},
        {"type":"text","info":"     curr_middle    = (this->order) / 2 - 1;"},
        {"type":"text","info":"Next, I keep track of iterators for the left and the right. Since we don't know where right will start, it is not defined yet."},
        {"type":"text","info":"SIZE_T left_iter = 0;"},
        {"type":"text","info":"SIZE_T right_iter;"},
        {"type":"text","info":"In each case, we will add elements to the left until we reach the element to raise. I am also copying the pointers, even though I know we have not yet reached the case where we are recursing, because I want to make sure I am staying in bounds for both the data and the structure."},
        {"type":"text","info":"// Iterate through the elements until we either reach curr_middle or the raised value"},
        {"type":"text","info":"while( left_iter < curr_middle && curr_node->data.at(left_iter) < insert_val ){"},
        {"type":"text","info":"     // Insert the current value into the node"},
        {"type":"text","info":"     left->node_insert( curr_node->data.at(left_iter) );"},
        {"type":"text","info":"     // The pointer to the left in curr node will be the pointer to the left in the new node"},
        {"type":"text","info":"     left->child_ptrs.at(left_iter) = curr_node->child_ptrs.at( left_iter );"},
        {"type":"text","info":"     ++left_iter;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"If we didn't reach curr_middle, the insert_val is on the left :"},
        {"type":"text","info":"if( left_iter < curr_middle ){ left->child_ptrs.at(left_iter) = curr_node->child_ptrs.at(iter)->child_ptrs.at(0); left->node_insert( raised_value ); left->child_ptrs.at(left_iter + 1) = curr_node->child_ptrs.at(iter)->child_ptrs.at(1); // Delete the child pointer since we no longer need that pointer - Essential to pass valgrind delete curr_node->child_ptrs.at(iter); // The we go until the element BEFORE the current middle while( left_iter < curr_middle - 1 ){ left->node_insert( curr_node->data.at(left_iter) ); left->child_ptrs.at(left_iter + 2) = curr_node->child_ptrs.at( left_iter + 1 ); ++left_iter; } // The curr middle needs to be the first element in the parent parent->node_insert( curr_node->data.at(left_iter) ); right_iter = curr_middle; while( right_iter < curr_node->curr_size ){ right->node_insert( curr_node->data.at(right_iter) ); right->child_ptrs.at(right_iter - curr_middle) = curr_node->child_ptrs.at( right_iter ); ++right_iter; } right->child_ptrs.at(right_iter - curr_middle) = curr_node->child_ptrs.at( right_iter );}"},
        {"type":"text","info":"Finally, we have the case where the split is on the right"},
        {"type":"text","info":"// Case where insert_val will be on the right else{ left->child_ptrs.at(left_iter) = curr_node->child_ptrs.at( left_iter ); // Insert the curr_middle in the parent parent->node_insert( curr_node->data.at(curr_middle) ); // Add all the values to the right right_iter = curr_middle + 1; while( right_iter < curr_node->curr_size && curr_node->data.at(right_iter) < raised_value ){ right->node_insert( curr_node->data.at(right_iter) ); right->child_ptrs.at(right_iter - curr_middle - 1) = curr_node->child_ptrs.at( right_iter ); ++right_iter; } right->child_ptrs.at(right_iter - curr_middle - 1) = curr_node->child_ptrs.at(iter)->child_ptrs.at(0); right->node_insert( raised_value ); right->child_ptrs.at(right_iter - curr_middle) = curr_node->child_ptrs.at(iter)->child_ptrs.at(1); if( right_iter < curr_node->curr_size ){ while( right_iter < curr_node->curr_size  ){ right->node_insert( curr_node->data.at(right_iter) ); right->child_ptrs.at(right_iter - curr_middle + 1) = curr_node->child_ptrs.at( right_iter + 1 ); ++right_iter; } } if( this->order % 2 == 1 ) right->child_ptrs.at(right_iter) = curr_node->child_ptrs.at( right_iter ); // Delete the child pointer since we no longer need that pointer - Essential to pass valgrind delete curr_node->child_ptrs.at(iter);"},
        {"type":"subtitle","info":"Testing this iteration"},
        {"type":"text","info":"The commands to run the tests are shown below. I am not testing past order + 1 insertions at this stage, since I have only accounted for one split in my design. Since there is no recursive case coded so far, there is a good chance it will segmentation fault (in fact, it often does if we go past the accounted for test cases. We will address this in the next section). But since we are working on one split only here, this is fine for now. You will see I've accounted for several cases to guarantee exactly one split. They all pass the tests as well as valgrind."},
        {"type":"text","info":"- btree3_int_test is a B-Tree templated to int with an order of 3"},
        {"type":"text","info":"- btree3_str_test is a B-Tree templated to string with an order of 4"},
        {"type":"text","info":"In the video below, I show the run of tests"},
        {"type":"text","info":"make btree3_int_test"},
        {"type":"text","info":"valgrind --leak-check=full exe/./btree3_int_test 11 10 7"},
        {"type":"text","info":"valgrind --leak-check=full exe/./btree3_int_test 7 10 11"},
        {"type":"text","info":"valgrind --leak-check=full exe/./btree3_int_test 11 10 7"},
        {"type":"text","info":"valgrind --leak-check=full exe/./btree3_int_test 10 7 11"},
        {"type":"text","info":"make btree3_str_test"},
        {"type":"text","info":"valgrind --leak-check=full exe/./btree3_str_test Aardvark Horse Manatee Zebra"},
        {"type":"text","info":"valgrind --leak-check=full exe/./btree3_str_test Horse Aardvark Manatee Zebra"},
        {"type":"text","info":"valgrind --leak-check=full exe/./btree3_str_test Horse Manatee Aardvark Zebra"},
        {"type":"text","info":"valgrind --leak-check=full exe/./btree3_str_test Zebra Manatee Horse Aardvark"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=c17f05a4-f48d-4caf-84f5-ae51012ed69d&start=0.224822"},
        {"type":"subtitle","info":"Recursively Splitting Up The B-Tree"},
        {"type":"text","info":"The final recursive design may be found in btree.h (Links to an external site.). We know from our study of B-Trees in the previous sections that, if the level did not split below, then it will not split at higher levels"},
        {"type":"text","info":"// Recursively call the insert node "},
        {"type":"text","info":"bool did_split = insert( curr_node->child_ptrs.at(iter), insert_val );"},
        {"type":"text","info":"// If the previous level did not split, then we do not need to check again"},
        {"type":"text","info":"if( !did_split ){"},
        {"type":"text","info":"return false;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"From there, we must account for two cases. First, that we split below and the current level is not full. Second, that we split below and the current level is full."},
        {"type":"text","info":"In my drawing for the first case, I copy the parent's one data element into the curr_node, and then have the pointers point to the left and the right."},
        {"type":"text","info":"- As I drew the elements, I realized that the old parent would not have a pointer pointing to the value. So I created a temporary pointer and then deleted that node once I updated the parent"},
        {"type":"text","info":"// Update the curr_node to point at parent"},
        {"type":"text","info":"// Create a reference node for deletion"},
        {"type":"text","info":"btree_node<T>* to_delete = curr_node;"},
        {"type":"text","info":"// Set the current node to the parent to recursively return"},
        {"type":"text","info":"curr_node = parent;"},
        {"type":"text","info":"// Delete the node we were pointing to"},
        {"type":"text","info":"delete to_delete;"},
        {"type":"text","info":"// We split again, so we must return true"},
        {"type":"text","info":"return true;"},
        {"type":"text","info":"To fully test the B-Tree, I performed  suite, which I will perform and demonstrate in class. The tests I ran are available at the following page"},
        {"type":"text","info":"Note: We will be going over several tests in detail in Lecture"}
        ]},
    {"unique_id":"6-3","content":[
        {"type":"subtitle","info":"Reading 23.1 - Conceptually Understanding Red-Black Trees"},
        {"type":"text","info":"In this lecture, we are going to study one of the most commonly used data structures: the Red-Black Tree. The Red-Black Tree is used as the underlying data structure for virtually all implementations of trees in programming languages"},
        {"type":"text","info":"- In C++, std::set (Links to an external site.), std::map (Links to an external site.), and std::multiset are implemented using Red-Black Trees"},
        {"type":"text","info":"- In Java, the TreeSet (Links to an external site.) and TreeMap (Links to an external site.) libraries are implemented using a Red-Black Tree"},
        {"type":"text","info":"- In Python, treelib (Links to an external site.) is an installable library using a Red-Black Tree"},
        {"type":"text","info":"So Red-Black Trees are common and important! However, if you've talked to any classmates or friends at other schools, you've likely heard horror stories about trying to learn Red-Black Trees (Links to an external site.)."},
        {"type":"text","info":"Even the Data Structure course at West Point starts out their lecture on Red-Black Trees (Links to an external site.) with the following statement:"},
        {"type":"text","info":"Everybody learns about balanced binary search trees in their introductory computer science classes, but even the stouthearted tremble at the thought of actually implementing such a beast."},
        {"type":"text","info":"Or consider this article published at Harvard: Left-Leaning Red-Black Trees Considered Harmful"},
        {"type":"text","info":"The consternation about the stress of Red-Black Trees is a bit ironic considering the are also called \"Relaxed Balance Trees\".  So how do we learn Red-Black Trees in a way that helps us be more relaxed and balanced? In my experience, students master the Red-Black topic through three iterations."},
        {"type":"text","info":"- First, an analogy of the invention of Red-Black Trees as a unique case of a Order-4 B-Tree."},
        {"type":"text","info":"-> In fact, Red-Black Trees are often referred to as 2-3-4 Color Trees"},
        {"type":"text","info":"- Second, by studying the rotations from an intuitive perspective and then applying the rules, instead of the other way around"},
        {"type":"text","info":"-> We will be talking about Red-Black Trees as an art, and then as a science"},
        {"type":"text","info":"- Third, by drawing the layout in memory, just like we did with Priority Queues, Stacks, Queues, and Deques."},
        {"type":"text","info":"-> The ideas behind coding and implementing Red-Black Trees become clearer"},
        {"type":"subtitle","info":"Real-World Motivation: Drum Memories"},
        {"type":"text","info":"In 1973, computing performance was driving innovation"},
        {"type":"text","info":"- Bottleneck - Drum Memory, which were 180kB of memory"},
        {"type":"text","info":"- To give you perspective: Need 10 of these Drum Memories to hold one Cell Phone photo in 2022"},
        {"type":"text","info":"Let's consider some of the Data Structures we have studied so far, and why they were not advantageous for Drum Memories:"},
        {"type":"text","info":"- Hash Tables - O(1) insert and find"},
        {"type":"text","info":"-> However, they used too much memory in the Hash to prevent collisions"},
        {"type":"text","info":"- AVL Trees and B-Trees"},
        {"type":"text","info":"-> Balancing Mechanisms were too complex"},
        {"type":"text","info":"So there was a need to find a compromise. It is helpful to think of Red-Black Trees as a compromise between the benefits and tradeoffs of various data structures we have studied so far."},
        {"type":"subtitle","info":"Brief Historical Note"},
        {"type":"text","info":"Why Red-Black Trees? From Robert Sedgewick, the inventor of Red-Black Trees:"},
        {"type":"text","info":"\"A lot of people ask why did we use the name red-black. Well, we invented this data structure, this way of looking at balanced trees, at Xerox PARC... But one of the things that was invented there was laser printing and we were very excited to have nearby color laser printer that could print things out in color and out of the colors the red looked the best.\""},
        {"type":"subtitle","info":"Step 1 - Red-Black Trees as a 2-3-4 Tree Variant"},
        {"type":"text","info":"(Unlike the Marvel TV show Loki and the Alligator Loki pictured above, we consider variants to be good!)"},
        {"type":"text","info":"Let's do a Thought Experiment: We will design a 2-3-4 B-Tree, except we will make the following variations in rules"},
        {"type":"text","info":"- Instead of putting the initial B-Tree value in the leftmost node (i.e. keys[0]),"},
        {"type":"text","info":"-> we put that value in the middle slot. Define as Black"},
        {"type":"text","info":"- This means that any value that would be smaller would go in the left slot"},
        {"type":"text","info":"-> Any value that is larger would go in the right slot."},
        {"type":"text","info":"-> Define those as red"},
        {"type":"text","info":"In the video below, I show an example of this analogy with the B-Tree and Red-Black Tree"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=19b76ecc-e2a4-4d47-ba28-ae5301266c55&start=0.975602"},
        {"type":"subtitle","info":"Step 2 - Intuitive Approach to Red-Black Trees"},
        {"type":"text","info":"Compared to B-Trees so the strict AVL trees we briefly discussed, let's relax the balancing requirement"},
        {"type":"text","info":"- Recall c from the Big-O notation requirement"},
        {"type":"text","info":"- What would happen if we said the worst-case would be 2*log(n)"},
        {"type":"text","info":"- Still qualifies as O( lg(n) ) search"},
        {"type":"text","info":"- But reduces the work of balancing"},
        {"type":"text","info":"Let's set some ground rules. To have 2 levels, we will separate the levels with colors, Red and Black"},
        {"type":"text","info":"- To maintain balance, we will have the same number of Black Nodes along each path"},
        {"type":"text","info":"-> This aligns well with our B-Tree analogy since we need one Black node per equivalent B-Tree cell"},
        {"type":"text","info":"- The root must be black"},
        {"type":"text","info":"-> Every element is inserted as a Red node"},
        {"type":"text","info":"- We cannot have consecutive red nodes"},
        {"type":"text","info":"- But we can have consecutive black nodes"},
        {"type":"text","info":"- The root node must be black"},
        {"type":"text","info":"In this video, I go over several examples to show what we would want to do when performing balance with these rules."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=55aa0eda-baf2-4786-a287-ae5301305551&start=0.189498"},
        {"type":"text","info":"Lecture 23 Introduction Question 1: Describe the idea of \"relaxed balanced trees\", and why are they so commonly used in modern programming language libraries?"},
        {"type":"text","info":"Lecture 23 Introduction Question 2: What is the metaphor between a 2-3-4 B-Tree that we studied in Lecture 22 and the Red-Black Tree we are studying in this lecture?"},
        {"type":"text","info":"Lecture 23 Introduction Question 3: What are some of the patterns for rotation you saw in the second video where we performed several insertions and rotations?"},
        {"type":"subtitle","info":"Reading 23.2 - Formally Defining Red-Black Trees"},
        {"type":"text","info":"Now that we've studied some intuitive approaches to relaxed balancing of Binary Search Trees, let's formally define rules for Red-Black Trees and put them into practice."},
        {"type":"text","info":"A Red-Black Tree is a binary search tree that uses locality of relationships recursively to provide a relaxed balanced tree"},
        {"type":"text","info":"- Every node is either red or black."},
        {"type":"text","info":"- The root and all NULL pointers are always black"},
        {"type":"text","info":"- If a node is red, then its children are black."},
        {"type":"text","info":"- All paths from a node to NULL pointers contain the same number of black nodes"},
        {"type":"subtitle","info":"Finding the “relaxed” balanced height"},
        {"type":"text","info":"At least half of all the nodes along any path in this tree are black:"},
        {"type":"text","info":"- bh(root) is at least h(root)/2."},
        {"type":"text","info":"- n≥2bh(root) -1"},
        {"type":"text","info":"- n+1≥2h(root)/2"},
        {"type":"text","info":"- lg(n+1)≥h(root)/2"},
        {"type":"text","info":"- 2*lg(n+1)≥h(root)"},
        {"type":"text","info":"Therefore, a Red-Black Tree with n nodes is guaranteed to have a height of no greater than 2*lg(n+1)"},
        {"type":"text","info":"Going back to Big-O notation."},
        {"type":"text","info":"For a function g(n), we define O(g(n)) as the asymptotic upper bound of the set of functions:"},
        {"type":"text","info":"O( lg(n) ) = {2*lg(n+1) : there exist positive constants c=3 and n0=1 such that 0 < 2*lg(n+1) < 3*lg(n) for all n > 1}"},
        {"type":"subtitle","info":"The Four Insertion Cases"},
        {"type":"text","info":"We now present the four cases for Red-Black Tree insertion. In the videos below, I show the examples comparing the cases with the insertion analogies we presented in the previous section."},
        {"type":"text","info":"Case 0: Root is red"},
        {"type":"text","info":"- Change the root node to black"},
        {"type":"text","info":"- Is the last check"},
        {"type":"text","info":"- Since it's the root, will not affect any of the other balancing mechanisms"},
        {"type":"text","info":"-> Increases the black nodes on each path by 1."},
        {"type":"text","info":"Case 1: Child is red. Parent is red. Uncle is red"},
        {"type":"text","info":"- Re-color Grandparent, Parent, and Uncle"},
        {"type":"text","info":"- No rotation needed, as the subtree now meets the Red-Black tree conditions"},
        {"type":"text","info":"In the video below, we will show two different instances of Case 1, both of which combine to Case 0 at the end. In both examples, the tree starts with 7, 10, 12, where 10 is black, and 7 and 12 are red. In the first example, we insert 9. In the second example, we insert 11. Both of these produce Case 1, which then recolors the root to red, necessitation Case 0."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=9f3fb079-2d06-446f-8f99-ae5301358f88&start=0.368138"},
        {"type":"text","info":"Case 2: Child is red. Parent is red. Uncle is black"},
        {"type":"text","info":"In this case, we need to perform a rotation. The child will become the new parent of the original parent and the child of the original grandparent."},
        {"type":"text","info":"Case 2 is not a terminal case."},
        {"type":"text","info":"In the video below, we have an initial tree with 10 and 15, and then we insert 12. The video only shows the completion of Case 2 to show that Case 2 is not a terminal case, and you can see how Case 3 is set up."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=d4824d03-bd42-4df9-9aff-ae5301389491&start=0.574628"},
        {"type":"text","info":"Case 3: Red node is a child of Parent, and red parent is child of grandparent in the same direction as the parent, and the Uncle is Black"},
        {"type":"text","info":"- Meaning if parent is greater than the grandparent (i.e. right child), then the child is greater than the parent (also right child)"},
        {"type":"text","info":"- If parent is less than the grandparent (i.e. left child), then the child is also less than the parent (also left child)"},
        {"type":"text","info":"Now we perform the rotation in the opposite direction."},
        {"type":"text","info":"In the video below, I show two examples where we just came from Case 2, and need to perform a case 3"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=dbe05edb-28c6-4bbb-95da-ae53013a5889&start=0.031499"},
        {"type":"text","info":"In the final video for this section, I will perform the exact same insertions from Reading 23.1, except I will describe the rules we covered here. Come to class with plenty of questions if you are still confused here."},
        {"type":"text","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=a2fbc3a5-33cb-4b91-8ba5-ae53013be70e&start=0.231944"},
        {"type":"text","info":"Lecture 23 Introduction Question 4: What are the four insertion rules for a Red-Black Tree"},
        {"type":"subtitle","info":"Reading 23.3 - Combining Concepts - The Red-Black Tree in Memory"},
        {"type":"text","info":"In Lecture 8, we went into detail about the layout of the Priority Queue, Stack, Heap, and Deque in the computing memory. In order to better understand how Red-Black Trees are designed, we will revisit memory layout by drawing the final Red-Black Tree."},
        {"type":"text","info":"You may review my implementations of a Red-Black Tree Node (RBTreeNode.h (Links to an external site.)) and the overall Red-Black Tree (RBTree.h (Links to an external site.)) online. For the purposes of this course, I will go over a couple of crucial concepts."},
        {"type":"subtitle","info":"Red-Black Tree Nodes Require a Parent Pointer"},
        {"type":"text","info":"In order to perform the rotations we discussed in the first two sections, we need to be able to \"look back\" at the parent so we can see the color of the sibling and uncle."},
        {"type":"text","info":"- Recall that we couldn't look back in a Singly Linked List"},
        {"type":"text","info":"- We addressed this issue with the prev_node pointer in a Doubly Linked List."},
        {"type":"text","info":"We will do the same thing we a parent pointer as shown below in the code segment from the RBTreeNode below:"},
        {"type":"text","info":"enum COLOR { RED, BLACK };"},
        {"type":"text","info":"template<class T>"},
        {"type":"text","info":"struct RBTNode {"},
        {"type":"text","info":"     T value; // Data itself"},
        {"type":"text","info":"     COLOR color; // Indicates if red or black"},
        {"type":"text","info":"     RBTNode<T> *left, *right, *parent; // Keeps track of the nodes for rotation"},
        {"type":"text","info":"     // Default constructor"},
        {"type":"text","info":"     RBTNode<T>() : value(), color(RED), left(NULL), right(NULL), parent(NULL) { }"},
        {"type":"text","info":"     // Overloaded Constructor"},
        {"type":"text","info":"     RBTNode<T>(const T& valueIn) : value(valueIn), color(RED), left(NULL), right(NULL), parent(NULL) { }"},
        {"type":"text","info":"Using our understanding of the this pointer to a node, as well as our understanding of pointer addresses we can now easily determine if the child is on the left or right of the parent:"},
        {"type":"text","info":"bool isOnLeft() const{"},
        {"type":"text","info":"     return this == parent->left; "},
        {"type":"text","info":"}"},
        {"type":"text","info":"// Returns true if this is the parent's right node"},
        {"type":"text","info":"bool isOnRight() const{"},
        {"type":"text","info":"     return this == parent->right;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"Note: In many of the links I provided in Reading 23.1 where people expressed frustration in designing and implementing a Red-Black Tree, their concept errors tend to occur right here. Many of the concepts we've studied, from void pointers, to memory management, to C structs, to C++ object keywords, have built to this concept. If you understand why isOnLeft and isOnRight work, you are well ahead of your peers."},
        {"type":"text","info":"Now that we can identify if the child is on the left or right, we can now determine the color of the Uncle as well."},
        {"type":"text","info":"// Get the Node's Uncle"},
        {"type":"text","info":"RBTNode<T>* uncle() const{"},
        {"type":"text","info":"     // If no parent or grandparent, then no uncle"},
        {"type":"text","info":"     if (parent == NULL or parent->parent == NULL)"},
        {"type":"text","info":"         return NULL;"},
        {"type":"text","info":"     // Return a pointer to the uncle"},
        {"type":"text","info":"     return (parent->isOnLeft()) ? parent->parent->right : parent->parent->left;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"To conclude, we will compare the addresses of the Red-Black Tree with the logical and physical layout. In the code I have provided at RBTreePrintAddr.cpp (Links to an external site.), we print the contents and addresses of the Level-Order Traversal of the Red-Black Tree."},
        {"type":"text","info":"Given the same example where I insert 2, 4, 6, 10, 9, 8, 12, and 11, the program prints the following outputs (Note: the 0/1 in the print out represents whether it is red (0) or black (1))"},
        {"type":"text","info":"rb_tree*: 0x7ffc9c6e1318"},
        {"type":"text","info":"root : 0xa46010 0xa460b0 "},
        {"type":"text","info":"Value Address  R/B Parent    Left     Right "},
        {"type":"text","info":"4     0xa460b0 1   0         0xa46030 0xa46140"},
        {"type":"text","info":"2     0xa46030 1   0xa460b0  (nil)    (nil)"},
        {"type":"text","info":"9     0xa46140 0   0xa460b0  0xa460e0 0xa461d0"},
        {"type":"text","info":"6     0xa460e0 1   0xa46140  (nil)    0xa46170"},
        {"type":"text","info":"11    0xa461d0 1   0xa46140  0xa46110 0xa461a0"},
        {"type":"text","info":"8     0xa46170 0   0xa460e0  (nil)    (nil)"},
        {"type":"text","info":"10    0xa46110 0   0xa461d0  (nil)    (nil)"},
        {"type":"text","info":"12    0xa461a0 0   0xa461d0  (nil)    (nil)"},
        {"type":"text","info":"We know from our previous studies that the RBTree struct contains a register at 0x7ffc9c6e1318 that contains the address of the root node pointer at 0xa46010. That root node pointer contains the address of the root node at 0xa460b0 containing the value 4."},
        {"type":"text","info":"The final drawing below combines all these concepts. On the Final Exam, you will have one problem where you will be given a set of inputs and will be expected to balance the Red-Black Tree. In the second problem, you will be given a set of addresses, and you will be expected to produce the layout in memory. By doing both problems, you will demonstrate advanced proficiency in both data and structure: "}
        ]},
    {"unique_id":"6-4","content":[
        {"type":"subtitle","info":"Reading 24.1 - Tries"},
        {"type":"text","info":"In this lecture, we are going to study two Data Structures that focus on memory reduction. To learn about these, we will need to study... Batman?"},
        {"type":"text","info":"Well, kind of... In 1959 Office of Naval Research needed to store large amounts of information regarding their storage of ordinances."},
        {"type":"text","info":"- Losing track of where we store bombs would be bad."},
        {"type":"text","info":"The Navy was storing ordinance data on a Datatron 205"},
        {"type":"text","info":"- Stored 32KB of memory total"},
        {"type":"text","info":"As you now know, searching algorithms with high speed, which used Hash functions, required significant memory overhead due to the empty buckets."},
        {"type":"text","info":"Their innovation was to use a “tree” property to store redundant information"},
        {"type":"text","info":"- Each character as a node in a decision tree"},
        {"type":"text","info":"- Sorts words and makes a subtree for each unique sub-word"},
        {"type":"text","info":"- The tree the derived has the following words: CAN, CANDY, COULD, COUNT, FAST, FASTER, FAT, FIT, FOUND, and FOX"},
        {"type":"text","info":"Important Historical Note: The \"Trie\" Data Structure gets its name from retrieval, as is formally pronounced as \"tree\" like the second syllabus in retrieval. However, as Binary Search Trees gained prominence, \"Tries\" became commonly pronounced \"try\" to differentiate them from normal trees."},
        {"type":"text","info":"Other names for a Trie:"},
        {"type":"text","info":"- Digital Search Tree"},
        {"type":"text","info":"- Directed Acyclic Word Graph"},
        {"type":"text","info":"- Suffix Tree"},
        {"type":"text","info":"Amusing Historical Note: Once the Navy upgraded their hardware, they sold their old Datatron 205 to Warner Brothers studios, who used it as a prop for TV shows. The actual computer on which the Trie data structure we will study today was first implemented is the \"Bat Computer\" from the 1960s TV show Batman."},
        {"type":"text","info":"(Batman using search Tries to search for Poison Ivy hiding in Gotham's trees.)"},
        {"type":"video","info":"https://youtu.be/IzaMs5iaX7w"},
        {"type":"subtitle","info":"Setting Up The Logical Representation of a Trie "},
        {"type":"text","info":"In the following video, I show the following problem:"},
        {"type":"text","info":"Given the following dictionary, draw the resulting Trie:"},
        {"type":"text","info":"{aab, aba, acb, acd, bcd, bdf, bfg, d, eaf, efa, efg, Aba, Abb, Abc }"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=4ff39bbf-5d69-41ff-80db-ae530162472b"},
        {"type":"text","info":"Lecture 24 Introduction Question 1: What is the main idea behind a Trie Data Structure?"},
        {"type":"subtitle","info":"Reading 24.2 - Implementing the Trie Data Structure in C++ Code"},
        {"type":"text","info":"Note: Reading 24.2 is a \"skim reading\" section. Nothing we will discuss in this section will be explicitly asked about on a Weekly Survey or Exam. However, one of the most common emerging interview questions is: Design a Trie from Scratch. So I will present my designed solution, as well as several test cases."},
        {"type":"subtitle","info":"Initialize the Trie Node"},
        {"type":"text","info":"The TrieNode, which may be found at TrieNode.h (Links to an external site.), will have its own char so we can print out the values in a traversal. In addition, it will have the following"},
        {"type":"text","info":"- VECTOR <TrieNode *> pointers"},
        {"type":"text","info":"- Have 128 null children"},
        {"type":"text","info":"-> 128 ASCII values"},
        {"type":"text","info":"#define VECTOR std::vector"},
        {"type":"text","info":"#define SIZE_T long unsigned int"},
        {"type":"text","info":"struct TrieNode{"},
        {"type":"text","info":"private:"},
        {"type":"text","info":"     char trie_letter;"},
        {"type":"text","info":"     VECTOR< TrieNode* > child_nodes;"},
        {"type":"text","info":"public:"},
        {"type":"text","info":"     // Default constructor"},
        {"type":"text","info":"     // Must set them to NULL, or you will get a stack overflow"},
        {"type":"text","info":"     TrieNode() : trie_letter(), child_nodes(128, NULL) {}"},
        {"type":"text","info":"     // Constructor with char input"},
        {"type":"text","info":"     TrieNode(const char& char_in) : trie_letter(char_in), child_nodes(128, NULL) {}"},
        {"type":"text","info":"Next, we need to define how to add a character to the Trie. We will first check to ensure the element is in the node (meaning that child is not NULL. Otherwise, we will create a new node, and then update that node's pointer to the new node:"},
        {"type":"text","info":"void addChild( const char& child_char ){"},
        {"type":"text","info":"     if( child_nodes.at( (SIZE_T)child_char ) != NULL )"},
        {"type":"text","info":"         return;"},
        {"type":"text","info":"     TrieNode* temp = new TrieNode(child_char);"},
        {"type":"text","info":"     child_nodes.at( (SIZE_T)child_char ) = temp;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"Next, we need methods to indicate the pointer at a specific char as well as a specific order"},
        {"type":"text","info":"TrieNode* getChildPtr( const char& child_char ){"},
        {"type":"text","info":"     return child_nodes.at( (SIZE_T)child_char );"},
        {"type":"text","info":"}"},
        {"type":"text","info":"TrieNode* getChildPtrOrder( unsigned int order ){"},
        {"type":"text","info":"     return child_nodes.at( order );"},
        {"type":"text","info":"}"},
        {"type":"text","info":"We also have the operators for >, >=, ==, <, and <= to compare the TrieNodes. To review, here is the C++ operator for <:"},
        {"type":"text","info":"bool operator<( const TrieNode& rhs ) const{"},
        {"type":"text","info":"     return trie_letter < rhs.trie_letter;"},
        {"type":"text","info":"}"},
        {"type":"subtitle","info":"Initialize the Trie Object"},
        {"type":"text","info":"The Trie object, which may be Trie.h, uses a recursive function to add the entire string to the Trie data structure. The input value keeps teach of the current index of the string, and we keep adding children as we progress through the string until the word is added."},
        {"type":"text","info":"void addString( TrieNode* theNode, const std::string& word, unsigned int value ){"},
        {"type":"text","info":"     // We haven't reach the end of the word"},
        {"type":"text","info":"     if( value < word.size() ){"},
        {"type":"text","info":"         // Add each character to the word"},
        {"type":"text","info":"         // addChild will not permit duplicates"},
        {"type":"text","info":"         theNode->addChild( word[value] );"},
        {"type":"text","info":"         // Get the TrieNode correlating to the char"},
        {"type":"text","info":"         TrieNode* nextLevel = theNode->getChildPtr( word[value] );"},
        {"type":"text","info":"         // Recursively call the next level"},
        {"type":"text","info":"         addString( nextLevel, word, value + 1);"},
        {"type":"text","info":"     }"},
        {"type":"text","info":"     // If we have reached the end of the word"},
        {"type":"text","info":"     else if( value == word.size() ){"},
        {"type":"text","info":"         // Add a star indicating this is a valid word"},
        {"type":"text","info":"         theNode->addChild( '*' );"},
        {"type":"text","info":"         return;"},
        {"type":"text","info":"     }"},
        {"type":"text","info":"}"},
        {"type":"text","info":"Additionally, we have a similar program to implement a contains method. We pass the current TrieNode pointer, and keep track of the current index. If the value is not found, we return false. If we get to the end (meaning we have exceeded the size of the string and we found all the previous values, we return true."},
        {"type":"text","info":"bool contains( TrieNode* theNode, const std::string& word, unsigned int value ) const {"},
        {"type":"text","info":"     // We haven't reach the end of the word"},
        {"type":"text","info":"     if( value < word.size() ){"},
        {"type":"text","info":"         if( theNode->getChildPtr( word.at(value) ) == NULL )"},
        {"type":"text","info":"             return false;"},
        {"type":"text","info":"         else"},
        {"type":"text","info":"             // Recursively call using the child pointer"},
        {"type":"text","info":"             return contains( theNode->getChildPtr( word.at(value) ), word, value+1 );"},
        {"type":"text","info":"     }"},
        {"type":"text","info":"     // If we have reached the end of the word"},
        {"type":"text","info":"     else{ // if( value == word.size() ){"},
        {"type":"text","info":"         // Add a star indicating this is a valid word"},
        {"type":"text","info":"         if( theNode->getChildPtr( '*' ) == NULL )"},
        {"type":"text","info":"             return false;"},
        {"type":"text","info":"         return true;"},
        {"type":"text","info":"     }"},
        {"type":"text","info":"     return false;"},
        {"type":"text","info":"}"},
        {"type":"subtitle","info":"Testing the Trie"},
        {"type":"text","info":"In the code provided online, I have several tests"},
        {"type":"text","info":"Trie theTrie;"},
        {"type":"text","info":"STRING BAT(\"BAT\");"},
        {"type":"text","info":"STRING BAT_CAVE(\"BAT-CAVE\");        STRING BAT_COMPUTER(\"BAT-COMPUTER\");"},
        {"type":"text","info":"STRING BAT_DANCE(\"BAT-DANCE\");        STRING BAT_DIAMOND(\"BAT-DIAMOND\");"},
        {"type":"text","info":"STRING BAT_PHONE(\"BAT-PHONE\");        STRING BAT_SHARK(\"BAT-SHARK\");"},
        {"type":"text","info":"STRING BAT_SIGNAL(\"BAT-SIGNAL\");    STRING BAT_TASER(\"BAT-TASER\");"},
        {"type":"text","info":"STRING BAT_TRACER(\"BAT-TRACER\");    STRING BATARANG(\"BATARANG\");"},
        {"type":"text","info":"STRING BATGIRL(\"BATGIRL\");            STRING BATMAN(\"BATMAN\");"},
        {"type":"text","info":"STRING BATMOBILE(\"BATMOBILE\");"},
        {"type":"text","info":"In the video, I show the compilation process and test for the Trie Data Structure."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=c2297005-db13-4f5f-8ca2-ae530169a9c9"},
        {"type":"text","info":"In Lecture, we will work on an advanced problem commonly known as Word Search (Links to an external site.), which implements Depth-First Search and Trie data structures together. You will see in that example that we are able to rapidly insert the entire English dictionary and play the Word Search game"},
        {"type":"text","info":"Lecture 24 Introduction Question 2: Describe the approach behind designing a Trie Data Structure from scratch in C++?"},
        {"type":"subtitle","info":"Reading 24.3 - Introduction to Approximation Algorithms"},
        {"type":"text","info":"Note: Reading 24.3 is a \"skim reading\" section. Nothing we will discuss in this section will be explicitly asked about on a Weekly Survey or Exam. However, this section will provide motivation for studying Bloom Filters in section 24.4, as well as the A* Algorithm we will study in Lecture 28."},
        {"type":"text","info":"Furthermore, I link and allude to many concepts you will study in future courses."},
        {"type":"text","info":"In the CSE 40133 Design and Analysis of AlgorithmsLinks to an external site. course, you will study \"Techniques for designing efficient computer algorithms and for analyzing computational costs of algorithms.\" You will cover many of the same data structures and algorithms we have discussed in this course, except you will approach them with greater mathematical rigor."},
        {"type":"text","info":"- Discrete Math is not a pre-requisite for Data Structures, but it is for CSE 40133"},
        {"type":"text","info":"- Data Structures is a pre-requisite for virtually every other class in the CSE curriculum"},
        {"type":"text","info":"To this point in your CS/CPEG careers, you have learned about problems with an exact solution"},
        {"type":"text","info":"- Allocating an exact amount of memory in a static array"},
        {"type":"text","info":"- Re-allocating double the previous memory for a Dynamic Array"},
        {"type":"text","info":"- Key to Location mapping using Hash Tables and a Dynamic Array"},
        {"type":"text","info":"- Performing insertions, deletions, and traversals in Binary Search Trees give the same results, depending on the type of tree."},
        {"type":"text","info":"- Even the C/C++ random number generator (Links to an external site.) is dependent upon an equation and the current clock in the computing device."},
        {"type":"text","info":"-> Remember the Year 2038 (Links to an external site.) error!"},
        {"type":"text","info":"But not every problem on a computer will give the same solution, even with the same inputs."},
        {"type":"text","info":"- Deterministic - An algorithm that, given a particular input, will always produce the same output, with the underlying machine always passing through the same sequence of states"},
        {"type":"text","info":"- Non-Deterministic - An algorithm that, even for the same input, can exhibit different behaviors on different runs. Even on the same machine!"},
        {"type":"text","info":"-> Operating Systems preview: You will need to keep track of race conditions in multi-threaded programs to reduce nondeteministic operation."},
        {"type":"text","info":"-> The way many Operating Systems keep track of multiple threads, since they are commonly built upon the C programming language, are void pointers"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=08a48c3b-5d4d-42e0-8af2-ae5500f17dea"},
        {"type":"text","info":"Interesting Note: Many of my TAs who have taken Operating Systems express gratitude for the void pointers review they get here, because they are really important in that class."},
        {"type":"text","info":"In the Algorithms course, you will learn that not every problem can be solved on a modern computing device given a set of reasonable resources. An approximation algorithm is an efficient algorithm that find approximate solutions to optimization problems."},
        {"type":"text","info":"- In the CSE 30151 Theory of ComputingLinks to an external site. course, you will learn about P and NP (Links to an external site.), which represent classes of solvable problems"},
        {"type":"text","info":"-> P is \"Solvable, Deterministic and Polynomial Time\""},
        {"type":"text","info":"--> O(N), O(N2), O(N3), and so on"},
        {"type":"text","info":"-> NP is \"Non-deterministic problems with solutions that are efficiently verifiable\""},
        {"type":"text","info":"--> Typically reduced to \"yes/no\" problems"},
        {"type":"text","info":"--> O(2N), O(3N)"},
        {"type":"text","info":"Examples of problems in P:"},
        {"type":"text","info":"- Is this array sorted?"},
        {"type":"text","info":"- Does this array have duplicates?"},
        {"type":"text","info":"Examples of problems in NP:"},
        {"type":"text","info":"- In graph G, does there exist a path from s to t of weight > k?"},
        {"type":"text","info":"- In graph G, does there exist a path that visits each vertex exactly once? "},
        {"type":"text","info":"-> Known as a Hamiltonian Path"},
        {"type":"text","info":"Comparing the runtime of P and NP:"},
        {"type":"text","info":"- P: If the runtime for a O(N) problem with 100 elements takes one second"},
        {"type":"text","info":"-> O(N2) will take 100 seconds (a little less than 2 minutes)"},
        {"type":"text","info":"-> O(N3) will take 166 minutes (a little less than 3 hours)"},
        {"type":"text","info":"-> O(N4) will take 11.54 days"},
        {"type":"text","info":"- NP:"},
        {"type":"text","info":"-> O(2N) will take 4.01 * 1020 years"},
        {"type":"text","info":"--> Literally one trillion eons!"},
        {"type":"text","info":"Examples of problems not in NP:"},
        {"type":"text","info":"- Is this the best chess move I can make next?"},
        {"type":"text","info":"-> Hard to verify."},
        {"type":"text","info":"- What is the longest path?"},
        {"type":"text","info":"-> Not a yes/no question."},
        {"type":"subtitle","info":"NP Completeness and Computing"},
        {"type":"text","info":"A form of NP problem you will encounter in your career is known as \"NP Complete\". Formally, this means \"nondeterministic polynomial-time complete\". At this stage in your career, it is sufficient to understand NP Complete in two parts:"},
        {"type":"text","info":"- A brute-force search algorithm can find a solution by trying all possible solutions"},
        {"type":"text","info":"- Once a solution is found, the correctness of each solution can be verified quickly."},
        {"type":"text","info":"What we've learned this semester through our study of complete search and search tree pruning is that using Brute Force to determine a solution is computationally expensive. Depending on the computational resources available to you, they may even be prohibitively expensive."},
        {"type":"text","info":"Optional Reading: Complexity of n-Queens Completion"},
        {"type":"text","info":"Optional Readings: The lectures from the Theory of Computing course on:"},
        {"type":"text","info":"- P and NP"},
        {"type":"text","info":"- NP Completeness"},
        {"type":"subtitle","info":"Heuristics and Approximation Algorithms"},
        {"type":"text","info":"In one of these prohibitively expensive scenarios, what if we don't need an “exact” solution?"},
        {"type":"text","info":"For example,"},
        {"type":"text","info":"- What if the need for performance is high and the memory cost is prohibitive?"},
        {"type":"text","info":"- And what if we have an allowable margin for error?"},
        {"type":"text","info":"Basically, if we sacrifice 3% accuracy, but get the problem from O(2N) down to O(N2),"},
        {"type":"text","info":"- We've potentially reduced the run time from 4.01 * 1020 years to 100 seconds!"},
        {"type":"text","info":"- Definitely enough difference in time to check the solution and re-run our approximation algorithm until we get a correct answer."},
        {"type":"text","info":"For example, Notre Dame alumnus Marty Rose, who is a Senior Software Developer at Google, described a project he worked on:"},
        {"type":"text","info":"- \"I worked for a project that applied machine learning to online advertising.  I would often need to count the number of unique cookies (millions out of billions of records) that reached each stage of our advertising funnel to do some analysis.\""},
        {"type":"text","info":"Heuristic algorithms are designed to solve a problem in a faster and more efficient fashion than traditional methods"},
        {"type":"text","info":"- Sacrificing optimality, accuracy, precision, or completeness for speed."},
        {"type":"text","info":"As we will see in reading 24.4 about Bloom Filters, we can quantify the amount of optimality we are sacrificing in trading off for performance. Here is the rest of Marty's quote on the Advertising problem he worked on at Google:"},
        {"type":"text","info":"- \"I would use bloom filters to do this.  I would check if I had see the cookie before.  If so, I would increment a counter.  Although not perfect, it gave reasonably accurate numbers while also being very memory efficient.\""},
        {"type":"text","info":"Because we are determining an approximate solution, we often refer to heuristics as approximation algorithms."},
        {"type":"subtitle","info":"Optional: P = NP?"},
        {"type":"text","info":"One of the most popular unsolved problems is the P=NP problem. In fact, many consider it the most important open problem in all of computer science."},
        {"type":"text","info":"- The main idea behind P problems is that creating the proof has the same complexity as proving the solution to the proof."},
        {"type":"text","info":"- The main idea behind NP problems is that checking the solution is easy, but creating the proof is hard."},
        {"type":"text","info":"So P = NP would imply that the apparently hard problems actually have relatively easy solutions."},
        {"type":"text","info":"The idea of P=NP was first postulated by mathematician John Nash (who you may know as the man portrayed by Russell Crowe in the movie A Beautiful Mind (Links to an external site.)) and is famous for his contributions to Game Theory."},
        {"type":"text","info":"Here are his comments in his \"Letter to the National Security Agency (Links to an external site.)\""},
        {"type":"text","info":"- “Now my general conjecture is as follows: for almost all sufficiently complex types of enciphering, especially where the instructions given by different portions of the key interact complexly with each other in the determination of their ultimate effects on the enciphering, the mean key computation length increases exponentially with the length of the key, or in other words, the information content of the key ... The nature of this conjecture is such that I cannot prove it, even for a special type of ciphers. Nor do I expect it to be proven.” —John Nash"},
        {"type":"text","info":"If P=NP, then every mathematical proof can be automated!"},
        {"type":"text","info":"- P=NP would mean checking a proof is roughly as easy as creating the proof in every case."},
        {"type":"text","info":"- \"The mental effort of the mathematician in the case of yes-or-no questions could be completely replaced by machines\" - Scott Aaronson"},
        {"type":"text","info":"While the yes/no solution to the P=NP problem is not known, the prevailing wisdom is that P ≠ NP"},
        {"type":"text","info":"- An argument in favor of P ≠ NP: If P = NP, then the world would be a profoundly different place than we usually assume it to be. There would be no special value in \"creative leaps,\" no fundamental gap between solving a problem and recognizing the solution once it's found."},
        {"type":"text","info":"- An argument in favor of P = NP:"},
        {"type":"subtitle","info":"Optional: Millennium Prize Problems"},
        {"type":"text","info":"In 2000, the Clay Mathematics Institute set up $1,000,000 \"Millennium Prize Problems\" for the solution of each of seven problems. (Links to an external site.) What I want you to take away is that there are many problems that have not yet been formally solved, which means that there are problems that are not yet solvable on a computer."},
        {"type":"text","info":"- Hodge Conjecture (Links to an external site.)"},
        {"type":"text","info":"- Poincare Conjecture (Solved by Grigoriy Perelman (Links to an external site.))"},
        {"type":"text","info":"- Riemann hypothesis"},
        {"type":"text","info":"- Yang-Mills existence and mass gap"},
        {"type":"text","info":"- Navier-Stokes existence and smoothness"},
        {"type":"text","info":"- Birch and Swinnerton-dyer conjecture (Links to an external site.)"},
        {"type":"text","info":"- P=NP"},
        {"type":"text","info":"-> If true, proof might allow you to trivially solve all of these problems."},
        {"type":"text","info":"Lecture 24 Introduction Question 3: What is a Heuristic and what are the benefits of using a heuristic to solve a problem in a computer?"},
        {"type":"subtitle","info":"Reading 24.4 - Bloom Filters"},
        {"type":"text","info":"A bloom filter is a space efficient, probabilistic data structure that is used to tell whether a member is in a set."},
        {"type":"text","info":"In the diagram below is an example of a Bloom Filter"},
        {"type":"text","info":"- x,y,z are hash functions"},
        {"type":"text","info":"- When a value is put in the bloom filter, all three are marked as 1"},
        {"type":"text","info":"-> w is the value being verified in the Bloom Filter"},
        {"type":"text","info":"- If all three elements are true, then the element is in the Filter"},
        {"type":"text","info":"Bloom filters have a space advantage over other data structures"},
        {"type":"text","info":"- Use a \"yes/no\" approach"},
        {"type":"text","info":"-> Use std::bitset to implement in C++"},
        {"type":"text","info":"-> Meaning we can reduce to a polynomial problem"},
        {"type":"text","info":"- Most of these require storing at least the data items themselves"},
        {"type":"text","info":"- Linked structures incur an additional linear space overhead for pointers."},
        {"type":"text","info":"A Bloom filter with 1% error and an optimal value of k"},
        {"type":"text","info":"- Requires only about 9.6 bits per element — regardless of the size of the elements."},
        {"type":"text","info":"Important Note: No Deletion from a Bloom Filter"},
        {"type":"text","info":"- Use multiple hash functions to determine which bits to mark"},
        {"type":"text","info":"-> Two values can generate a '1' for one of the hash functions"},
        {"type":"text","info":"Erase is not possible with bitset since that would introduce false negatives"},
        {"type":"text","info":"- Search is probabilistic:"},
        {"type":"text","info":"- Returns false if definitely not in set"},
        {"type":"subtitle","info":"Determining the number of hash functions in a Bloom Filter"},
        {"type":"text","info":"The accuracy of the Bloom Filter is dependent upon the number of Hash Functions we look up."},
        {"type":"text","info":"- The more Hash Functions, the more bits we require"},
        {"type":"text","info":"Intuitively, this makes sense. Since we are trading accuracy for space efficiency, then the more accurate we make the Bloom Filter, the more memory it will consume."},
        {"type":"text","info":"Given a desired error rate (e) and an anticipated number of elements (n), we can find the optimal settings of m, the size of the table, and k, the number of hash functions:"},
        {"type":"text","info":"e = desired error rate"},
        {"type":"text","info":"n = number of elements"},
        {"type":"text","info":"k = -log2(e)  # number of hash functions"},
        {"type":"text","info":"m = kn/ln(2)  # number of bits"},
        {"type":"text","info":"Example Problem:"},
        {"type":"text","info":"Given a desired error rate (6.25%) and an anticipated number of elements of 1000 signed integers, state how many hash functions and bits would be required in the Bloom Filter and the improvement in memory."},
        {"type":"text","info":"Solution:"},
        {"type":"text","info":"k = -log2(0.0625) = log2( 1 / 0.0625 ) = log2( 16 ) = 4"},
        {"type":"text","info":"- Therefore, we will need four separate Hash Functions"},
        {"type":"text","info":"m = kn/ln(2) = 4*1000 / ln(2) = 5770.78"},
        {"type":"text","info":"- Therefore, we need 5771 bits in the Bloom Filter"},
        {"type":"text","info":"- Therefore, we will need 5771 bits"},
        {"type":"text","info":"1000 signed integers requires 1000*4*8 bits = 32,000 bits"},
        {"type":"text","info":"The improvement in memory is 1 - ( 5771 / 32000 ) = 0.81965625"},
        {"type":"text","info":"- Therefore, we have an 81.965% improvement in memory"},
        {"type":"text","info":"This Bloom Filter gives"},
        {"type":"text","info":"- An improvement in memory of 81.965% "},
        {"type":"text","info":"- An improvement in search from O(N) to O(1)"},
        {"type":"text","info":"-> Four hash calculations instead of an average of 1000/2 comparisons"},
        {"type":"text","info":"- In exchange for a 6.25% reduction in accuracy."},
        {"type":"text","info":"Lecture 24 Introduction Question 4: What is a Bloom Filter and how do we calculate the size and number of Hash Functions in the Bloom Filter?"}
        ]},

    {"unique_id":"7-1","content":[
        {"type":"subtitle","info":"Classes and C++ Friend Operators"},
        {"type":"subtitle","info":"To Data Structures, and Beyond! What exactly is a Programming Paradigm?"},
        {"type":"text","info":"In this lecture, we will review the concepts of C++ Operators, Classes, Inheritance, and Polymorphism. This lecture is designed to reinforce your understanding of how data is structured in a computing device while simultaneously setting you up for success in the Programming Paradigms course. "},
        {"type":"text","info":"A programming paradigm is way to classify programming languages based on their features. In the CSE 30332 course, you will acquire a high-level view of programming language concepts."},
        {"type":"text","info":"In addition to understanding the kinds of problems a language was designed to solve, you need to understand how a language solves these problems."},
        {"type":"text","info":"Think of Paradigms as a breadth-first search approach to studying programming languages"},
        {"type":"text","info":"You can understand the possible paths to solving a problem with a programming language"},
        {"type":"text","info":"But you don't go so far into depth into any one paradigm."},
        {"type":"text","info":"Strengthens your breadth of understanding as a Computer Scientist or Computer Engineer."},
        {"type":"text","info":"Mastering more than one language is often a watershed in the career of a professional programmer. Once a programmer realizes that programming principles transcend the syntax of any specific language, the doors swing open to knowledge that truly makes a difference in quality and productivity."},
        {"type":"text","info":"In the Data Structures course, you've seen the difference in how C and C++ can be used to solve problems"},
        {"type":"text","info":"C is a functional programming language focusing primarily on control the flow of data through the computing structure"},
        {"type":"text","info":"C++ is an object-oriented programming language focusing on relating ideas to computing machine operations"},
        {"type":"text","info":"Python, which is covered in Systems Programming in depth, can be implemented through all four programming paradigms"},
        {"type":"text","info":"Although Python doesn't fully provide the data hiding that C++ and Java perform in classes, so many argue that Python doesn't fully support Object-Oriented Programming"},
        {"type":"text","info":"That being said, C++ and Java don't fully support data hiding either! If you know the base address of the object and perform pointer arithmetic, you can still access the memory on the data heap. "},
        {"type":"text","info":"This actually provides a way for programs to circumvent the private access modifier"},
        {"type":"text","info":"No C++ compiler can prove the absence of such illegal accesses (Known as the pointer aliasing problem)"},
        {"type":"subtitle","info":"C++ Classes vs. C++ Structs"},
        {"type":"text","info":"In C, we learned that we could allocate memory with multiple elements together in a struct. We then learned that, in C++, would could construct and destruct by treating C structs as objects. In order to provide data hiding, we had to explicitly save C++ members and methods privately."},
        {"type":"text","info":"A C++ class is just like a C++ struct except for one key difference:"},
        {"type":"text","info":"In a C++ struct, all members and methods are public by default, and we have to explicitly hide declare members and methods as private"},
        {"type":"text","info":"But you don't go so far into depth into any one paradigm."},
        {"type":"text","info":"In a C++ class, all members and methods are private by default, and we have to explicitly hide declare members and methods as public"},
        {"type":"text","info":"For all the code we've presented from Lectures 11-24, you can replace the keyword \"struct\" with the keyword \"class\", and all the code will compile and run just as well. This is because we employed a data-hiding programming paradigm using C++ structs in the exact same manner as a C++ class. "},
        {"type":"text","info":"We were able to do this because we first learned about memory management and C struct pointers. Then we learned about the this pointer, C++ constructors and destructors, and the encapsulation and the private keyword."},
        {"type":"text","info":"Next, we learned about C++ templates to promote a data structure towards the object-oriented paradigm."},
        {"type":"text","info":"Now we can abstract complexity away a step further by not requiring the this keyword unless we are passing the pointer to the class itself."},
        {"type":"subtitle","info":"CC++ Friend Operators"},
        {"type":"text","info":"We also learned about C++ operators in our implementation of Minimum Spanning Trees where we could compare different objects. But let's say we have a data structure, and instead of wanting to call a print_data() method, we just wanted to print the structure using COUT, just like we would for an integer/float/double:"},
        {"type":"text","info":"RBTree< std::string > the_rbtree;"},
        {"type":"text","info":"the_rbtree.insert( \"Let's\" );"},
        {"type":"text","info":"the_rbtree.insert( \"go\" );"},
        {"type":"text","info":"the_rbtree.insert( \"Irish!\" );"},
        {"type":"text","info":"COUT << \"In-Order Traversal: \" << the_rbtree << \" is here!\" << ENDL;"},
        {"type":"text","info":"Our operator could not just use the Red-Black Tree itself, because we might not always be printing to std::cout. What if we were printing to an output stream or output FILE* pointer?"},
        {"type":"text","info":"In the Object-Oriented Programming paradigm, you must set your code up for success in any situation! This includes the Red-Black Tree being part of a set of outputs in the same line, as we see in the code segment above!"},
        {"type":"text","info":"The solution is a friend operator. The idea behind a friend operator is that you pass both an object and a friend object. In the example below, this operator prints out information for a class Student. You need to pass the student with a call by reference as well as an output stream with a call by reference. "},
        {"type":"text","info":"Since we need to pass the output stream to the next object to be printed, we need to return the std::ostream with a call by reference as well."},
        {"type":"text","info":"The method is able to access the private members of theStudent"},
        {"type":"text","info":"The std::ostream output is the friend of the student"},
        {"type":"text","info":"friend std::ostream& operator<<(std::ostream& output, const Student& theStudent){"},
        {"type":"text","info":"output << \"Student: \" << theStudent.lastName << \", \" << theStudent.firstName;"},
        {"type":"text","info":"output    << \" (\" << theStudent.ndID << \")\" << (char)10;"},
        {"type":"text","info":"output << \"Home Address: \" << theStudent.homeAddress << \"\n\";"},
        {"type":"text","info":"output << \"Class Rank: \" << theStudent.getCLASS() << std::endl;"},
        {"type":"text","info":"output << \"Dorm: \" << theStudent.dorm;"},
        {"type":"text","info":"return output;"},
        {"type":"text","info":"}"},   
        {"type":"subtitle","info":"C++ Inheritance"},                      
        {"type":"subtitle","info":"Object Relationships"},
        {"type":"text","info":"When relating object types, it is helpful to think of them in 3 ways"},
        {"type":"text","info":" 1. \"Uses a\" = An object uses another object by calling a public method of that object."},
        {"type":"text","info":"Example: array[ currentPos ].first"},
        {"type":"text","info":"array is a vector"},
        {"type":"text","info":"[] is an overloaded operator, which is a public method of that object"},
        {"type":"text","info":".first is a public member of a std::pair"},
        {"type":"text","info":" 2. \"Has a\" - Implemented using composition (aggregation)"},
        {"type":"text","info":"Examples:"},
        {"type":"text","info":"A course section has a student list"},  
        {"type":"text","info":"A person has a birth date"},  
        {"type":"text","info":"A movie has a start time"},
        {"type":"text","info":"A library has a book"},
        {"type":"text","info":" 3. \"Is a\" - One object is a more specialized version of another:"},
        {"type":"text","info":"Implemented using inheritance"},
        {"type":"text","info":" A car is a vehicle"},
        {"type":"text","info":"A sorted list is a list"},
        {"type":"text","info":"A student is a person"},
        {"type":"text","info":""},
        {"type":"text","info":"An undergraduate student is a student"},
        {"type":"subtitle","info":"Inheritance and OOP"},
        {"type":"text","info":"More general class: base class (or superclass)."},
        {"type":"text","info":"Specialized classes: a derived class (or subclass)."},
        {"type":"text","info":"Derived classes use, extend, modify, or replace the base class behaviors."},
        {"type":"text","info":"Consider the Notre Dame community. Each \"object\" of the ND community has a unique set of privileges as well as a set of \"is a\" relationships"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/25-1.jpg') }}"},
        {"type":"text","info":"When designing a Base and Derived Class, adhere to the following rules (there are 8 total across Reading 25.2 and 25.3)"},
        {"type":"text","info":"1) Base class requires a destructor with the virtual keyword in the .h file"},
        {"type":"text","info":"virtual function - a member function which is declared within a base class and is re-defined (Overriden) by a derived class"},
        {"type":"text","info":"Use the virtual keyword in class definition (.h file) only"},
        {"type":"text","info":"2) Any private members or methods in the base that you wish for the derived class to have access to should be put under a protected keyword in the base"},
        {"type":"text","info":"Consider the Base Class Irish.h (Links to an external site.) and Irish.cpp (Links to an external site.) shown below. You can see the virtual destructor, even though no private member has an explicitly defined pointer. Furthermore, the members are protected since we plan on using all of them in the derived classes. "},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/25-2.png') }}"},
        {"type":"text","info":"3) In the derived class, the format is class derived : public base"},
        {"type":"text","info":"Example: class Student : public Irish"},
        {"type":"text","info":"4) For private members or methods in the derived class, you only need to add members that are unique to the derived class."},
        {"type":"text","info":"Example: For class Student, no need to include lastName, firstName, ndID, or homeAddress, since they are inherited from Irish"},
        {"type":"text","info":"5) For the constructor, you must use the constructor for the base class as the first argument for the member initialization list"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/25-3.png') }}"},
        {"type":"text","info":"6) The derived class must have a destructor"},
        {"type":"text","info":"Only use the virtual keyword if the derived class is a base class for another class"},
        {"type":"text","info":"7) You must write new friend methods, since the friend method depends on the specific class you are passing to it"},
        {"type":"text","info":"code examples for inheritance:"},
        {"type":"text","info":"Base Class: Irish"},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/include/Irish.h"},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/src/Irish.cpp"},
        {"type":"text","info":"Derived Class:Student"},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/include/Student.h"},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/src/Student.cpp"},
        {"type":"text","info":"Derived Class:Faculty"},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/include/Faculty.h"},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/src/Faculty.cpp"},
        {"type":"text","info":"Test Programs:"},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/src/IrishTest.cpp"},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/src/Inherit.cpp"},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/src/Inherit2.cpp"},  
                                
        
        {"type":"subtitle","info":"C++ Polymorphism"}, 
        {"type":"text","info":"With Inheritance, we are able to represent the \"is a\" relationship between objects."},     
        {"type":"text","info":"However, each derived class should be able to override base class methods to implement their own version"}, 
        {"type":"text","info":"These derived class methods should have many forms."}, 
        {"type":"text","info":"In Greek, \"many forms\" translates to \"polymorph\""}, 
        {"type":"text","info":"This is why overriding base class methods is known as Polymorphism."}, 
        {"type":"text","info":"Polymorphism"}, 
        {"type":"text","info":"Formal: The ability of a base class to refer transparently to any of its derived classes"}, 
        {"type":"text","info":"Manipulate objects of these classes in a type-independent manner"},               
        {"type":"text","info":"Supported only when we use pointers or references"},
        {"type":"subtitle","info":"Static vs. Dynamic Binding in Polymorphism "},
        {"type":"text","info":"Binding is the process of determine which method in the class hierarchy is to be invoked for a particular object"}, 
        {"type":"text","info":"Static Binding"}, 
        {"type":"text","info":"Compile time"}, 
        {"type":"text","info":"Compiler can determine which method in the class hierarchy to use"}, 
        {"type":"text","info":"Dynamic Binding"}, 
        {"type":"text","info":"Run time"}, 
        {"type":"text","info":"Determination of which method in the class hierarchy occurs during program execution"}, 
        {"type":"subtitle","info":"An Example of Static Binding "},
        {"type":"text","info":"An Example of Static Binding "}, 
        {"type":"text","info":"Time t1;"}, 
        {"type":"text","info":"ExtTime et2;"}, 
        {"type":"text","info":"Statically Bind setTime method"}, 
        {"type":"text","info":"t1.setTime(12, 30, 00);            // static binding"}, 
        {"type":"text","info":"et2.setExtTime(13, 45, 30);    // static binding"}, 
        {"type":"text","info":"Statically Bind printTime methos"},
        {"type":"text","info":"t1.printTime( );         // static binding - Time's printTime( )"},
        {"type":"text","info":"et2.printTime();        // static binding - ExtTime's printTime( )"},
        {"type":"subtitle","info":"Dynamic Binding"},
        {"type":"text","info":"Base class must use the reserved word virtual"}, 
        {"type":"text","info":"We've seen an example already!"}, 
        {"type":"text","info":"Destructors for inherited classes"}, 
        {"type":"text","info":"Virtual Methods"}, 
        {"type":"text","info":"All overriding methods from that point on down the hierarchy are virtual"}, 
        {"type":"text","info":"Even if not explicitly defined to be so"},    
        {"type":"text","info":"We can use a base class with no constructor"},   
        {"type":"subtitle","info":"Arithmetic Trees Example"},
        {"type":"text","info":"In Lecture, we will study in detail an example of dynamic binding where we implement an arithmetic tree."},    
        {"type":"text","info":"This is a form of Advanced Data Structure known as an Abstract Syntax Tree"},  
        {"type":"text","info":"Trees with different types of nodes"},    
        {"type":"text","info":"Let's say we want to perform the task 2 * ( 3+4 ) + 5. We know how much orders of operation are important in mathematics. We also know that coding an advanced problem in C++ would be prohibitively difficult."},  
        {"type":"text","info":"So let's use our knowledge of data structures, inheritance, and polymoprhism to strategically program an approach to developing an arithmetic tree!"},    
        {"type":"image","info":"{{ url_for('static', filename='contentImages/25-4.gif') }}"},
        {"type":"text","info":"We know that there is a difference between the data (the values 2, 3, 4, and 5) and the structure of operations (+ and *). So let's build a class hierarchy of nodes:"},  
        {"type":"image","info":"{{ url_for('static', filename='contentImages/25-5.gif') }}"},
        {"type":"subtitle","info":"The Node Abstract Class"},
        {"type":"text","info":"The Node class is what is known as an abstract class"},
        {"type":"text","info":"Cannot be instantiated, so there is no constructor"},    
        {"type":"text","info":"Calc Virtual Method"},    
        {"type":"text","info":"returns a double as the result of calculating the node's value"},    
        {"type":"text","info":"The calculation may involve the recursive calculations of its children"},    
        {"type":"text","info":"method is const because it doesn't change the node itself"},  
        {"type":"text","info":"no \"default\" implementation of Calc for an arbitrary Node"},    
        {"type":"text","info":"Pure Virual"},  
        {"type":"text","info":"We will set it equal to 0"},   
        {"type":"text","info":"The Node.h file contains the example of this base virtual class."},  
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/include/Node.h"},    
        {"type":"text","info":"class Node"},
        {"type":"text","info":"{"},
        {"type":"text","info":"    public:"},
        {"type":"text","info":"     virtual ~Node () {}"},
        {"type":"text","info":"     virtual double Calc () const = 0;"},
        {"type":"text","info":"};"},  
        {"type":"subtitle","info":"BinNode Class "},
        {"type":"text","info":"In the BinNode.h and BinNode.cpp files, we see an example of Polymorphism."},    
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/include/BinNode.h"},  
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/src/BinNode.cpp"},    
        {"type":"text","info":"We create a constructor to bind two child nodes together. Since we don't if the child nodes will be a "},  
        {"type":"text","info":"All the other node types will derive from the BinNode class, so this will permit creation of the Abstract Syntax Tree"},  
        {"type":"text","info":"We do not need to create a Calc() method since we are not creating another form at this stage."},  
        {"type":"text","info":"All the derived classes will be able to overwrite the virutal method from Node."},  
        {"type":"text","info":"#include \"Node.h\""},

        {"type":"text","info":"class BinNode : public Node"},
        {"type":"text","info":"{"},
        {"type":"text","info":"    protected:"},
        {"type":"text","info":"        Node* leftNode;"},
        {"type":"text","info":"        Node* rightNode;        "},
        {"type":"text","info":"    public:"},
        {"type":"text","info":"        //default constructor"},
        {"type":"text","info":"         BinNode() : leftNode(Lnode), rightNode(Rnode){}"},
        {"type":"text","info":"        // destructor"},
        {"type":"text","info":"         virtual ~BinNode (){"},
        {"type":"text","info":"           delete leftNode;"},
        {"type":"text","info":"            delete rightNode;"},
        {"type":"text","info":"          }"},
        {"type":"text","info":"   };"},
        {"type":"text","info":" "},   
        {"type":"subtitle","info":"NumNode Class "},
        {"type":"text","info":"In the NumNode.h and NumNode.cpp files, we see an example of a derived class that creates its own form of the Calc() method."},    
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/include/NumNode.h"},  
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/src/NumNode.cpp"},    
        {"type":"text","info":"In this case, the NumNode will return its own private member with the value itself:"},  
        {"type":"text","info":"class NumNode : public Node"},  
        {"type":"text","info":" {"},  
        {"type":"text","info":"     protected:"},  
        {"type":"text","info":"         double num;"},  
        {"type":"text","info":"     public:"},  
        {"type":"text","info":"       // Constructor"},  
        {"type":"text","info":"       NumNode(double numIN) : num(numIN){ }"},  
        {"type":"text","info":"       // destructor"},  
        {"type":"text","info":"      virtual ~NumNode () { }    "},  
        {"type":"text","info":"       // overloaded method"},  
        {"type":"text","info":"       double Calc() const{"},  
        {"type":"text","info":"           return this -> num;"},  
        {"type":"text","info":"        }"},  
        {"type":"text","info":" };"},    
        {"type":"subtitle","info":"AddNode Class"},
        {"type":"text","info":"In the AddNode.h and AddNode.cpp files, we see an example of a derived class that creates pointers to two child Nodes. "},    
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/include/AddNode.h"},  
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/src/AddNode.cpp"},    
        {"type":"text","info":"They can be either another BinNode derived class, or a NumNode class."},  
        {"type":"text","info":"Notice how I use the BinNode constructor as the first object in the AddNode constructor"},    
        {"type":"text","info":"The destructor automatically calls the BinNode destructor, so we do not need to try to delete the nodes"},    
        {"type":"text","info":"The polymorphism is evident in the Calc() method"},    
        {"type":"text","info":"class AddNode : public BinNode"},
        {"type":"text","info":"{"},
        {"type":"text","info":"    public:"},
        {"type":"text","info":"      // overload Constructor"},
        {"type":"text","info":"      AddNode(Node* node1, Node* node2) : BinNode(node1,node2){ }"},
        {"type":"text","info":"       // destructor"},
        {"type":"text","info":"        ~AddNode () { }"},
        {"type":"text","info":"       // Function"},
        {"type":"text","info":"       double Calc() const{"},
        {"type":"text","info":"             double val1 = this -> leftNode -> Calc();"},
        {"type":"text","info":"            double val2 = this -> rightNode -> Calc();"},
        {"type":"text","info":"           return val1 + val2;"},
        {"type":"text","info":"      }"},
        {"type":"text","info":"};"},  
        {"type":"subtitle","info":"A Final Note on Polymorphism and Makefiles"},  
        {"type":"text","info":"The remaining classes perform Subtraction, Multiplication, and Division. Here are the remaining files and driver programs, which we will cover in detail in class:"},    
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/include/SubNode.h"},  
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/src/SubNode.cpp"},  
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/include/MultNode.h"},  
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/src/MultNode.cpp"},  
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/include/DivNode.h"},  
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/src/DivNode.cpp"},  
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/src/Polymorph.cpp"},  
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/Makefile"},  
        {"type":"text","info":"Here is the final compilation for the addition, subtraction, multiplication, and division. Note how many files and classes are required, even in this \"simple\" implementation. Imagine having to perform all those operations by hand! This should reinforce the purpose and benefit of Makefiles and File Hierarchies."},    
        {"type":"text","info":"-bash-4.2$ make Polymorph "},
        {"type":"text","info":"g++ -m64 -std=c++11 -Weffc++ -O2 -g -Wall -Wextra -Wconversion -Wshadow -Werror -c src/BinNode.cpp -o objects/BinNode.o "},
        {"type":"text","info":"g++ -m64 -std=c++11 -Weffc++ -O2 -g -Wall -Wextra -Wconversion -Wshadow -Werror -c src/NumNode.cpp -o objects/NumNode.o "},
        {"type":"text","info":"g++ -m64 -std=c++11 -Weffc++ -O2 -g -Wall -Wextra -Wconversion -Wshadow -Werror -c src/AddNode.cpp -o objects/AddNode.o "},
        {"type":"text","info":"g++ -m64 -std=c++11 -Weffc++ -O2 -g -Wall -Wextra -Wconversion -Wshadow -Werror -c src/SubNode.cpp -o objects/SubNode.o "},
        {"type":"text","info":"g++ -m64 -std=c++11 -Weffc++ -O2 -g -Wall -Wextra -Wconversion -Wshadow -Werror -c src/DivNode.cpp -o objects/DivNode.o "},
        {"type":"text","info":"g++ -m64 -std=c++11 -Weffc++ -O2 -g -Wall -Wextra -Wconversion -Wshadow -Werror -c src/MultNode.cpp -o objects/MultNode.o "},
        {"type":"text","info":"g++ -m64 -std=c++11 -Weffc++ -O2 -g -Wall -Wextra -Wconversion -Wshadow -Werror -o exe/Polymorph objects/Polymorph.o objects/BinNode."},
        {"type":"text","info":"o objects/NumNode.o objects/AddNode.o objects/SubNode.o objects/DivNode.o objects/MultNode.o "},
        {"type":"text","info":"-bash-4.2$ exe/./Polymorph"},
        {"type":"text","info":"First Equation: (20.0 - (-10.0) * 0.1)"},
        {"type":"text","info":"Multiplying : -10 + (0.1)"},
        {"type":"text","info":"Adding : 20 and -1"},
        {"type":"text","info":"Result: 19"},
        
        {"type":"text","info":"Second Equation: 5 - (1 / (3 * ( -20 + 6) ) )"},
        {"type":"text","info":"Adding : -20 + (6)"},
        {"type":"text","info":"Multiplying : 3 * -14"},
        {"type":"text","info":"Dividing : 1 / -42"},
        {"type":"text","info":"Subtracting : 5 - -0.0238095"},
        {"type":"text","info":"Result: 5.02381"}]},                    
        
      
        



    {"unique_id":"7-2","content":[
        {"type":"subtitle","info":"Cache Hierarchy"},
        {"type":"subtitle","info":"To Data Structures, and Beyond! How Computers Organize Memory"},
        {"type":"text","info":"When we write programs in a computing machine, because of the way we structure data and the way we compile code, programs tend to access data that forms a physical cluster in memory. This phenomenon is known as the principle of locality."}, 
        {"type":"text","info":"There are two types of locality in a computer:"},    
        {"type":"text","info":"Temporal locality - If an memory element is referenced, it will tend to be referenced again soon"},    
        {"type":"text","info":"Spatial locality - If an memory element is referenced, memory elements who memory addresses are close by will tend to be referenced soon."},    
        {"type":"text","info":"Furthermore, from our studies in storing data, we know we need to store significant amount of memory in a data structure. In Lecture 22, I performed a demonstration of B-Trees of several orders that stored several million elements that passed valgrind. For example:"},    
        {"type":"text","info":"The B-Tree with Order 64 that stored the Wordle dictionary (2,309 std::string elements) required 5,271 allocs, 5,271 frees, and 371,852 bytes allocated"},    
        {"type":"text","info":"The B-Tree with Order 3 that stored 2,500,000 long ints required 16,781,844 allocs, 16,781,844 frees, and 626,522,176 bytes allocated"},    
        {"type":"text","info":"The drawback of B-Trees is that they store elements by their cluster on a disk. While they make searching for specific keys more efficient, they do not efficiently temporal or spatial locality. So what if we could structure temporary memory so that recently accessed elements are easier to find?"},    
        {"type":"text","info":"This is the main idea behind cache memory. Hardware designers split the levels of memory between the processor and disk memory into several levels, each with increasing access speeds."},    
        {"type":"text","info":"The tradeoff is that, the faster the cache memory, the higher the cost"},    
        {"type":"text","info":"Or: In order to get more cache, you need more cash."},    
        {"type":"text","info":"Because of this design tradeoff, the speed and amount of cache are strategically selected to optimize the speed and cost. To understand why this is important, let us run the command lscpu from the UNIX command line. We can see the different levels of cache in the x86_64 architecture we ran the demonstrate on. In the Level 1 cache, you can see the separation into L1d (for Level 1 - Data Heap) and L1i (for Level 1 - Instruction Stack). "},    
        {"type":"text","info":"L1d cache: 32K"},    
        {"type":"text","info":"L1i cache: 32K"},    
        {"type":"text","info":"L2 cache: 256K"},    
        {"type":"text","info":"L3 cache: 20480K"},    
        {"type":"text","info":"We see that the 626,522,176 bytes we required for the B-Tree with 2,500,000 long integers required significantly more memory than all the cache memory we have available. Yet, when I printed the in-order traversal of that B-Tree, it did not take very long at all."},    
        {"type":"text","info":"The closer the data is to the CPU, the more recently it has been accessed."},    
        {"type":"text","info":"So we can say that swapping memory between levels of cache memory is one time-consuming operation that permits an improved average run time."},    
        {"type":"text","info":"Where have we studied that concept before?"},    
        {"type":"image","info":"{{ url_for('static', filename='contentImages/cache.jpeg') }}"}, 
        {"type":"text","info":"That's right! We studied Amortized Analysis in Lecture 14. In Reading 26.2, we will study a specific data structure called a Splay Tree keeps the elements in a sorted order, but \"splays\" the more recently accessed elements to the root of the Binary Search Tree. Consider this quote from the original paper by Daniel Sleator and Robert Tarjan in 1985:"},    
        {"type":"text","info":"\"[Self-balancing Binary Search Trees] are all designed to reduce the worst-case time per operation. However, in typical applications of search trees, not one but a sequence of operations is performed, and what matters is the total time the sequence takes, not the individual times of the operations.\""},    
        
        
        
        {"type":"subtitle","info":"Formally Defining Splay Trees"},    
        {"type":"text","info":"The main idea behind Splay Trees is that the nodes that are most recently access are closer to the top of the tree"},    
        {"type":"text","info":"Getting the element to the top from near the bottom of the tree is the occasional costly operation"},    
        {"type":"text","info":"However, the most recently accessed elements will be near the top."},    
        {"type":"text","info":"By the Principle of Locality, this means those elements are more likely to be accessed."},    
        {"type":"text","info":"So the traversal to the specific data element is lower on the average."},    
        {"type":"text","info":"Which means the average case is good!"},    
        {"type":"subtitle","info":"\"Splaying\" to the Top of the Tree"},    
        {"type":"text","info":"We will implement three rules when accessing an element in a Splay Tree"},    
        {"type":"text","info":"1. Insertion - When inserting an element into a Splay Tree, we will insert into the tree in the sorted order, like a normal Binary Search Tree. Then, we will \"splay\" the element to the top of the tree using the four rules listed below."},    
        {"type":"text","info":"2. Access - Whenever we access an element, we will splay the requested element to the top of the tree using the four rules listed below."},    
        {"type":"text","info":"3. Element not in Tree - If we attempt to access an element, and it is not in the tree, then we \"splay\" the closest element to that requested element to the top of the tree using the four rules listed below."},    
        {"type":"text","info":"Why do you think we would implement the third rule?"},    
        {"type":"text","info":"The reason is that the memory that is closest to the requested element is now at the top of the Splay Tree, so we are preserving the Principle of Locality."},        
        {"type":"subtitle","info":"Four Rules for Rotation Elements to the Top of the Splay Tree"},    
        {"type":"text","info":" Splaying 3 to the top of the tree"},    
        {"type":"text","info":"Rule 1 : Zig (Left of Root) - Splaying 3 to the top of the tree"},    
        {"type":"text","info":"4 becomes 3s right child"},    
        {"type":"text","info":"3s right child becomes 4s left child"},  
        {"type":"image","info":"{{ url_for('static', filename='contentImages/26-1.png') }}"}, 
        {"type":"text","info":"Rule 2 : Zag (Right of Root) - Splaying 5 to the top of the tree"},    
        {"type":"text","info":"4 becomes 5s left child"},    
        {"type":"text","info":"5s left child becomes 4s right child"},  
        {"type":"image","info":"{{ url_for('static', filename='contentImages/26-2.png') }}"}, 
        {"type":"text","info":"Rule 3 : Zig-Zig (Left of Left of Root, or Right of Right of Root)"},    
        {"type":"text","info":"In this example, we are splaying 3 to the top of the tree:"},    
        {"type":"image","info":"{{ url_for('static', filename='contentImages/26-3.png') }}"}, 
        {"type":"text","info":"Just like a Red-Black Tree, we say that"},    
        {"type":"text","info":"3 is the child"},    
        {"type":"text","info":"4 is the parent"},    
        {"type":"text","info":"10 is the grandparent"},    
        {"type":"text","info":"In the Zig-Zig, 3 becomes the new root, 4 becomes the right child of 3, and 10 becomes the new right child of 10."},    
        {"type":"image","info":"{{ url_for('static', filename='contentImages/26-4.png') }}"}, 
        {"type":"text","info":"Rule 4 - Zig-Zag (Left of Right of Root, or Right of Left of Root)"},    
        {"type":"text","info":"In this example, we are splaying 5 to the root:"},    
        {"type":"image","info":"{{ url_for('static', filename='contentImages/26-5.png') }}"}, 
        {"type":"text","info":"First, we make 5 the parent of 4, and then 5's right child becomes the left child of 4 (in this case, NULL)"},    
        {"type":"image","info":"{{ url_for('static', filename='contentImages/26-6.png') }}"}, 
        {"type":"text","info":"Next, we make 5 the root, and make 10 the right child of 5"},    
        {"type":"image","info":"{{ url_for('static', filename='contentImages/26-7.png') }}"},    
        {"type":"subtitle","info":"Example Problem:"},    
        {"type":"text","info":"Given the following insertions and finds, generate the final Splay Tree"},    
        {"type":"text","info":"Insert: 10, 7, 15, 8, 12, 16, 11"},    
        {"type":"text","info":"Find: 8, 13, 10"},    
        {"type":"text","info":"Note: 13 is not in the original Splay Tree. The problem on the Exam will have a similar attempted access"},    
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=3551fa41-cd5c-441a-85eb-ae5700127cdd&start=2.273826"},    
        


        {"type":"subtitle","info":"Visualizing the Benefit of Splay Trees with Caches"},    
        {"type":"text","info":"There are two excellent resources to help you visualize how Splay Trees work"},    
        {"type":"text","info":"University of San Francisco:"},    
        {"type":"code","info":" https://www.cs.usfca.edu/~galles/visualization/SplayTree.html"},    
        {"type":"text","info":"Carnegie Mellon:"},    
        {"type":"code","info":"https://www.link.cs.cmu.edu/splay/"},    
        {"type":"text","info":"The Splay Tree visualization was developed by Prof. Daniel Sleator, who is a co-inventor of Splay Trees. The interesting aspect of this visualization tool is that you can enter a number of elements, and then visualize the Splay of a large tree by clicking on the specific element."},    
        {"type":"text","info":"In the video below, I demonstrate how the Splay Tree can be used to promote memory addresses in a Cache."},    
        {"type":"text","info":"I enter 100 for the initial elements"},    
        {"type":"text","info":"I then focus my selections on 50-59 as the first block"},    
        {"type":"text","info":"After a couple of selections, 50-59 are all near the top of the Splay Tree"},    
        {"type":"text","info":"Next, I focus my selections on 70-79"},    
        {"type":"text","info":"After a couple of selections, 70-79 are near the top"},    
        {"type":"text","info":"You can also see 50-59 and 60-69 are also close to the top of the Splay"},    
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=ee249645-bd47-4778-94c7-ae5601823c0f&start=0"},    

        {"type":"subtitle","info":"Probabilistic Treaps"},    
        {"type":"text","info":"The main idea of a Splay Tree is that the elements that are more likely to be accessed will be closer to the top of the tree, and we use the most recent access to move the elements to the top of the tree."},    
        {"type":"text","info":"But... what if we could knew the priority in advance? We could combine balancing and priority somehow."},    
        {"type":"subtitle","info":"Trade-offs in Sorting Trees and Heaps"},    
        {"type":"text","info":"Based on our study of balancing data structures, let's consider the benefits and drawbacks to each self-balancing structure:"},    
        {"type":"text","info":""},    
        {"type":"subtitle","info":"B-Trees"},    
        {"type":"text","info":"Great for Databases"},    
        {"type":"text","info":"Strict Balancing"},    
        {"type":"text","info":"Good for structuring blocks of data, but not priorities"},    
        {"type":"subtitle","info":"Red-Black Trees"},    
        {"type":"text","info":"Relaxed balancing mechanisms improve on AVL, with a small tradeoff in height"},    
        {"type":"text","info":"Best for uniform access to data"},    
        {"type":"text","info":"Worst-case: When elements near the bottom of the tree have a higher priority"},      
        {"type":"subtitle","info":"Splay Trees"},    
        {"type":"text","info":"Good for amoritized, non-uniform access to the tree"},    
        {"type":"text","info":"Splay occasionally has a worst-case access"},    
        {"type":"subtitle","info":"Heaps and Binomial Heaps"},    
        {"type":"text","info":"Elements with higher priority are closer to the top of the Heaps"},    
        {"type":"text","info":"Not Sorted, so bad for structures that require sorting."},    
        {"type":"subtitle","info":"Ideation: Sort by Value, Heapify by Priority!"},    
        {"type":"text","info":"In the Splay Tree, we insert in order, and then splay the element to the top."},    
        {"type":"text","info":"In our new data structure, which we will call a Treap "},    
        {"type":"text","info":"Nodes are inserted in-order by their keys"},    
        {"type":"text","info":"But then heap-ordered by their priorities!"},    
        {"type":"text","info":"Consider the Treap below:"},    
        {"type":"text","info":"In-order: A, C, D, F, H, I, and J still works!"},    
        {"type":"text","info":"The level order of the tree shows that higher probabilities move up the tree"},    
        {"type":"text","info":"Prob - Level Order: 75, 70, 65, 55, 60, 14, 45"},    
        {"type":"image","info":"{{ url_for('static', filename='contentImages/26-8.png') }}"},        
        {"type":"subtitle","info":"Example Problem:"},    
        {"type":"text","info":"In the video below, we will go through the process of inserting into a Treap. The insertions are performed in the following order, where the input is show in the format {Data, Priority}:"},    
        {"type":"text","info":"{D, 60}, {F, 75}, {H, 14}, {C, 70}, {A, 55}, {I, 65}, {G, 80}"},    
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=86342341-e575-45f6-aadc-ae5700298e43&start=0"},    
        {"type":"subtitle","info":"Probabilistic Treap "},    
        {"type":"text","info":"One way we can expand on this idea is to use the Random Number Generator to produce a random priority for each inserted value."},    
        {"type":"text","info":"A particular treap may have bad (or good) worst-case performance."},    
        {"type":"text","info":"But as we randomize the priorities in the treaps over time, we will see that most treaps average out to good worst-case performance overall."},      
        {"type":"subtitle","info":"Comparing the Maximum Height "},    
        {"type":"text","info":"For 100 Random Elements - log2( 100 ) = 6.64385618977 ≈ 7"},    
        {"type":"subtitle","info":"Binary Search Tree and Splay"},    
        {"type":"text","info":"Best case - 7"},    
        {"type":"text","info":"Requires traversing through 7 nodes to get to any leaf"},    
        {"type":"text","info":"Worst case - 100"},    
        {"type":"text","info":"Requires traversing through all 100 nodes to get to the leaf"},    
        {"type":"subtitle","info":"AVL Trees"},    
        {"type":"text","info":"Worst case height is 7"},    
        {"type":"subtitle","info":"Red Black Tree"},    
        {"type":"text","info":"Best case height - 7"},    
        {"type":"text","info":"2 * lg(100) + 1 = 14.28 => Worst case max height is 15"},    
        {"type":"subtitle","info":"Probabilistic Treaps"},    
        {"type":"text","info":"Given the height of the Treap with n nodes being h before an insert, the higher the probability, the more likely to be raised in the Treap."},    
        {"type":"text","info":"My presented Probabilistic Treap in C++, which you may view online, we well as its test driver program InsertRandom.cpp"},    
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec26_Reading/include/TreapNode.h"},    
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec26_Reading/include/Treap.h"},    
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec26_Reading/src/InsertRandom.cpp"},    
        {"type":"text","info":"To experiment, I ran 100 random inserts on a Probabilistic Treap 1,000,000 times and combined the statistics. You may view the code InsertRandom2.cpp"},    
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec26_Reading/src/InsertRandom2.cpp"},    
        {"type":"text","info":"Here are my results"},    
        {"type":"text","info":"The average was a height of 11.654"},    
        {"type":"text","info":"This result was remarkably consistent across dozens of runs."},    
        {"type":"text","info":"This is almost exactly equal to 3/2*lg(100)+1"},    
        {"type":"text","info":"Here is the output run for the 1,000,000 instance test:"},    
        {"type":"image","info":"{{ url_for('static', filename='contentImages/26-9.png') }}"},        
        {"type":"subtitle","info":"Probabilistic Treap in C++,"},    
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec26_Reading/include/TreapNode.h"},    
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec26_Reading/include/Treap.h"},    
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec26_Reading/src/InsertRandom.cpp"},    
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec26_Reading/src/InsertRandom2.cpp"}      
        ]},



    {"unique_id":"7-3","content":[
        {"type":"subtitle","info":"Introduction to Data Compression"},
        {"type":"subtitle","info":"To Data Structures and Beyond! Data Management"},
        {"type":"text","info":"Every day, humans create a mind-blowing amount of data. Here are some examples for daily creation of data in 2022:"},
        {"type":"text","info":"900 million Tweets"},
        {"type":"text","info":"8 billion Google Searches"},
        {"type":"text","info":"376.4 billion emails"},
        {"type":"text","info":"720,000 hours of YouTube video"},
        {"type":"text","info":"Now that you have learned intuitively that data must actually be structured on a computer, you now understand the challenge that all this data must have a location to be stored!"},
        {"type":"text","info":"Companies like Google, Facebook, Amazon, TikTok, ect., are creating massive data stores"},
        {"type":"text","info":"These data stores require significant energy in order to maintain."},
        {"type":"text","info":"Google used about 15.439 gigawatt-hours of electricity in 2020"},
        {"type":"text","info":"That is about the amount of energy consumed by the entire Dominican Republic"},
        {"type":"text","info":"The more data that needs to be saved, the more energy it requires"},
        {"type":"text","info":"Going back to Makefiles and Git: This underlies the importance of running make clean before pushing to GitHub."},
        {"type":"subtitle","info":"Data Compression"},
        {"type":"text","info":"While companies are looking for ways to keep the power down or use renewable resources, there is another approach: what if we can represent the same amount of information while consuming less memory?"},
        {"type":"text","info":"We took our first crack at this idea when we implemented Tries."},
        {"type":"text","info":"We also managed to significantly reduce the amount of memory we required to save information in a Bloom Filter, albeit with a tradeoff in accuracy."},
        {"type":"text","info":"The goal of a compression algorithm is to find short sequences of bits or characters that generate desired longer sequences of bits. You see examples of Data Compression algorithms and applications every time you open your laptop!"},
        {"type":"text","info":"Generic file compression."},
        {"type":"text","info":"Files: Gzip, bzip2, 7z, PKZIP"},
        {"type":"text","info":"File systems: ZFS, HFS+, ReFS, GFS, APFS"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/27-1.png') }}"},        
        {"type":"text","info":"Multimedia."},
        {"type":"text","info":"Images: GIF, JPEG, PNG, RAW, ...."},
        {"type":"text","info":"Sound: MP3, AAC, Ogg Vorbis, ...."},
        {"type":"text","info":"Video: MP4, HDTV, H.264, HEVC, .... "},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/27-2.png') }}"},        
        {"type":"text","info":"Communication. Fax, Skype, WeChat, Zoom, ...."},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/27-3.png') }}"},        
        {"type":"text","info":"Databases. SQL, Google, Facebook, NSA, …."},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/27-4.png') }}"},        
        {"type":"text","info":"Smart sensors. Phone, watch, car, health, …."},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/27-5.png') }}"},        
        {"type":"subtitle","info":"Data Compression Algorithms Preview: \"Rdenudcany in Enlgsih lnagugae\""},
        {"type":"text","info":"There is quite a bit of redundancy in the English language. We can leverage this property to reduce the amount of data required to represent sentences, code, ect. while the final compressed string represents the exact same text:"},
        {"type":"text","info":"“ ... randomizing letters in the middle of words [has] little or no effect on the ability of skilled readers to understand the text. This is easy to denmtrasote.  In a pubiltacion of New Scnieitst you could ramdinose all the letetrs, keipeng the first two and last two the same, and reibadailty would hadrly be aftcfeed. ” — Graham Rawlinson"},
        {"type":"text","info":"Compression and expansion "},
        {"type":"text","info":"Message. Bitstream B we want to compress."},
        {"type":"text","info":"Compress. Generates a “compressed” representation C(B)."},
        {"type":"text","info":"Expand. Reconstructs original bitstream B."},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/27-6.png') }}"},        
        {"type":"text","info":"Simple Example: DNA Genomic Code"},
        {"type":"text","info":"Genome. String over the alphabet { A, T, C, G }."},
        {"type":"text","info":"Goal. Encode an n-character genome: ATAGATGCATAG"},
        {"type":"text","info":"Since there are only 4 characters, why use ASCII?"},
        {"type":"text","info":"ASCII characters require 8 characters each"},
        {"type":"text","info":"But since there are four choices, we can reduce to 2 bits for each"},
        {"type":"text","info":"Say we make A = 00, T = 01, C = 10, and G = 11"},
        {"type":"text","info":"Consider this example: ATAGATGCATAG"},
        {"type":"text","info":"In ASCII       : 010000010101010001000001010001110100000101010100010001110100001101000001010101000100000101000111"},
        {"type":"text","info":"Compressed: 000100110001111000010011"},
        {"type":"text","info":"We reduced the size by 75 percent! Considering the human genome has 3.2 billion base pairs"},
        {"type":"text","info":"Before: required 3.2 megabytes to represent one DNA strand"},
        {"type":"text","info":"After: required 800 kilobytes to represent one DNA strand"},
        {"type":"text","info":"Run-length encoding (RLE) "},
        {"type":"text","info":"RLE is a form of lossless data compression in which runs of data (sequences in which the same data value occurs in many consecutive data elements) are stored as a single data value and count, rather than as the original run."},
        {"type":"text","info":"Long runs of repeated bits"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/27-7.png') }}"},        
        {"type":"text","info":"Representation - 4-bit counts to represent alternating runs of 0s and 1s:"},
        {"type":"text","info":"15 0s, then 7 1s, then 7 0s, then 11 1s."},
        {"type":"text","info":"1111 0111 0111 1011"},
        {"type":"text","info":"Reduction from a length of 40 bits to 16 bits"},
        {"type":"text","info":"So what is the compression ratio?"},
        {"type":"text","info":"4^2 = 16"},
        {"type":"text","info":"The run length can go from 0 to 15"},
        {"type":"text","info":" - 0000"},
        {"type":"text","info":" 0 - 0001"},
        {"type":"text","info":" 00 - 0010"},
        {"type":"text","info":" 000 - 0011"},
        {"type":"text","info":" 0000 - 0100"},
        {"type":"text","info":" 00000 - 0101"},
        {"type":"text","info":" 000000 - 0110"},
        {"type":"text","info":" 0000000 - 0111"},
        {"type":"text","info":" 00000000 - 1000"},
        {"type":"text","info":" 000000000 - 1001"},
        {"type":"text","info":" 0000000000 - 1010"},
        {"type":"text","info":" 00000000000 - 1011"},
        {"type":"text","info":" 000000000000 - 1100"},
        {"type":"text","info":" 0000000000000 - 1101"},
        {"type":"text","info":" 00000000000000 - 1110"},
        {"type":"text","info":" 000000000000000 - 1111"},
        {"type":"text","info":"So what is the average compression ration?"},
        {"type":"text","info":"Sum of 0 to 15, 16 values"},
        {"type":"text","info":"( n * n - 1 ) / 2 = 16*15 / 2 = 120"},
        {"type":"text","info":"Each of the compressed values is 4 bits"},
        {"type":"text","info":"16 * 4 = 64"},
        {"type":"text","info":"Therefore, the average compression ratio is 64/120"},
        {"type":"text","info":"Example Problem: Given a run-length encoding scheme of 8-bits, what is the average compression ratio"},
        {"type":"text","info":"n^2 = 64 bits"},
        {"type":"text","info":"Sum of 0 to 63, 64 values"},
        {"type":"text","info":"( n * n - 1 ) / 2 = 64*63 / 2 = 2016"},
        {"type":"text","info":"Each of the compressed values is 8 bits"},
        {"type":"text","info":"64 * 8 = 512"},
        {"type":"text","info":"Therefore, the average compression ratio is 512/2016, which reduces to 16/63"},
        {"type":"text","info":"Advantages and Disadvantages"},
        {"type":"text","info":"RLE is most efficient on data that contains many such runs, for example, simple graphic images such as icons, line drawings, Conway's Game of Life, and animations."},
        
   
        {"type":"subtitle","info":"Huffman Encoding"},
        {"type":"text","info":"We can compress the string if we use a variable-length code where codewords may have different lengths."},
        {"type":"text","info":"Give short codewords for characters that appear often and long codewords for characters that appear rarely."},
        {"type":"text","info":"For example, let's say we have the following string: AABACDACA"},
        {"type":"text","info":"A fixed length encoding would try to reduce to:"},
        {"type":"text","info":"A = 00, B = 01, C = 10, D = 11"},
        {"type":"text","info":"The ASCII representation is 72 bits"},
        {"type":"text","info":"The fixed length encoding is now 18 bits: 000001001011001000"},
        {"type":"text","info":"But let's now consider the number of instances:"},
        {"type":"text","info":"The count is A = 5, B = 1, C = 2, and D = 1"},
        {"type":"text","info":"Let's say that we make each string unique in that we get to 0 and then stop the character. This approach ensures that no codeword is a prefix of another codeword, which prevents ambiguity"},
        {"type":"text","info":"it is not allowed that a code would contain both codewords 10 and 1011. "},
        {"type":"text","info":"Can't tell if the 10 is the beginning of 1011 or the entire string of 10!"},
        {"type":"text","info":"However, since specific strings are prefixes of other characters, radio operators had to leave a space between each character so that the receiver of the message knew how to interpret the characters."},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/28-1.png') }}"},        
        {"type":"subtitle","info":"Huffman Coding"},
        {"type":"text","info":"Huffman coding is a greedy algorithm that constructs an optimal code for compressing a given string. The algorithm builds a binary tree based on the frequencies of the characters in the string, and each character's codeword can be read by following a path from the root to the corresponding node. A move to the left corresponds to bit 0, and a move to the right corresponds to bit 1."},
        {"type":"text","info":"Initially, each character of the string is represented by a node whose weight is the number of times the character occurs in the string. Then at each step two nodes with minimum weights are combined by creating a new node whose weight is the sum of the weights of the original nodes. The process continues until all nodes have been combined."},
        {"type":"text","info":"Next we will see how Huffman coding creates the optimal code for the string AABACDACA. The node that represents character A has weight 5 because character A appears 5 times in the string. The other weights have been calculated in the same way. In a tie, we sort by alphabetical order:"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/28-2.png') }}"},        
        {"type":"text","info":"The next step is to combine the nodes that correspond to characters B and D, both with weight 1. The result is:"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/28-3.png') }}"},        
        {"type":"text","info":"After this, the nodes with weight 2 are combined: "},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/28-4.png') }}"},        
        {"type":"text","info":"Finally, the two remaining nodes are combined:"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/28-5.png') }}"},        
        {"type":"text","info":"Now all nodes are in the tree, so the code is ready. The following codewords can be read from the tree:"},
        {"type":"text","info":"A = 0"},
        {"type":"text","info":"C = 10"},
        {"type":"text","info":"B = 110"},
        {"type":"text","info":"D = 111"},
        {"type":"text","info":"Now we can reduce AABACDACA:"},
        {"type":"text","info":"001100101110100, which is now 15 bits"},
        {"type":"subtitle","info":"Two possible philosophies for using Huffman Compression:"},
        {"type":"text","info":"1. For each input type (English text, Chinese text, images, Java source code, etc.), assemble huge numbers of sample inputs for that category. Use each corpus to create a standard code for English, Chinese, etc."},
        {"type":"text","info":"Will result in suboptimal encoding for specific input strings"},
        {"type":"text","info":"2. For every possible input file, create a unique code just for that file. Send the code along with the compressed file."},
        {"type":"text","info":"Requires you to use extra space for the codeword table in the compressed bitstream"},
        {"type":"text","info":"demonstrate your understanding of Huffman Encoding by building the tree, which is the second philosophy. This approach is also the philosophy used in the real world."}
        
        
        ]},


    {"unique_id":"7-4","content":[
        {"type":"text","info":"EXAMPLE PARAGRAPH"},
        {"type":"image","info":"link to image"}
        ]},

    {"unique_id":"8-1","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},
    {"unique_id":"8-2","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},
    {"unique_id":"8-3","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},
    {"unique_id":"8-4","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]}

]



