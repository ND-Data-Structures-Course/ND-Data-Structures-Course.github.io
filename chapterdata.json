[
    
    {"unique_id":"1-1","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},
    {"unique_id":"1-2","content":[
        {"type":"subtitle","info":"Section 2.1 - Writing and Compiling Basic Programs"},
        {"type":"text","info":"A challenge many students have when beginning the Data Structures course is that they struggle with the idea that the computer is actually a physical machine, and not a nebulous device where magically fairies fight pointer demons. The first part of the course will drive home the idea that we must learn structure before we can master the use of data. "},
        {"type":"text","info":"So we will start with a seemingly simple piece of code:"},
        {"type":"code","info":"https://raw.githubusercontent.com/mmorri22/sp22-cse-20312/main/Lec02_Reading/nothing.c"},
        {"type":"text","info":"This piece of code takes in no inputs, (seemingly) performs no tasks, and then returns nothing on the output. However, C is a brace procedure language, meaning that tasks are divided up by using braces."},
        {"type":"text","info":"Consider the TV show Avatar: The Last Airbender. For those of you not familiar with the show, the Avatar confronts a character named King Bumi. Bumi appears to have allowed the Fire Nation to conquer his city without a fight. However, Bumi uses this as an opportunity to teach the Avatar about options in fighting. Bumi actually elected to do nothing until the time was right, which allowed him to attack from the inside. A computer is very much the same way: you must first learn that you need act on inputs or deliver the expected outputs, you need to know that they are. So you must learn to code nothing before you can learn to code something."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=e8f33aad-b1e0-4b1e-a363-ae1301491289&start=11.653175"}
        ]},

    {"unique_id":"2-1","content":[
        {"type":"subtitle","info":"Pointer Syntax Review"},
        {"type":"text","info":"In the Lecture 2 reading, we made an analogy between computing memory and the way our brain remembers information. To review, that analogy was"},
        {"type":"text","info":"Registers, like our working memory, are limited, fast, and control how we process information"},
        {"type":"text","info":"Stack, like the Hippocampus, is slightly slower, and \"crams and forgets\" information"},
        {"type":"text","info":"Heap, like the Neocortex, is the slowest, but can be used to structure and store long-term information and data."},
        {"type":"text","info":"So why is knowing memory locations important?"},
        {"type":"text","info":"Registers are extremely limited, and we must use them effectively"},
        {"type":"text","info":"Stack are static - must be known at compile time"},
        {"type":"text","info":"Heap is dynamic - Can reallocate whenever we want"},
        {"type":"text","info":"In this section, we are going to learn about pass by reference, where you pass pointers to information to a function in order to perform a task. In order to master this concept, let's briefly review the syntax of C pointers."},
        {"type":"text","info":"Each pointer contains three elements:"},
        {"type":"text","info":"An initial location (origin)"},
        {"type":"text","info":"Typically the address of a register"},
        {"type":"text","info":"A destination"},
        {"type":"text","info":"Stored in the origin register"},
        {"type":"text","info":"A value"},
        {"type":"text","info":"Information at that destination"},
        {"type":"text","info":"In C, we use & and * to represent pointer information:"},
        {"type":"text","info":"The & indicates the address"},
        {"type":"text","info":"The * indicates we are either allocating a pointer or de-referencing a pointer."},
        {"type":"subtitle","info":"C Pointer Review Code Example "},
        {"type":"text","info":"The second syntax definition is often the most confusing to students. So let's review these concepts through code:"},
        {"type":"text","info":"int x = 5;"},
        {"type":"text","info":"int* int_ptr = &x"},
        {"type":"text","info":"So, what does this mean?"},
        {"type":"text","info":"We create a register containing the value 5, and we label this register x"},
        {"type":"text","info":"We create a second register containing the address of x (&x), and we indicate the data in the register is a pointer by using int*."},
        {"type":"text","info":"We have now established a pointer. Just like the neurons in our brain do in order to connect information"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/3-1.png') }}"},
        {"type":"text","info":"So now let's print the information for each of the following"},
        {"type":"text","info":"The address of x"},
        {"type":"text","info":"The data contained in x"},
        {"type":"text","info":"The address of int_ptr"},
        {"type":"text","info":"The data contained in int_ptr"},
        {"type":"text","info":"The data at the address pointed to by int_pointer"},
        {"type":"text","info":"Recall that the output specifier for addresses is %p, which is for pointer. So we specify we want to print the pointer to the address of x."},
        {"type":"text","info":"fprintf( stdout, \"The address of x = %p\n\", &x );"},
        {"type":"text","info":"Next, we use %d to print the data in x"},
        {"type":"text","info":"fprintf( stdout, \"The data contained in x = %d\n\", x );"},
        {"type":"text","info":"The next task is where students are most likely to be confused coming into this course. Remember that pointers are registers that contain data which is an address. This means that the register has an address as well as contains an address. "},
        {"type":"text","info":"fprintf( stdout, \"The address of int_ptr = %p\n\", &int_ptr );"},
        {"type":"text","info":"fprintf( stdout, \"The data contained in int_ptr = %p\n\", int_ptr);"},
        {"type":"text","info":"Watch this video where I explain the difference between the address of the register containing a pointer and the address that the pointer is pointing to:"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=1aaa7423-5344-46b5-881a-ae150105dc15&start=0"},
        {"type":"text","info":"Finally, to obtain the data at the address we are pointing to, we need to de-reference the pointer. We use the same * character that we used to allocate the pointer in order to de-reference the data."},
        {"type":"text","info":"Putting all the pieces together, we see that the following code segment will produce the resulting register addresses and data. "},
        {"type":"text","info":"#include <stdio.h>"},
        {"type":"text","info":"int main()"},
        {"type":"text","info":"{"},
        {"type":"text","info":"int x = 5;"},
        {"type":"text","info":"int* int_ptr = &x;"},
        {"type":"text","info":"fprintf( stdout, \"The address of x = %p\n\", &x );"},
        {"type":"text","info":"fprintf( stdout, \"The address of int_ptr = %p\n\", &int_ptr );"},
        {"type":"text","info":"fprintf( stdout, \"The data contained in int_ptr = %p\n\", int_ptr);"},
        {"type":"text","info":"fprintf( stdout, \"The data at the address pointed to by int_pointer = %d\n\", *int_ptr );"},
        {"type":"text","info":"return 0;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"In the compile and run, I have highlighted which outputs match (meaning they are C \"synonyms\")"},
        {"type":"text","info":"-bash-4.2$ gcc -Wall -Wconversion -Werror ptr_review.c -o ptr_review"},
        {"type":"text","info":"-bash-4.2$ ./ptr_review"},
        {"type":"text","info":"The address of x = 0x7fff93a47f2c"},
        {"type":"text","info":"The data contained in x = 5"},
        {"type":"text","info":"The address of int_ptr = 0x7fff93a47f20"},
        {"type":"text","info":"The data contained in int_ptr = 0x7fff93a47f2c"},
        {"type":"text","info":"The data at the address pointed to by int_pointer = 5"},
        {"type":"subtitle","info":"The Two Pointer Metaphors"},
        {"type":"text","info":"Over the years, I have found that students understand pointers better in office hours when I use one of these two metaphors"},
        {"type":"text","info":"The Pirate Ship"},
        {"type":"text","info":"The Hungry Pupfessor"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=1252cfdd-64ab-4967-8770-ae150109cb69&start=0"},
        
        
        {"type":"subtitle","info":"Static and Dynamic Arrays"},
        {"type":"text","info":"In this section, we will discuss the difference between static and dynamic arrays. But first, let's review what an array actually is:"},
        {"type":"text","info":"An array is a collection of individual data elements that is:"},
        {"type":"text","info":"Ordered -- we can count off the elements 0,1,2,3,..."},
        {"type":"text","info":"Fixed in size"},
        {"type":"text","info":"Homogeneous -- all of the elements have to be of the same type"},
        {"type":"text","info":"In C and C++, each array has two fundamental properties"},
        {"type":"text","info":"the element type -> Data"},
        {"type":"text","info":"the size - > Structure"},
        {"type":"text","info":"But now we are introducing this idea of pointers as the \"conductor\" of the program. And in Lecture 2, we learned how to allocate a block of memory to a specific pointer, as well as performing pointer arithmetic."},
        {"type":"subtitle","info":"Static Arrays"},
        {"type":"text","info":"A static array is allocated in the stack. When we say the array is static, we mean that we know the full size of the array ahead of time. We can initialize the arrays in one of two ways:"},  
        {"type":"text","info":"data_type variable_name[size];"},
        {"type":"text","info":"Example: int int_array[5];"},
        {"type":"text","info":"data_type variable_name[] = { element1, element2, ..., elementN };"},
        {"type":"text","info":"Example: int int_array[] = {-10, 22, -17, 44, 5 };"},
        {"type":"text","info":"Here is an example of a static array in C. In the for loop, we will print the index, the address of the index, as well as the data contained at the address. Compare the code and the output from compilation:"},
        {"type":"text","info":"#include <stdio.h>"},
        {"type":"text","info":"int main(){"},
        {"type":"text","info":"  int i = 0;"},
        {"type":"text","info":"  int sample[] = {10, 22, -17, 44, 5};"},
        {"type":"text","info":"  for(i = 0; i < 5; i++){"},
        {"type":"text","info":"           fprintf( stdout, \"element = %d, address = %p, data = %d\n\", i, &sample[i], sample[i] );"},
        {"type":"text","info":"  }"},
        {"type":"text","info":"   fprintf( stdout, \"\n\");"},
        {"type":"text","info":"   return 0;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"And here is the compiled run:"},
        {"type":"text","info":"-bash-4.2$ gcc -Wall -Wconversion -Werror static_array.c -o static_array "},
        {"type":"text","info":"-bash-4.2$ ./static_array "},
        {"type":"text","info":"element = 0, address = 0x7ffc78a66b10, data = 10 "},
        {"type":"text","info":"element = 1, address = 0x7ffc78a66b14, data = 22 "},
        {"type":"text","info":"element = 2, address = 0x7ffc78a66b18, data = -17 "},
        {"type":"text","info":"element = 3, address = 0x7ffc78a66b1c, data = 44 "},
        {"type":"text","info":"element = 4, address = 0x7ffc78a66b20, data = 5 "},
        {"type":"text","info":"Note: Notice how the addresses increment by 4. The reason why is that signed integers are 32-bits. A byte is 8 bits, and the memory addresses are represented as bytes. Therefore 32/8 = 4, which is why they increment by 4."},
        {"type":"subtitle","info":"Dynamic Arrays"},
        {"type":"text","info":"A dynamic array is an array allocated on the Data Heap. When we say the array is dynamic, we mean that we do not necessarily know the size of the array at compile time. If we have any scenario where the amount of data increases during the program, we will use dynamic memory."},
        {"type":"text","info":"Almost every data structure we will study in this course addresses some variant of the question: \"how do we efficiently store and access dynamic data in X scenario?\""},
        {"type":"text","info":"A void pointer is the fundamental dynamic array, and casting the pointer informs us what type of data we are implementing."},
        {"type":"text","info":"For example, let's allocate a dynamic array of 10 doubles. I am going to go through this code step-by-step and show you how I allocated the dynamic memory."},
        {"type":"text","info":"We need stdlib.h (C standard library ) in order to be able to implement dynamic memory allocation in C."},
        {"type":"text","info":"#include <stdio.h>"},
        {"type":"text","info":"#include <stdlib.h>"},
        {"type":"text","info":"Recall that we use long unsigned integers allocate memory. Also, we cast a void pointer (returned by malloc) to double pointer to give context to the operating system that the memory we are pointing to must be considered as doubles."},
        {"type":"text","info":"int main(){"},
        {"type":"text","info":"    long unsigned int size = 5;"},
        {"type":"text","info":"    double* dbl_array = (double *)malloc( size * sizeof(double) );"},
        {"type":"text","info":"Since the array is dynamic, we must allocate them individually. I am presenting both the array syntax you are familiar with (dbl_array[2]) as well as pointer arithmetic ( *(dbl_array + 3) ) to indicate they are synonyms. C and C++ interpret dynamic arrays dbl_array[1] and *(dbl_array + 1) the exact same way."},
        {"type":"text","info":"    dbl_array[0] = -12.7;"},
        {"type":"text","info":"    *(dbl_array + 1) = 25.1;"},
        {"type":"text","info":"    dbl_array[2] = -3.3;"},
        {"type":"text","info":"    *(dbl_array + 3) = -15.2;"},
        {"type":"text","info":"    dbl_array[4] = 1; "},
        {"type":"text","info":"To re-enforce the fundamental pointer concepts, I am printing the address where the pointer is contained, as well as the address where the pointer is pointing to on the Heap. (Note: I have a video at the bottom where I will review this code and draw out the memory, so you can refer to that video to gain clarity.)"},
        {"type":"text","info":"    fprintf( stdout, \"dbl_array register at %p\n\", &dbl_array );"},
        {"type":"text","info":"    fprintf( stdout, \"Base address of dbl_array in Heap at %p\n\", dbl_array );"},
        {"type":"text","info":"Finally, I am iterating through the array, printing the addresses and values of the dynamic array elements. Then, we free the array"},
        {"type":"text","info":"    long unsigned int i;"},
        {"type":"text","info":"    for(i = 0; i < size; ++i){"},
        {"type":"text","info":"    fprintf( stdout, \"element = %lu, address = %p, data = %lf\n\", i, dbl_array + i, *(dbl_array + i) );"},
        {"type":"text","info":"    }"},
        {"type":"text","info":"    fprintf( stdout, \"\n\");"},
        {"type":"text","info":"    free( dbl_array );"},
        {"type":"text","info":"    return 0;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"Here is the output run, a drawing of the layout based on these addresses, as well as a video where I explain and draw the memory elements."},
        {"type":"text","info":"-bash-4.2$ gcc -Wall -Wextra -Wconversion -Werror dynamic_array.c -o dynamic_array"},
        {"type":"text","info":"-bash-4.2$ ./dynamic_array"},
        {"type":"text","info":"dbl_array register at 0x7ffd4c2205c8"},
        {"type":"text","info":" Base address of dbl_array in Heap at 0x14a9010"},
        {"type":"text","info":"element = 0, address = 0x14a9010, data = -12.700000"},
        {"type":"text","info":"element = 1, address = 0x14a9018, data = 25.100000"},
        {"type":"text","info":"element = 2, address = 0x14a9020, data = -3.300000"},
        {"type":"text","info":"element = 3, address = 0x14a9028, data = -15.200000"},
        {"type":"text","info":"element = 4, address = 0x14a9030, data = 1.000000"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/3-2.png') }}"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=f00210aa-429e-4e9d-a244-ae150123fd9e&start=0"},
        {"type":"subtitle","info":"Comparing Static and Dynamic Arrays"},
        {"type":"text","info":"Let's compare, and then run memory on the stack and the heap. To review:"},        
        {"type":"text","info":"Stack: int static_array[] = {4, 22, 10, 19};"},
        {"type":"text","info":"Fast access"},
        {"type":"text","info":"Limited amount of memory"},
        {"type":"text","info":"Unsafe to statically re-allocate"},
        {"type":"text","info":"C/C++ explicitly forbid static reallocation"},
        {"type":"text","info":"Java: No static memory allocation at all"},
        {"type":"text","info":"Abstracts pointers from the programmer"},
        {"type":"text","info":"Automatically allocated at compile time"},
        {"type":"text","info":"Heap: int* dyn_arr = (int*)malloc(size);"},
        {"type":"text","info":"Slower"},
        {"type":"text","info":"But much more memory"},
        {"type":"text","info":"Where Ideas will be built"},
        {"type":"text","info":"Remember that the memory is one long slab of silicon with different types built in (SRAM, DRAM). The syntax allows you to determine which type of memory you want to use:"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/3-3.png') }}"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/3-4.png') }}"},
        {"type":"text","info":"The crucial concept to take away is that you want to use static and dynamic memory for the specific situation you want:"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/3-5.png') }}"},
        {"type":"text","info":"To conclude this section, I will show a code sample with both static and dynamic memory. After the code segment, I will present a drawing of the layout of the memory. There are two important things I want to note:"},
        {"type":"text","info":"I have highlighted the line of code printing the addresses of the base address of the static memory in red, as well as the corresponding print out in red. Notice how they print the same address on the Stack. This is because the operating system knows where static memory is located at compile time, so the OS tracks the base address without requiring a pointer. (I will explain again in the video below the print outs)"},
        {"type":"text","info":"Do not free statically allocated memory. You will get a "},
        {"type":"text","info":"#include <stdio.h>"},
        {"type":"text","info":"#include <stdlib.h>"},
        {"type":"text","info":"int main(){"},
        {"type":"text","info":"    int int_static[] = {10, 20, -19, 34};"},
        {"type":"text","info":"   long unsigned int length = 4;"},
        {"type":"text","info":"    int* int_dynamic = (int *)malloc( length * sizeof(int) );"},
        {"type":"text","info":"    int_dynamic[0] = 10;"},
        {"type":"text","info":"    int_dynamic[1] = 20;"},
        {"type":"text","info":"    int_dynamic[2] = -19;"},
        {"type":"text","info":"    int_dynamic[3] = 34;"},
        {"type":"text","info":"    fprintf( stdout, \"Static Memory addresses: %p %p\n\", &int_static, int_static );"},
        {"type":"text","info":"    fprintf( stdout, \"Dynamic Memory addresses: %p %p\n\", &int_dynamic, int_dynamic );"},
        {"type":"text","info":"    long unsigned int iter;"},
        {"type":"text","info":"    for( iter = 0; iter < length; ++iter )"},
        {"type":"text","info":"       fprintf( stdout, \"int_static[%lu] = %d at %p and int_dynamic[%lu] = %d at %p\n\","},
        {"type":"text","info":"            iter, int_static[iter], &int_static[iter], iter, int_dynamic[iter], &int_dynamic[iter] );"},
        {"type":"text","info":"    }"},
        {"type":"text","info":"    // Free dynamically allocated memory"},
        {"type":"text","info":"    free( int_dynamic );"},
        {"type":"text","info":"    // Do NOT free statically allocated memory"},
        {"type":"text","info":"    // free( int_static );"},
        {"type":"text","info":"    return 0;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"Compile and run:"},
        {"type":"text","info":"-bash-4.2$ gcc -Wall -Wextra -Wconversion -Werror static_dynamic.c -o static_dynamic "},
        {"type":"text","info":"-bash-4.2$ ./static_dynamic "},
        {"type":"text","info":" Static Memory addresses: 0x7ffebeb6ab40 0x7ffebeb6ab40 "},
        {"type":"text","info":" Dynamic Memory addresses: 0x7ffebeb6ab38 0x244f010 "},
        {"type":"text","info":" int_static[0] = 10 at 0x7ffebeb6ab40 and int_dynamic[0] = 10 at 0x244f010 "},
        {"type":"text","info":" int_static[1] = 20 at 0x7ffebeb6ab44 and int_dynamic[1] = 20 at 0x244f014 "},
        {"type":"text","info":" int_static[2] = -19 at 0x7ffebeb6ab48 and int_dynamic[2] = -19 at 0x244f018 "},
        {"type":"text","info":" int_static[3] = 34 at 0x7ffebeb6ab4c and int_dynamic[3] = 34 at 0x244f01c "},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/3-6.png') }}"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=6c8d1e0a-6420-48bd-a2a2-ae1501308b72&start=0"},


        {"type":"subtitle","info":"Reading 3.3 - Passing Arrays by Reference in C"},
        {"type":"subtitle","info":"Pass by Value vs Pass by Reference"},
        {"type":"text","info":"Helpful to think of functions as a new working memory"},
        {"type":"text","info":"Completely different set of registers"},
        {"type":"text","info":"Completely different scope"},
        {"type":"text","info":"Changes to a copy in foo do not necessarily get reflected in main"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/3-7.png') }}"},
        {"type":"text","info":"Pass by Value passes a copy of the value"},
        {"type":"text","info":"Consider this: int foo( int x );"},
        {"type":"text","info":"Copy of x passed to value"},
        {"type":"text","info":"Return to a different register"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=0b2c27c2-873b-41ce-9b30-ae1501361e52&start=0"},
        {"type":"subtitle","info":"Pass by Reference"},
        {"type":"text","info":"This is a concept that trips up most new programmers…"},
        {"type":"text","info":"Structure: Pointer addresses are passed by value"},
        {"type":"text","info":"Data: The variable at that address is passed by reference"},
        {"type":"text","info":"You de-reference the pointer in the function"},
        {"type":"text","info":"The data is passed by reference"},
        {"type":"text","info":"Changes to pointer value are lost when the function goes out of scope."},
        {"type":"text","info":"Consider this function : void foo( int* x );"},
        {"type":"text","info":"Address of x passed to foo() and de-references the variable"},
        {"type":"text","info":"Updates and then passes the value back"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=039a9efa-b077-4430-90b9-ae15013721c1&start=0"},
        {"type":"text","info":"We will now present code to demonstrate how this works in memory. The code may be found at pass_by_ref.c (Links to an external site.), and performs the same tasks that were presented in the metaphor video. After the code segment, we will present a sample output run, and then a video explaining the program, as well as drawing out the memory:"},
        {"type":"text","info":"#include <stdio.h>"},
        {"type":"text","info":"void foo( int* x ){"},
        {"type":"text","info":"    fprintf( stdout, \"Working memory (register) address of x in foo            : %p\n\", &x);"},
        {"type":"text","info":"    fprintf( stdout, \"Value of the information inside the register x in foo    : %p\n\", x ); "},
        {"type":"text","info":"    fprintf( stdout, \"Working memory (register) address of de-ferenced x in foo: %p\n\", &*x );"},
        {"type":"text","info":"    fprintf( stdout, \"De-referenced value of x in foo prior to addition        : %d\n\", *x );"},
        {"type":"text","info":"    *x += 2;"},
        {"type":"text","info":"    fprintf( stdout, \"De-referenced value of x in foo after the addition       : %d\n\", *x );"},
        {"type":"text","info":"}"},
        {"type":"text","info":"int main( void ){"},
        {"type":"text","info":"    int x = 4;"},
        {"type":"text","info":"    fprintf( stdout, \"Old x data value in the working memory (register) in main: %d\n\", x);"},
        {"type":"text","info":"    fprintf( stdout, \"Working memory (register) address of x in main           : %p\n\", &x);"},
        {"type":"text","info":"    foo( &x );"},
        {"type":"text","info":"    fprintf( stdout, \"New x data value in the working memory (register) in main: %d\n\", x);"},
        {"type":"text","info":"    return 0;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"Here is the compilation and run"},
        {"type":"text","info":"Old x data value in the working memory (register) in main: 4"},
        {"type":"text","info":"Working memory (register) address of x in main           : 0x7ffc03ec94e4"},
        {"type":"text","info":"Working memory (register) address of x in foo            : 0x7ffc03ec94c8"},
        {"type":"text","info":"Value of the information inside the register x in foo    : 0x7ffc03ec94e4"},
        {"type":"text","info":"Working memory (register) address of de-ferenced x in foo: 0x7ffc03ec94e4"},
        {"type":"text","info":"De-referenced value of x in foo prior to addition        : 4"},
        {"type":"text","info":"De-referenced value of x in foo after the addition       : 6"},
        {"type":"text","info":"New x data value in the working memory (register) in main: 6"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=8ebc0d11-279b-4d23-a612-ae15013ae871&start=0"},
        {"type":"subtitle","info":"Passing Static and Dynamic Arrays by Reference"},
        {"type":"text","info":"In C programs, arrays are passed by reference, since the reference is the base address of the array. So all we have to do in order to pass arrays by reference is pass the value of the base address! Simply put, just pass them by reference the exact way you would define them in main:"},
        {"type":"text","info":"int int_static[]"},
        {"type":"text","info":"int* int_dynamic"},
        {"type":"text","info":"To show the effectiveness, we will modify the static_dynamic.c code to pass both arrays by reference to a function when we print them."},
        {"type":"text","info":"#include <stdio.h>"},
        {"type":"text","info":"#include <stdlib.h>"},
        {"type":"text","info":"void print_arrays( int int_static[], int* int_dynamic, long unsigned int length ){"},
        {"type":"text","info":"    fprintf( stdout, \"Static Memory addresses: %p %p\n\", &int_static, int_static );"},
        {"type":"text","info":"    fprintf( stdout, \"Dynamic Memory addresses: %p %p\n\", &int_dynamic, int_dynamic );"},
        {"type":"text","info":"    long unsigned int iter;"},
        {"type":"text","info":"    for( iter = 0; iter < length; ++iter ){"},
        {"type":"text","info":"        fprintf( stdout, \"int_static[%lu] = %d at %p and int_dynamic[%lu] = %d at %p\n\","},
        {"type":"text","info":"            iter, int_static[iter], &int_static[iter], iter, int_dynamic[iter], &int_dynamic[iter] );"},
        {"type":"text","info":"    }"},
        {"type":"text","info":"}"},
        {"type":"text","info":"int main(){"},
        {"type":"text","info":"    int int_static[] = {10, 20, -19, 34};"},
        {"type":"text","info":"    long unsigned int length = 4;"},
        {"type":"text","info":"    int* int_dynamic = (int *)malloc( length * sizeof(int) );"},
        {"type":"text","info":"    int_dynamic[0] = 10;"},
        {"type":"text","info":"    int_dynamic[1] = 20;"},
        {"type":"text","info":"    int_dynamic[2] = -19;"},
        {"type":"text","info":"    int_dynamic[3] = 34;"},
        {"type":"text","info":"    print_arrays( int_static, int_dynamic, length );"},
        {"type":"text","info":"    // Free dynamically allocated memory"},
        {"type":"text","info":"    free( int_dynamic );"},
        {"type":"text","info":"    return 0;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"And here is the program output:"},
        {"type":"text","info":"Static Memory addresses: 0x7ffc6b561768 0x7ffc6b5617a0"},
        {"type":"text","info":"Dynamic Memory addresses: 0x7ffc6b561760 0x55ac3cf142a0"},
        {"type":"text","info":"int_static[0] = 10 at 0x7ffc6b5617a0 and int_dynamic[0] = 10 at 0x3cf142a0"},
        {"type":"text","info":"int_static[1] = 20 at 0x7ffc6b5617a4 and int_dynamic[1] = 20 at 0x3cf142a4"},
        {"type":"text","info":"int_static[2] = -19 at 0x7ffc6b5617a8 and int_dynamic[2] = -19 at 0x3cf142a8"},
        {"type":"text","info":"int_static[3] = 34 at 0x7ffc6b5617ac and int_dynamic[3] = 34 at 0x3cf142ac"}
       

        ]},




    {"unique_id":"2-2","content":[
        {"type":"subtitle","info":"Pointers to Pointers"}, 
        {"type":"text","info":"In this section, we will describe pointers to pointers. The reason we will cover pointers to pointers is that many advanced data structures we will learn about in this course are pointers to pointers, pointers to structs, or pointers to classes. By introducing and practicing these concepts now, you will be set up for success later in the semester, especially when we cover graphs."},
        {"type":"subtitle","info":"Pointers to Pointers"}, 
        {"type":"text","info":"Sometimes, we need to keep track of arrays of arrays of information. For example, let us consider Pascal's Triangle, a triangular arrangement of numbers that gives the coefficients in the expansion of any binomial expression, such as (x + y)n. The first row is one element with the value 1. The second row contains two elements, both of which contain the value 1. After that, the first and last elements in the row are 1, and the triangle can be filled out from the top by adding together the two numbers just above to the left and right of each position in the triangle."},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/4-1.png') }}"},
        {"type":"text","info":"So how could we represent this in a computing device? Let us presume that we have 6 rows as in the triangle above. We know that the last row requires 6 integers, so we could create 6 arrays with 6 integers. But what do you think an issue with this approach might be?"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/4-2.png') }}"},
        {"type":"text","info":"There is a lot of wasted space in this array of arrays! This approach is an inefficient use of the computer's memory resources. Furthermore, what happens if we are inputting the number of rows in real time? We would need to implement dynamic memory allocation."},
        {"type":"text","info":"So how can we reduce the memory usage while simultaneously ensuring we can allocate memory dynamically? Our solution will be to use pointers to pointers, and then only allocate the amount of memory we need! Here is an example of pointers to pointers drawn out for both Pascal of size 4 and Pascal of size 6, which shows the potential of dynamic memory allocation:"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/4-3.jpeg') }}"},
        {"type":"text","info":"The question becomes how do we allocate pointers to pointers? To understand this, let's revisit how we allocated an array of integers:"},
        {"type":"text","info":"int* int_array = (int *)malloc( array_size * sizeof(int) );"},
        {"type":"text","info":"The (int *) in front of malloc gave context to the void pointer that this is an array of integers"},
        {"type":"text","info":"The array_size is a long unsigned int so we can ensure proper allocation of memory"},
        {"type":"text","info":"The sizeof(int) indicates we need to allocate 32 bits (4 bytes) of memory times for each integer"},
        {"type":"text","info":"The int* int_array is the register containing the base address of the array of integers."},
        {"type":"text","info":"We've also learned that pointers are contained in registers, which means they have physical space. Which means they have a size! Now we will combine these concepts and build a pointer to an array of integer pointers. (In the video after the code segment description, I write the code in C and then draw out what we have completed so far."},
        {"type":"text","info":"int** pascal_array = (int **)malloc( array_size * sizeof( int * ) );"},
        {"type":"text","info":"The (int **) in front of malloc gave context to the void pointer that this is an array of integer pointers"},
        {"type":"text","info":"The array_size is a long unsigned int so we can ensure proper allocation of memory"},
        {"type":"text","info":"The sizeof(int *) indicates we need to allocate 64 bits (4 bytes) for each integer pointer"},
        {"type":"text","info":"The int** int_array is the register containing the base address of the array of integer of integer pointers."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=92efbfa1-c0f1-4691-9d3d-ae16010f5cec&start=0"},
        {"type":"subtitle","info":"Allocating Memory to Pointers of Pointers"}, 
        {"type":"text","info":"The next step is to allocate memory to each individual pointers. I will pass the int** pascal to a function in order to demonstrate the effectiveness of pass by reference, and to promote modularity in programming."},
        {"type":"text","info":"Review: Modularity is breaking down programs into the smallest possible tasks. Using functions to promote modularity is a sign of a strong programmer."},  
        {"type":"text","info":"I will also pass the size of the array with the long unsigned int. Notice in the loop that I allocate"},
        {"type":"text","info":"void alloc_mem( int** pascal, long unsigned int pascal_size ){"},
        {"type":"text","info":"    long unsigned int iter;"},
        {"type":"text","info":"    for( iter = 0; iter < pascal_size; ++iter ){"},
        {"type":"text","info":"        pascal[iter] = (int *)malloc( (iter + 1) * sizeof(int) );"},
        {"type":"text","info":"    }"},
        {"type":"text","info":"}"},
        {"type":"text","info":"In the same vein, I will write another function where I free all the memory allocated to those pointers. This approach ensures we pass valgrind and successfully free all the memory in the computing device. In the video below, I write the code and draw the memory layout of the computing system. I also point out in the video that, whenever I am writing code to structure data with pointers, I ensure I've properly made the malloc and free work properly (i.e. set up the structure) before I design the algorithm (i.e. perform data operations)."},
        {"type":"text","info":"void free_mem( int** pascal, long unsigned int pascal_size  ){"},
        {"type":"text","info":"    long unsigned int iter;"},
        {"type":"text","info":"    for( iter = 0; iter < pascal_size; ++iter ){"},
        {"type":"text","info":"        free ( pascal[iter] );"},
        {"type":"text","info":"    }"},
        {"type":"text","info":"}"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=07aa1614-9006-4433-998b-ae1601184fc5&start=0"},
        {"type":"text","info":"I have included the final solution to setting up and printing the Pascal triangle in the code pascal.c I want you to notice the highlighted line in the valgrind statement. I have asked for 5 lines of Pascal, and the valgrind says I have 6 allocs and 6 frees. Why do you think that is? (Answer after the valgrind statement)"},
        {"type":"text","info":"-bash-4.2$ gcc -Wall -Wconversion -Werror pascal.c -o pascal "},
        {"type":"text","info":"-bash-4.2$ valgrind --leak-check=full ./pascal "},
        {"type":"text","info":"==27735== Memcheck, a memory error detector "},
        {"type":"text","info":"==27735== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al. "},
        {"type":"text","info":"==27735== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info "},
        {"type":"text","info":"==27735== Command: ./pascal "},
        {"type":"text","info":"==27735== "},
        {"type":"text","info":"Enter the size of the Pascal Triangle: 5 "},
        {"type":"text","info":"1 "},
        {"type":"text","info":"1 1 "},
        {"type":"text","info":"1 2 1 "},
        {"type":"text","info":"1 3 3 1 "},
        {"type":"text","info":"1 4 6 4 1 "},
        {"type":"text","info":"==27735== "},
        {"type":"text","info":"==27735== HEAP SUMMARY: "},
        {"type":"text","info":"==27735== in use at exit: 0 bytes in 0 blocks "},
        {"type":"text","info":" ==27735== total heap usage: 6 allocs, 6 frees, 100 bytes allocated "},
        {"type":"text","info":"==27735== "},
        {"type":"text","info":"==27735== All heap blocks were freed -- no leaks are possible "},
        {"type":"text","info":"==27735== "},
        {"type":"text","info":"==27735== For lists of detected and suppressed errors, rerun with: -s "},
        {"type":"text","info":"==27735== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)"},
        {"type":"text","info":"The reason is because we allocate the pointer to the pointers (1 alloc), and then allocate 5 pointer arrays (5 allocs), which gives us 6. Furthermore, each pointer in the int* array is 64 bits (8 bytes), so the pointer to pointers array takes up 5*8 bytes = 40 bytes. Then, here is how much memory each array contains:"},
        {"type":"text","info":"pascal[0] = 1 integer = 4 bytes"},
        {"type":"text","info":"pascal[1] = 2 integers = 8 bytes"},
        {"type":"text","info":"pascal[2] = 3 integers = 12 bytes"},
        {"type":"text","info":"pascal[3] = 4 integers = 16 bytes"},
        {"type":"text","info":"pascal[4] = 5 integers = 20 bytes"},
        {"type":"text","info":"Summing the memory together, we get 40 + 4 + 8 + 12 + 16 + 20, which is 100 bytes, precisely the number that valgrind gave us."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=2254b32c-65ed-447e-bea5-ae160122ec6f&start=0"},
        
        
        
        {"type":"subtitle","info":"The Challenges of Floats and Doubles"},
        {"type":"text","info":"In this section, we will discuss an important concept in programming: the difference between accuracy and precision."},
        {"type":"subtitle","info":"When 0.1 Does Not Equal 0.1: Doubles and Floats are Precise Not Accurate"},
        {"type":"text","info":"Consider this simple C code segment double.c What do you expect to happen?"},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec04_Reading/double.c"},
        {"type":"text","info":"Likely, you guessed that it will print that the values match, and that they will print the values. But here is the actual output. It turns out that they don't match! But why does 0.1 not equal 0.1? Look at the output line I've highlighted as a hint:"},
        {"type":"text","info":"-bash-4.2$ gcc -Wall -Wconversion -Werror double.c -o double "},
        {"type":"text","info":"-bash-4.2$ ./double "},
        {"type":"text","info":"0.100000 0.100000 "},
        {"type":"text","info":"They do not match! "},
        {"type":"text","info":"0x1.9999999999998p-4 0x1.999999999999ap-4 "},
        {"type":"text","info":"0.09999999999999997779554 0.10000000000000000555112 "},
        {"type":"text","info":"It turns out that doubles are double precision floating point values. Meaning they are precise approximations of the number. The line highlighted in red is a representation of the actual physical value stored in the register (printed with %la). Look at the last hex number of each. One is 8 and the other is a. Here are the corresponding binary values"},
        {"type":"text","info":"8 = 1000"},
        {"type":"text","info":"a = 1010"},
        {"type":"text","info":"It turns out that doubles are double precision floating point values. Meaning they are precise approximations of the number. The line highlighted in red is a representation of the actual physical value stored in the register (printed with %la). Look at the last hex number of each. One is 8 and the other is a. Here are the corresponding binary values"},
        {"type":"text","info":"8 = 1000"},
        {"type":"text","info":"a = 1010"},
        {"type":"text","info":"They are physically different values. So why does the first line print both values as 0.1000000? Because the linux system is printing their output approximately to 6 decimal places by default. If you look at the last line of code, I print the values to 23 decimal places of precision (%.23lf). You see the different in the precise values in the last line of the output."},
        {"type":"text","info":"An important takeaway is that floats and doubles are precise, but not accurate."},
        {"type":"subtitle","info":"Case Study: The ESA Ariane 5 Disaster"},
        {"type":"text","info":"I will present a seeimgly simple C program using the Production Quality Compilation Flags "},
        {"type":"text","info":"#include"},
        {"type":"text","info":"int main(){"},
        {"type":"text","info":" float the_float = 3.1415926;"},
        {"type":"text","info":" fprintf( stdout, \"%f\n\", the_float );"},
        {"type":"text","info":" return 0;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"Using normal compilation flags, this program will compile without issue. However, using the PQC flags in this course, this code will not compile! Read the compiler error, and see if you can figure out why..."},
        {"type":"text","info":"-bash-4.2$ gcc -Wall -Wconversion -Werror float_error.c -o float_error "},
        {"type":"text","info":"float_error.c: In function 'main': "},
        {"type":"text","info":"float_error.c:5:2: error: conversion to 'float' alters 'double' constant value [-Werror=conversion] "},
        {"type":"text","info":"float the_float = 3.1415926; "},
        {"type":"text","info":"The computer is defining this issue as a type mismatch because 3.1415926 is a double. And this is being enforced by the -Wconversion flag."},
        {"type":"text","info":"The logical follow up question is: Why would this be important? It turns out the C compiler initializes decimal values to double! But we are putting it in a float"},
        {"type":"text","info":"float = Single Precision Floating Point"},
        {"type":"text","info":"32 bits!"},
        {"type":"text","info":"double = Double Precision Floating Point"},
        {"type":"text","info":"64 bits"},
        {"type":"text","info":"Trying to put a 64 bit value in a 32 bit value"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/4-4.png') }}"},
        {"type":"text","info":"So now let's run the same code, but with the decimal casted to float "},
        {"type":"text","info":"float the_float = (float)3.1415926;"},
        {"type":"text","info":"This code tell the C compiler to initialize 3.1415926 to a 32-bit float, not a double, and and we will see that it compiles"},
        {"type":"text","info":"Most Programmer just don't mess with and always choose double… but why the big fuss?"},
        {"type":"text","info":"To see why, let's evaluate a different code segment (float_ariane_5.c ) In this code, we save a large double into a float. In fact, the number is too large to store in the float, and we get overflow if you compile without the PQC flags."},
        {"type":"text","info":"#include <stdio.h>"},
        {"type":"text","info":"int main( void ){"},
        {"type":"text","info":"    // Largest number that can be save in a float"},
        {"type":"text","info":"    double the_double = 0x1.fffffep+127;"},
        {"type":"text","info":"    float the_float = the_double;"},
        {"type":"text","info":"    fprintf( stdout, \"The double and the float = %lf %f\n\", the_double, the_float );"},
        {"type":"text","info":"    fprintf( stdout, \"Now we add 1 to the_double and try to save to the float!\n\" );"},
        {"type":"text","info":"    // One bit greater than can be held in a float"},
        {"type":"text","info":"    the_double = 0x1.ffffffp+127;"},
        {"type":"text","info":"    the_float = the_double;    // Ariane 5 Error!"},
        {"type":"text","info":"    fprintf( stdout, \"The double and the float = %lf %f\n\", the_double, the_float );"},
        {"type":"text","info":"    return 0;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"Here is error with the PQC flags:"},
        {"type":"text","info":"-bash-4.2$ gcc -Wall -Wconversion -Wextra float_ariane_5.c -o float_ariane_5 "},
        {"type":"text","info":"float_ariane_5.c: In function 'main': "},
        {"type":"text","info":"float_ariane_5.c:8:2: warning: conversion to 'float' from 'double' may alter its value [-Wconversion]"}, 
        {"type":"text","info":" float the_float = the_double; "},
        {"type":"text","info":" ^"},
        {"type":"text","info":"float_ariane_5.c:16:2: warning: conversion to 'float' from 'double' may alter its value [-Wconversion] "},
        {"type":"text","info":" the_float = the_double; // Ariane 5 Error! "},
        {"type":"text","info":"And here is the run without the PQC flags. Notice the inf in the output meaning the float overflowed:"},
        {"type":"text","info":"-bash-4.2$ gcc float_ariane_5.c -o float_ariane_5 "},
        {"type":"text","info":"-bash-4.2$ ./float_ariane_5 "},
        {"type":"text","info":"The double and the float = 340282346638528859811704183484516925440.000000 340282346638528859811704183484516925440.000000 "},
        {"type":"text","info":"Now we add 1 to the_double and try to save to the float! "},
        {"type":"text","info":"The double and the float = 340282356779733661637539395458142568448.000000 inf "},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=60fb8831-2d3d-425d-97db-ae16012e215b&start=0"},
        {"type":"text","info":"So why the big fuss? Consider the Case Study of the Ariane 5 European Space Agency Rocket. In this rocket, sensors measured rocket speed and angle, and the trajectory for Ariane 4 and 5 were significantly different. So there was an error that occurred in the sensors that was not anticipated in Ariane 4, but should have been tested in Ariane 5."},
        {"type":"text","info":"Error checking code tried to pass a 64-bit double into a 32-bit float"},
        {"type":"text","info":"Stored last 32 bits only => Filled with all zeros"},
        {"type":"text","info":"The sensor believed the rocket was 90o off course"},
        {"type":"text","info":"The rocket's self-destruct sequence was initiated"},
        {"type":"text","info":"This error resulted from a similar error to the one that I coded in float_ariane_5.c!"},

        {"type":"subtitle","info":"C Structs"},
        {"type":"text","info":"Up to this point, we have allocated memory for homogeneous structures of data (such as integer arrays). But that is not how life works. Consider information for a student:"},
        {"type":"text","info":"Name"},
        {"type":"text","info":"Age"},
        {"type":"text","info":"GPA"},
        {"type":"text","info":"Dorm Room"},
        {"type":"text","info":"Address"},
        {"type":"text","info":"Courses"},
        {"type":"text","info":"All of this information is conveyed in different ways, meaning we need different types of data to represent one student! We can represent a Data Structure using a Struct"},
        {"type":"subititle","info":"C Structs"},
        {"type":"text","info":"Struct: derived data type composed of members that are each fundamental or derived data types"},
        {"type":"text","info":"Helpful for clusters of information"},
        {"type":"text","info":"Struct address is the same as the address of the first variable in the struct, next variables are consecutive in memory"},
        {"type":"text","info":"typedef: keyword that allows you to define your own data type (only needed in C)"},
        {"type":"text","info":"Notice how I have defined the struct as simple both before and after the braces. This ensure we can allocate space when we define the struct. Furthermore, I have put the keyword typedef so we do not need to use the struct keyword in main."},
        {"type":"text","info":"Simply put: if you define your C structs in this format, this approach will make your program process much simpler when you implement them."},
        {"type":"text","info":"typedef struct simple{"},
        {"type":"text","info":"     int the_int;"},
        {"type":"text","info":"     double the_double;"},
        {"type":"text","info":"     float the_float;"},
        {"type":"text","info":"} simple;"},
        {"type":"subtitle","info":"Static C Structs"},
        {"type":"text","info":"In order to access a static C struct, we use a period to access the element"},
        {"type":"text","info":"simple_str.the_float"},
        {"type":"text","info":"We will now build a C struct on the stack. Recall that when we build data on the stack, that we can access the data in real time akin to how we access registers. In this code segment, I have also printed out the addresses of the struct using the &. "},
        {"type":"text","info":"#include <stdio.h>"},
        {"type":"text","info":"// struct definition"},
        {"type":"text","info":"typedef struct simple{"},
        {"type":"text","info":"    int the_int;"},
        {"type":"text","info":"    float the_float;"},
        {"type":"text","info":"    double the_double;"},
        {"type":"text","info":"} simple;"},
        {"type":"text","info":"int main(){"},
        {"type":"text","info":"      //create a struct on the stack"},
        {"type":"text","info":"      simple simple_str = {-14, (float)22.7, 9.2 };"},
        {"type":"text","info":"      fprintf( stdout, \"%p\n\", &simple_str);"},
        {"type":"text","info":"      fprintf( stdout, \"%d %p\n\", simple_str.the_int, &(simple_str.the_int));"},
        {"type":"text","info":"      fprintf( stdout, \"%f %p\n\", simple_str.the_float, &(simple_str.the_float));"},
        {"type":"text","info":"      fprintf( stdout, \"%lf %p\n\", simple_str.the_double, &(simple_str.the_double));"},
        {"type":"text","info":"      return 0;"},
        {"type":"text","info":"}"},
        {"type":"text","info":"And here is the output"},
        {"type":"text","info":"-bash-4.2$ gcc -Wall -Wextra -Wconversion -Werror -std=c11 struct_static.c -o struct_static "},
        {"type":"text","info":"-bash-4.2$ ./struct_static "},
        {"type":"text","info":"0x7ffc19fb20b0 "},
        {"type":"text","info":"-14 0x7ffc19fb20b0 "},
        {"type":"text","info":"22.700001 0x7ffc19fb20b4 "},
        {"type":"text","info":"9.200000 0x7ffc19fb20b8 "},
        {"type":"text","info":" In the video, I use the output addresses to "},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=3f4b13f2-13a5-452f-95d2-ae16014fb21b&start=0"},
        {"type":"subtitle","info":"Dynamic C Structs"},
        {"type":"text","info":"In order to allocate a C struct on the Heap, we need to create a pointer, just like we've done with everything else. "},
        {"type":"text","info":"let's revisit how we allocated an array of integers:"},
        {"type":"text","info":"simple* dynamic_struct = (simple *)malloc( sizeof(simple) );"},
        {"type":"text","info":"The (simple *) in front of malloc gave context to the void pointer that this is a pointer to a struct on the Heap"},
        {"type":"text","info":"The sizeof(simple) indicates we need to allocate 128 bits ( 32 + 32 + 64 bytes) of memory times for the int, float, and double"},
        {"type":"text","info":"The simple* dynamic_struct is the register containing the base address of the array of integers."},
        {"type":"text","info":"In order to access a struct pointer, we use the -> in the place where we would use a . in a statically allocated struct"},
        {"type":"text","info":"dynamic_struct->the_int = 45;"},
        {"type":"text","info":"In the file struct_dynamic.c, we have allocated and printed a struct on the Heap, and we have properly freed the memory."},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec04_Reading/struct_dynamic.c"},
        {"type":"text","info":"And here is the output:"},
        {"type":"text","info":"-bash-4.2$ gcc -Wall -Wextra -Wconversion -Werror -std=c11 struct_dynamic.c -o struct_dynamic "},
        {"type":"text","info":"-bash-4.2$ ./struct_dynamic "},
        {"type":"text","info":"0x7ffe07036178 0x15e1010 "},
        {"type":"text","info":"45 0x15e1010 "},
        {"type":"text","info":"-1.100000 0x15e1014 "},
        {"type":"text","info":"45.100000 0x15e1018"},
        {"type":"text","info":" In the video below, I show the output and draw the structure of the data based on the solution:"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=cd924e49-3e51-4041-a74a-ae1601543967&start=0"} 
        ]},



    {"unique_id":"2-3","content":[
        {"type":"subtitle","info":"Recursion"},       
        {"type":"text","info":"In this section, we will describe recursion. The reason we will review recursion early in this course is because many data structures programming techniques, including traversals of lists and trees, as well as sorting algorithms, are strengthened through the use of recursion. The second-most commonly cited concept that students say they struggled to understand is recursion. (The most commonly cited concept is pointers)."},
        {"type":"subtitle","info":"Intro to Recursion"},       
        {"type":"text","info":"Let's compare recursion with an art concept known as the Droste Effect. In this painting by MC Escher, \"Paint Gallery\", the painting has a "},
        {"type":"video","info":"https://www.youtube.com/watch?v=ZMh347hPvzY"},
        {"type":"text","info":"Recursion: The use of a procedure, subroutine, function, or algorithm"},
        {"type":"text","info":"calls itself one or more times"},
        {"type":"text","info":"until a specified condition is met"},
        {"type":"text","info":"the rest of each repetition is processed from last to first."},
        {"type":"text","info":"It is useful to think of the solution to a recursive problem as the elements in a set of solutions."},
        {"type":"text","info":"We will learn an application of recursion to improve computing performance called Dynamic Programming in section 5.2."},
        {"type":"subtitle","info":"Advantages and Disadvantages of Recursion"},
        {"type":"text","info":"Main Advantage:"},
        {"type":"text","info":"For some problems, recursion is much simpler to program"},
        {"type":"text","info":"Implementation and exploration of Binary Trees, Sorting algorithms"},
        {"type":"text","info":"Defining objects that have a repeated similar structural form in C++"},
        {"type":"text","info":"Main Disadvantage:"},
        {"type":"text","info":"Every recursive call is saved to the stack"},
        {"type":"text","info":"Potential for Stack Overflow"},
        {"type":"subtitle","info":"A Fundamental Example: Factorial!"},
        {"type":"text","info":"Consider the Factorial:"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/5-1.png') }}"},
        {"type":"text","info":"Similar to a summation, we can use repetitive multiplications to find a solution."},
        {"type":"text","info":"f(n) = n!"},
        {"type":"text","info":"Ex: f(5) = 5 * 4 * 3 * 2 * 1 = 120"},       
        {"type":"text","info":"Think about this problem as f(n) = n * (n - 1)!, and since f(n - 1) = (n - 1)!,"},       
        {"type":"text","info":"Metaphor: Think of recursive solutions as a Russian Nesting Doll. The doll is not complete without all the smaller dolls inside. Similarly, the answer to 5! is not possible without first finding the answer to 4!, 3!, 2!, 1! and 0!. Any computing problem with dependencies like these lend themselves well to recursion (and eventually dynamic programming)"},       
        {"type":"image","info":"{{ url_for('static', filename='contentImages/5-2.png') }}"},
        {"type":"text","info":"Note: The proof below is a quick refresher on why we may claim that 0! is equal to 1. This is essential to understand for this problem, as we are able to design an efficient base case (which I will describe in a moment)."},       
        {"type":"image","info":"{{ url_for('static', filename='contentImages/5-3.png') }}"},
        {"type":"subtitle","info":"Base and Recursive Cases"},       
        {"type":"text","info":"Base Case: Non-recursively defined values that limit or cut off recursion"},
        {"type":"text","info":"Recursive Step: Recursive definition or reapplication of function on new subset."},
        {"type":"text","info":"The next thing to do is think about the base case, what is the simplest input that the function can just return without doing many operations ? In this case,   n = 0, the function just returns 1."},
        {"type":"text","info":"Let's consider a code example (which may be found at fact.c (Links to an external site.)), which has the base and recursive cases for the Factorial. In this example, i == 0 is the base case, and the recursive case is return i * factorial(i-1);"},
        {"type":"text","info":"unsigned int factorial(unsigned int i){"},
        {"type":"text","info":"  if(i == 0)"},
        {"type":"text","info":"    return 1;"},
        {"type":"text","info":"  return i * factorial(i-1);"},
        {"type":"text","info":"}"},
        {"type":"subtitle","info":"Simple Recursive Trace Example"},
        {"type":"text","info":"A simple way of determining the operation of a recursive function is tracing out its operation. In the video below, I show how the factorial operation works recursively."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=d31228df-e0c3-45df-a5e1-ae18012e29dd&start=0"},
        {"type":"subtitle","info":"Recursion on the Stack"},
        {"type":"text","info":"Let's revisit our metaphor of computing as the mechanization of thought in order to help you better picture recursion in your mind. Since recursive calls are function calls, each call gets its own set of registers. We see in the video that the recursive calls are allocated their own set of registers (octopus), and then when we are done with them, the memory in the registers and stack is freed."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=c7ec4094-a738-4f82-b167-ae18012f65e9&start=0"},
        {"type":"text","info":"Now let's take that metaphor and correlate it to the actual physical device. We run the same recursive function, but now we see that the stack and registers correlates with C code."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=fb1d4165-1abe-49ad-a47f-ae180128a8aa&start=0"},
        {"type":"text","info":"Helping you Visualize: A more complicated recursive trace:"},
        {"type":"text","info":"In this example, we will walk through the code at trace1.c and trace2.c to help you visualize tracking steps in recursive functions. There is one line of code that is different, but this difference is an example of how to trace recursive functions properly. Note: This video is a good example of how I will expect you to perform a recursive trace problem on Exam 1."},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec05_Reading/trace1.c"},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec05_Reading/trace2.c"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=6861a4ed-0c6b-4a1f-accd-ae180155ac14&start=0"},
        {"type":"subtitle","info":"Binary Recursion"},
        {"type":"text","info":"We define binary recursion as a recursive function that calls a recursive function twice. There are several problems where making precisely two calls to the recursive function is advantageous, such as the divide-and-conquer techniques we will encounter in binary search trees."},
        {"type":"text","info":"Consider as an example the Fibonacci sequence"},
        {"type":"text","info":"Recursive Case: Fib(n) = Fib(n-1) + Fib(n-2)"},
        {"type":"text","info":"Base cases: Fib(0) = 1, Fib(1) = 1"},
        {"type":"text","info":"Here is the code fib.c and a video where I show the recursive trace of the program."},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec05_Reading/fib.c"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=df85ce13-4be4-4732-bc80-ae1801413598&start=0"},
       
       
        {"type":"subtitle","info":"Introduction to Dynamic Programming"},
        {"type":"text","info":"You may have noticed an issue with the Fibonacci sequence code I presented in 5.1. We did a lot of redundant work. How much? Well, consider the chart below, which details the number of recursive function calls we would need in order to calculate the nth Fibonacci number. We would need forty billion calls to find the 50th Fibonacci number. "},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/5-4.png') }}"},
        {"type":"text","info":"So if this is true, why even use recursion at all when we can use while loops? It turns out we can significantly improve the number of calls, and strengthen our understanding of effective programming in the process, by learning about dynamic programming and memoization."},
        {"type":"text","info":"Note: We will learn an introduction to dynamic programming in this course. In the Algorithms course, you will learn mathematical and theoretical applications of dynamic programming. In this course, you will gain a fundamental understanding of dynamic programming in order to better understand effective structuring of data in a computing device. The optional reading for this lecture on the Lecture Notes page is an opportunity for those of you who want to push yourself further than the scope of this course."},
        {"type":"subtitle","info":"Dynamic Programming"},
        {"type":"text","info":"Dynamic programming combines the correctness of complete search and the efficiency of greedy algorithms:"},
        {"type":"text","info":"1. Simplified: Caching results of subproblems in memory to avoid repeated computation."},
        {"type":"text","info":"2. Advanced: A method for efficiently solving a particular set of search and optimization problems where greedy algorithms or brute-force would take much too long."},
        {"type":"text","info":"Generally, we can use dynamic programming to solve problems that require:"},
        {"type":"text","info":"1. Finding an optimal solution - Find a solution that is as large or small as possible."},
        {"type":"text","info":"2. Count the number of solutions - Calculate the total number of possible solutions."},
        {"type":"subtitle","info":"Dynamic Programming, Explained to a Four Year Old"},
        {"type":"text","info":"A mom writes down \"1+1+1+1+1+1+1+1 =\" on a sheet of paper*. \"What's that equal to?\""},
        {"type":"text","info":"Her son counts it out and says \"Eight!\""},
        {"type":"text","info":"The mom then writes down another \"1+\" on the left*. \"What about that?\""},
        {"type":"text","info":"Her son quickly replies \"Nine!\""},
        {"type":"text","info":"\"How'd you know it was nine so fast?\""},
        {"type":"text","info":"\"You just added one more\""},
        {"type":"text","info":"\"So you didn't need to recount because you remembered there were eight! \""},
        {"type":"text","info":"Dynamic Programming is just a fancy way to say 'remembering stuff to save time later'"},
        {"type":"subtitle","info":"Caching: Memoizing Computation"},
        {"type":"text","info":"In a recursive algorithm such as complete search or backtracking, we will sometimes repeat a subproblem.  To avoid this unnecessary duplicate computation:"},
        {"type":"text","info":"Identify these overlapping subproblems"},
        {"type":"text","info":"Cache or memoize the previous results in lookup table and check that before computing."},
        {"type":"text","info":"In some problems, the optimal solution can be constructed efficiently from optimal solutions to its subproblems.  These problems usually look something like this:"},
        {"type":"text","info":"1. Let's say we have a collection of objects called A."},
        {"type":"text","info":"2. For each object o in A we have a “cost,” cost(o)"},
        {"type":"text","info":"3. Find the subset of A with the maximum (or minimum) cost, perhaps subject to certain constraints."},
        {"type":"text","info":"Rather than generate all possible subsets O(2n), build a table where at each step we know the best solution thus far."},
        {"type":"text","info":"1. Identify rows and columns: Rows and columns must be discrete units and usually involve the subsets in question."},
        {"type":"text","info":"2. Define recursive relationships: How does one square depend on another?"},
        {"type":"text","info":"Reconstruct solution: Use built tables to identify and generate final solution."},
        {"type":"text","info":"So how can we improve the operation of the Fibonacci sequence? We can use an array to store the previous solutions. In the video below, I walk through the process of making calls to the array. You will see the benefit of looking up previous solutions in the Fibonacci sequence, which is that we will eliminate redundant recursive calls."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=95f26e46-3655-411a-ac77-ae1801469054&start=0"},
        {"type":"text","info":"The code used to implement the memoized version of the Fibonacci sequence may be found at fib_memo.c, and the code is visible below. Note how we see if the values in the array have been initialized (i.e. not equal to 0) before we make a recursive call at all! If the value exists, we simply return it. Otherwise, we make the recursive call and update the array."},
        {"type":"text","info":"Combining Concepts: The amount of memory used by the program is reduced significantly because we pass the arrays by reference instead of making a copy of the entire array every call."},
        {"type":"text","info":"double Fibonacci( int fib_num, double* fib_nums ){"},
        {"type":"text","info":"    if( fib_nums[fib_num] != 0 )"},
        {"type":"text","info":"        return fib_nums[fib_num];"},
        {"type":"text","info":"    if( fib_num == 0 ){"},
        {"type":"text","info":"       fib_nums[0] = 1;"},
        {"type":"text","info":"    }"},
        {"type":"text","info":"    else if( fib_num == 1 ){"},
        {"type":"text","info":"        fib_nums[1] = 1;"},
        {"type":"text","info":"    }"},
        {"type":"text","info":"    else{ "},
        {"type":"text","info":"        fib_nums[fib_num] = Fibonacci( fib_num - 1, fib_nums ) + Fibonacci( fib_num - 2, fib_nums );"},
        {"type":"text","info":"    }"},
        {"type":"text","info":"    return fib_nums[fib_num];"},
        {"type":"text","info":"}"},
        {"type":"text","info":"Now we can compare the number of calls required to calculate the nth Fibonacci number. You can see that we have significantly improved our programming efficiency. In the case of the 50th fibonacci number, we've reduced the number of calls from forty billion down to 99."},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/5-5.png') }}"}

        ]},



    {"unique_id":"2-4","content":[
        {"type":"subtitle","info":"Sorting Introduction"},
        {"type":"text","info":"Sorting is the process of rearranging a sequence of objects so as to put them in some logical order. Sorting plays a major role in commercial data processing and in modern scientific computing. Applications abound in transaction processing, combinatorial optimization, astrophysics, molecular dynamics, linguistics, genomics, weather prediction, and many other fields. "},
        {"type":"subtitle","info":"Sorting Definitions and Models"},
        {"type":"text","info":"An ordering relation < for keys a, b, and c has the following properties:"},
        {"type":"text","info":"Law of Trichotomy: Exactly one of a < b, a = b, b < a is true."},
        {"type":"text","info":"Law of Transitivity: If a < b, and b < c, then a < c."},
        {"type":"text","info":"An ordering relation with the properties above is also known as a “total order”."},
        {"type":"text","info":"A sort is a permutation (re-arrangement) of a sequence of elements that puts the keys into non-decreasing order relative to a given ordering relation."},
        {"type":"text","info":"x1 ≤ x2 ≤ x3≤ ...≤ xN"},
        {"type":"text","info":"Our primary concern is rearranging arrays of items where each item contains a key. The objective is to rearrange the items such that their keys are in ascending order."},
        {"type":"text","info":"Sorting cost model. When studying sorting algorithms, we count compares and exchanges. For algorithms that do not use exchanges, we count array accesses."},
        {"type":"text","info":"Extra memory. The sorting algorithms we consider divide into two basic types: those that sort in place (no extra memory except perhaps for a small function-call stack or a constant number of instance variables), and those that need enough extra memory to hold another copy of the array to be sorted."},
        {"type":"text","info":"In this lecture, we will focus on sorting in place, with an emphasis on using recursion to improve the sorting operations."},
        {"type":"subtitle","info":"Elementary Sorting - Selection Sort"},
        {"type":"text","info":"Suppose we want to sort a one-dimensional array of integers. One of the simpler sorting algorithms"},
        {"type":"text","info":"Find smallest item."},
        {"type":"text","info":"Swap this item to the front and 'fix' it."},
        {"type":"text","info":"Repeat for unfixed items until all items are fixed."},
        {"type":"text","info":"Example: Consider the following array: 32 15 2 17 19 26 41 17 17"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=71324d58-fd4e-4989-b881-ae1801577d5f&start=0"},
        {"type":"text","info":"Here is a visualization aid:"},
        {"type":"code","info":"https://www.hackerearth.com/practice/algorithms/sorting/selection-sort/visualize/"},
        {"type":"subtitle","info":"Our next improvement - Insertion Sort"},
        {"type":"text","info":"Insertion Sort is our first improvement over Selection Sort. Instead of searching the entire array for the smallest element and then moving it, we select a location and then move the data at that location to the left until it is no longer smaller than the data at the previous array location."},
        {"type":"text","info":"We split the array into a sorted part and an unsorted part."},
        {"type":"text","info":"So initially, the value is unsorted, so you begin at array element 0."},
        {"type":"text","info":"The sorted part will go from the beginning of the array to some index, and the rest of the array will form the unsorted part."},
        {"type":"text","info":"We start by saying that only the first element forms the sorted part."},
        {"type":"text","info":"In each step, we take away one element of the unsorted portion of the array and insert it in its place in the sorted part of the array. This increases the length of the sorted part of the array by one."},
        {"type":"text","info":"We are done after n - 1 steps because we increase the length of the sorted part of the array by 1"},
        {"type":"text","info":"Once the length of the sorted part of the array is n, we know that the array is sorted."},
        {"type":"text","info":"Consider the following example: 22 17 10 84 99 7 36 8 15. The video shows the process for Insertion Sort"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=b0600a10-1bc8-42c0-8342-ae1801598da4&start=0"},
        {"type":"text","info":"Here is a visualization aid:"},
        {"type":"code","info":"https://www.hackerearth.com/practice/algorithms/sorting/insertion-sort/visualize/"},
        {"type":"text","info":"I have provided C code for Insertion Sort:"},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec06_Reading/insert_sort.c"},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec06_Reading/insert_sort.h"},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec06_Reading/run_insert.c"},


        {"type":"subtitle","info":"Merge Sort"},
        {"type":"text","info":"The major challenge with an Insertion Sort is that we have a worst case scenario with we have to iterate through all the elements n2 times (specifically, in the case where they are sorted in the exact opposite order."},
        {"type":"text","info":"We can use recursion to remove the dependency of ordering on the efficiency of the sorting algorithm. "},
        {"type":"subtitle","info":"Merge Sort - Using Binary Recursion to Sort"},
        {"type":"text","info":"The algorithms that we consider in this section is based on a simple operation known as merging: combining two ordered arrays to make one larger ordered array. "},
        {"type":"text","info":"The main idea of merge sort is that we recursively divide the array in half. Once we get to the base case, where the subarray length is 1, then we sort the subarrays as we recombine them recursively."},
        {"type":"text","info":"Base Case:"},
        {"type":"text","info":"If the length of the array is 1"},
        {"type":"text","info":"The singular element is the largest element"},
        {"type":"text","info":"Sorted array = array[0];"},
        {"type":"text","info":"Recursive Case:"},
        {"type":"text","info":"The sorted array sorts the two arrays and returns one array"},
        {"type":"text","info":"An Example Sort: In this video, I will show an example of Merge Sort, with an emphasis on how the algorithm proceeds through the machine recursively. "},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=c4805861-a3e7-4fe2-8bf3-ae1900ea8be8&start=0"},
        {"type":"text","info":"Here is a visualization aid:"},
        {"type":"code","info":"https://www.hackerearth.com/practice/algorithms/sorting/merge-sort/visualize/"},
        {"type":"subtitle","info":"Programming Merge Sort"},
        {"type":"text","info":"I will present my process for implementing Merge Sort in C code. (In the in-class lecture, I will begin by reviewing  this code and taking questions.) While you read this description of the code, I want you to observe the process of writing the code. When I write large programs, I often split them up into several steps in order to produce benchmarks for testing."},
        {"type":"text","info":"Step 1: Setting up the arrays as test cases."},
        {"type":"text","info":"In merge1.c, I set up two arrays to run the algorithm. I purposely selected arrays of two different lengths (odd and even) because I want to test the splitting process with odd and even lengths."},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec06_Reading/merge1.c"},
        {"type":"subtitle","info":"Step 2: Initial Recursive Call"},
        {"type":"text","info":"In my next step, I designed the recursive call steps before I perform the swaps. The merge function in merge2.c will print the indices of the recursive splits."},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec06_Reading/merge2.c"},
        {"type":"text","info":"The base case is the if statement max > min + 1"},
        {"type":"text","info":"For each call, we recursively call the left by going from min to (min + max)/2"},
        {"type":"text","info":"Then, we make the right call by going from (min+max)/2 + 1 to max"},
        {"type":"text","info":"The video below shows an animation of how this code recursively splits the arrays."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=9a696784-4169-40e7-ab68-ae1901064fb0&start=0"},
        {"type":"subtitle","info":"Step 3: The cases when min == max and when min == max - 1"},
        {"type":"text","info":"In my next step, I designed the cases where min == max (when the indices are identical) and when they are separated by 1."},
        {"type":"text","info":"I also have a && case where array[max] < array[min], which means the value to the right is larger than the value to the left. You can see the in merge3.c"},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec06_Reading/merge3.c"},
        {"type":"text","info":" The video below shows an animation of how this code swaps the indices at this stage. Note that the algorithm is not completed. We will complete the final merge in step 4."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=eb5a96e1-1b3e-4c60-b729-ae190108a43f&start=0"},
        {"type":"subtitle","info":"Step 4: Merging arrays when max > min + 1"},
        {"type":"text","info":"In the final step, we will iterate between the two sub arrays. These sub arrays are"},
        {"type":"text","info":"min to (min + max)/2"},
        {"type":"text","info":"(min + max)/2 + 1 to max"},
        {"type":"text","info":"We will create two \"pointers\" (which are actually just the indices of the location, start1 and start2). I also print out the subarray so you can see the stages if you choose to use this code to aid your studies."},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/5-6.png') }}"},
        {"type":"text","info":"Next, I will create a temporary array where I will store the elements we are swapping. I will also create an iterator (arrayIter) to keep track of all the elements. We will update the location of the temp array based on which value in the subarray is larger, and then move those pointers as appropriate. (I have a video after the code segments to help you visualize this process)."},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/5-7.png') }}"},
        {"type":"text","info":"Next, I check to see if we have reached the end of the subarrays and update the values. Then I overwrite the array passed by reference with the sorted values."},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/5-8.png') }}"},
        {"type":"text","info":"Finally, I print the sorted subarray so you can see the intermediate steps."},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/5-9.png') }}"},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=cb2ac3da-a019-4b92-a6f7-ae19010d633b&start=0"},
        {"type":"subtitle","info":"Core Ideas Review"},
        {"type":"text","info":"Selection sort: Find the smallest item and put it at the front"},
        {"type":"text","info":"Insertion sort: Figure out where to insert the current item."},
        {"type":"text","info":"Merge sort: Merge two sorted halves into one sorted whole."},


        {"type":"subtitle","info":" Quick Sort"},
        {"type":"text","info":"Improving upon Merge Sort"},
        {"type":"text","info":"Merge Sort is a good algorithm for data structures students to study because they get good practice with recursion and pass by reference of arrays. But we can do better!"},
        {"type":"text","info":"Here is a motivating example. suppose we do the following:"},
        {"type":"text","info":"Read 1,000,000 integers from a file into an array of length 1,000,000."},
        {"type":"text","info":"Merge Sort these integers."},
        {"type":"text","info":"Select one integer randomly and change it."},
        {"type":"text","info":"Sort using algorithm X of your choice."},
        {"type":"text","info":"In the worst case, we have 999,999 inversions."},
        {"type":"text","info":"On arrays with a small number of inversions, insertion sort is extremely fast."},
        {"type":"text","info":"One exchange per inversion (and number of comparisons is similar). "},
        {"type":"text","info":"One exchange per inversion (and number of comparisons is similar). "},
        {"type":"text","info":"Less obvious: For small arrays (N < 15 or so), insertion sort is fastest."},
        {"type":"text","info":"More of an empirical fact than a theoretical one."},
        {"type":"text","info":"Theoretical analysis beyond scope of the course."},
        {"type":"text","info":"Rough idea: Divide and conquer algorithms like Merge Sort spends too much time dividing, but insertion sort goes straight to the conquest."},
        {"type":"text","info":"So the question we should be asking is this: is there a way we can gain the benefits of the average case for Merge Sort's divide and conquer approach while gaining the benefits of Insertion Sort's inversion processes?"},
        {"type":"subtitle","info":"Introduction to Quick Sort"},
        {"type":"text","info":"The next sorting algorithm we will study is the Quick Sort algorithm. Quick Sort is often known as Partition Sort, and is popular because it is not difficult to implement, works well for a variety of different kinds of input data, and is substantially faster than any other sorting method in typical applications. It is in-place (uses only a small amount of space on the stack),"},
        {"type":"text","info":"The basic algorithm. Quicksort is a divide-and-conquer method for sorting. It works by partitioning an array into two parts, then sorting the parts independently."},
        {"type":"text","info":"Interview Question Example: Partitioning - Given an array of colors where the 0th element is white, and the remaining elements are red (less) or blue (greater), rearrange the array so that all red squares are to the left of the white square, and all blue squares are to the right. "},
        {"type":"text","info":"Relative order of red and blues does NOT need to stay the same!"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/6-1.png') }}"},
        {"type":"text","info":"Here are two potential solutions:"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/6-2.png') }}"},
        {"type":"text","info":"So how do we partition?"},
        {"type":"text","info":"Consider this example:"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/6-3.png') }}"},
        {"type":"text","info":"5 is “in its place.” Exactly where it'd be if the array were sorted."},
        {"type":"text","info":"Can sort two halves separately, e.g. through recursive use of partitioning."},
        {"type":"subtitle","info":"The Importance of Shuffling in Quick Sort"},
        {"type":"text","info":"Later in this course, we will learn about Big-O notation. And we will learn that Quick Sort runs in O(n * lg(n)) time. For now, all you need to understand is that we have the occasional worst-case scenario of O(n2) time. This means that the average run time is usually proportional to n * lg(n), but there is an occasional worst case of n2 time. "},
        {"type":"text","info":"Consider the case where the size of the array (n) is equal to 100. This means the number of operations required to complete the task is proportional to:"},
        {"type":"text","info":"n = 100, n2 = 100*100 = 10,000"},
        {"type":"text","info":"n = 100 n* lg(n) = 100 * 6.643 = 664.3"},
        {"type":"text","info":"The worst case is when the pivot always lands at beginning of array. It turns out that randomly shuffling the array prior to the Quick Sort is a quick way of ensuring that you really do end up with all cases turning up with equal probability, and therefore that this worst case will be as rare as any other case."},
        {"type":"text","info":"We can make this claim because the random shuffle also shuffles all the subarrays uniformly, giving the array the property that its two subarrays are also in random order. This fact is crucial to the algorithm's predictability."},
        {"type":"text","info":"In quick1.c we have implemented a C function, shuffle, which randomly swaps locations in the array to generate a randomly shuffle. "},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec06_Reading/quick1.c"},
        {"type":"text","info":"And here is the output run three separate times to show the effectiveness of the shuffle"},
        {"type":"text","info":"-bash-4.2$ gcc -Wall -Wextra -Wconversion -Wconversion -std=c11 quick1.c -o quick1 "},
        {"type":"text","info":"-bash-4.2$ ./quick1 "},
        {"type":"text","info":"Initial Array 1: 22 13 33 44 -10 55 88 27 "},
        {"type":"text","info":"Shuffled Array 1: -10 55 27 33 22 88 13 44 "},
        {"type":"text","info":"Initial Array 2: 14 99 42 77 2 66 1 8 44 "},
        {"type":"text","info":"Shuffled Array 2: 1 14 42 99 2 77 44 8 66 "},
        {"type":"text","info":"-bash-4.2$ ./quick1 "},
        {"type":"text","info":"Initial Array 1: 22 13 33 44 -10 55 88 27 "},
        {"type":"text","info":"Shuffled Array 1: 33 -10 22 44 27 55 13 88 "},
        {"type":"text","info":"Initial Array 2: 14 99 42 77 2 66 1 8 44 "},
        {"type":"text","info":"Shuffled Array 2: 8 14 99 1 77 42 44 66 2 "},
        {"type":"text","info":"-bash-4.2$ ./quick1 "},
        {"type":"text","info":"Initial Array 1: 22 13 33 44 -10 55 88 27 "},
        {"type":"text","info":"Shuffled Array 1: 44 22 55 88 27 -10 13 33 "},
        {"type":"text","info":"Initial Array 2: 14 99 42 77 2 66 1 8 44 "},
        {"type":"text","info":"Shuffled Array 2: 44 14 99 2 42 1 66 77 8 "},
        {"type":"subtitle","info":"The Partitioning Algorithm"},
        {"type":"text","info":"We will now determine the process of partitioning the array. To start, we set the left most value as the pivot. We then set two iterators i and j. "},
        {"type":"text","info":"We scan left, meaning we move i until either array[i] > array[pivot] OR i == j - 1"},
        {"type":"text","info":"If j != i + 1, then we move j until either array[j] < array[pivot] OR i == j - 1"},
        {"type":"text","info":"We then swap array[i] and array[j] if array[i] > array[j]"},
        {"type":"text","info":"At the end of this iteration, make a final exchange where we swao array[pivot] and array[i]."},
        {"type":"text","info":"Here is an example from the last shuffled. You will see that the all the values to the left of array[i] are less than array[i], and all the elements to the right of array[i] are greater than array[i]. This property means that array[i] is at the correct final location of the sort! We solved the interview question above."},
        {"type":"text","info":"Operation                pivot i  j   array values"},
        {"type":"text","info":"Initial Values           0     1  7   44 14 99 2 42 1 66 77"},
        {"type":"text","info":"Scan left, Scan Right    0     2  5   44 14 99 2 42 1 66 77"},
        {"type":"text","info":"Swap?                    0     2  5   44 14 1 2 42 99 66 77"},
        {"type":"text","info":"Scan left, Scan Right    0     4  3   44 14 1 2 42 99 66 77"},
        {"type":"text","info":"Swap?                    0     4  3   44 14 1 2 42 99 66 77"},
        {"type":"text","info":"Final Exchange           0     4  3   42 14 1 2 44 99 66 77"},
        {"type":"text","info":"Comparison                            42 14 1 2 44 99 66 77"},
        {"type":"subtitle","info":"Recursive Steps"},
        {"type":"text","info":"Now we can recursively call Quick Sort on the subarray to the left of i (0 to i-1) and then on the subarray to the right of i (i+1 to j). In the next set of steps, I show the first left recursive call for indices 0 through 3 on the left."},
        {"type":"text","info":"Note: By randomly shuffling the array, we are more likely to reduce the number of required recursive calls. "},
        {"type":"text","info":"Operation                pivot i  j   array values"},
        {"type":"text","info":"Initial Values           0     1  3   42 14 1 2 44 99 66 77"},
        {"type":"text","info":"Scan left, Scan Right    0     3  2   42 14 1 2 44 99 66 77"},
        {"type":"text","info":"Swap?                    0     3  2   42 14 1 2 44 99 66 77"},
        {"type":"text","info":"Final Exchange           0     3  2   2 14 1 42 44 99 66 77"},
        {"type":"text","info":"Comparison                            2 14 1 42 44 99 66 77"},
        {"type":"text","info":"In the video below, I go through the entire set of steps to solve the presented array."},
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=55256139-838d-4657-b936-ae1b011a6d97&start=0"}

        ]},

    {"unique_id":"3-1","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},
    {"unique_id":"3-2","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},
    {"unique_id":"3-3","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},

    {"unique_id":"4-1","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},
    {"unique_id":"4-2","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},

    {"unique_id":"5-1","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},
    {"unique_id":"5-2","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},
    {"unique_id":"5-3","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},
    {"unique_id":"5-4","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},

    {"unique_id":"6-1","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},
    {"unique_id":"6-2","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},
    {"unique_id":"6-3","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},

    {"unique_id":"7-1","content":[
        {"type":"subtitle","info":"Classes and C++ Friend Operators"},
        {"type":"subtitle","info":"To Data Structures, and Beyond! What exactly is a Programming Paradigm?"},
        {"type":"text","info":"In this lecture, we will review the concepts of C++ Operators, Classes, Inheritance, and Polymorphism. This lecture is designed to reinforce your understanding of how data is structured in a computing device while simultaneously setting you up for success in the Programming Paradigms course. "},
        {"type":"text","info":"A programming paradigm is way to classify programming languages based on their features. In the CSE 30332 course, you will acquire a high-level view of programming language concepts."},
        {"type":"text","info":"In addition to understanding the kinds of problems a language was designed to solve, you need to understand how a language solves these problems."},
        {"type":"text","info":"Think of Paradigms as a breadth-first search approach to studying programming languages"},
        {"type":"text","info":"You can understand the possible paths to solving a problem with a programming language"},
        {"type":"text","info":"But you don't go so far into depth into any one paradigm."},
        {"type":"text","info":"Strengthens your breadth of understanding as a Computer Scientist or Computer Engineer."},
        {"type":"text","info":"Mastering more than one language is often a watershed in the career of a professional programmer. Once a programmer realizes that programming principles transcend the syntax of any specific language, the doors swing open to knowledge that truly makes a difference in quality and productivity."},
        {"type":"text","info":"In the Data Structures course, you've seen the difference in how C and C++ can be used to solve problems"},
        {"type":"text","info":"C is a functional programming language focusing primarily on control the flow of data through the computing structure"},
        {"type":"text","info":"C++ is an object-oriented programming language focusing on relating ideas to computing machine operations"},
        {"type":"text","info":"Python, which is covered in Systems Programming in depth, can be implemented through all four programming paradigms"},
        {"type":"text","info":"Although Python doesn't fully provide the data hiding that C++ and Java perform in classes, so many argue that Python doesn't fully support Object-Oriented Programming"},
        {"type":"text","info":"That being said, C++ and Java don't fully support data hiding either! If you know the base address of the object and perform pointer arithmetic, you can still access the memory on the data heap. "},
        {"type":"text","info":"This actually provides a way for programs to circumvent the private access modifier"},
        {"type":"text","info":"No C++ compiler can prove the absence of such illegal accesses (Known as the pointer aliasing problem)"},
        {"type":"subtitle","info":"C++ Classes vs. C++ Structs"},
        {"type":"text","info":"In C, we learned that we could allocate memory with multiple elements together in a struct. We then learned that, in C++, would could construct and destruct by treating C structs as objects. In order to provide data hiding, we had to explicitly save C++ members and methods privately."},
        {"type":"text","info":"A C++ class is just like a C++ struct except for one key difference:"},
        {"type":"text","info":"In a C++ struct, all members and methods are public by default, and we have to explicitly hide declare members and methods as private"},
        {"type":"text","info":"But you don't go so far into depth into any one paradigm."},
        {"type":"text","info":"In a C++ class, all members and methods are private by default, and we have to explicitly hide declare members and methods as public"},
        {"type":"text","info":"For all the code we've presented from Lectures 11-24, you can replace the keyword \"struct\" with the keyword \"class\", and all the code will compile and run just as well. This is because we employed a data-hiding programming paradigm using C++ structs in the exact same manner as a C++ class. "},
        {"type":"text","info":"We were able to do this because we first learned about memory management and C struct pointers. Then we learned about the this pointer, C++ constructors and destructors, and the encapsulation and the private keyword."},
        {"type":"text","info":"Next, we learned about C++ templates to promote a data structure towards the object-oriented paradigm."},
        {"type":"text","info":"Now we can abstract complexity away a step further by not requiring the this keyword unless we are passing the pointer to the class itself."},
        {"type":"subtitle","info":"CC++ Friend Operators"},
        {"type":"text","info":"We also learned about C++ operators in our implementation of Minimum Spanning Trees where we could compare different objects. But let's say we have a data structure, and instead of wanting to call a print_data() method, we just wanted to print the structure using COUT, just like we would for an integer/float/double:"},
        {"type":"text","info":"RBTree< std::string > the_rbtree;"},
        {"type":"text","info":"the_rbtree.insert( \"Let's\" );"},
        {"type":"text","info":"the_rbtree.insert( \"go\" );"},
        {"type":"text","info":"the_rbtree.insert( \"Irish!\" );"},
        {"type":"text","info":"COUT << \"In-Order Traversal: \" << the_rbtree << \" is here!\" << ENDL;"},
        {"type":"text","info":"Our operator could not just use the Red-Black Tree itself, because we might not always be printing to std::cout. What if we were printing to an output stream or output FILE* pointer?"},
        {"type":"text","info":"In the Object-Oriented Programming paradigm, you must set your code up for success in any situation! This includes the Red-Black Tree being part of a set of outputs in the same line, as we see in the code segment above!"},
        {"type":"text","info":"The solution is a friend operator. The idea behind a friend operator is that you pass both an object and a friend object. In the example below, this operator prints out information for a class Student. You need to pass the student with a call by reference as well as an output stream with a call by reference. "},
        {"type":"text","info":"Since we need to pass the output stream to the next object to be printed, we need to return the std::ostream with a call by reference as well."},
        {"type":"text","info":"The method is able to access the private members of theStudent"},
        {"type":"text","info":"The std::ostream output is the friend of the student"},
        {"type":"text","info":"friend std::ostream& operator<<(std::ostream& output, const Student& theStudent){"},
        {"type":"text","info":"output << \"Student: \" << theStudent.lastName << \", \" << theStudent.firstName;"},
        {"type":"text","info":"output    << \" (\" << theStudent.ndID << \")\" << (char)10;"},
        {"type":"text","info":"output << \"Home Address: \" << theStudent.homeAddress << \"\n\";"},
        {"type":"text","info":"output << \"Class Rank: \" << theStudent.getCLASS() << std::endl;"},
        {"type":"text","info":"output << \"Dorm: \" << theStudent.dorm;"},
        {"type":"text","info":"return output;"},
        {"type":"text","info":"}"},   
        {"type":"subtitle","info":"C++ Inheritance"},                      
        {"type":"subtitle","info":"Object Relationships"},
        {"type":"text","info":"When relating object types, it is helpful to think of them in 3 ways"},
        {"type":"text","info":" 1. \"Uses a\" = An object uses another object by calling a public method of that object."},
        {"type":"text","info":"Example: array[ currentPos ].first"},
        {"type":"text","info":"array is a vector"},
        {"type":"text","info":"[] is an overloaded operator, which is a public method of that object"},
        {"type":"text","info":".first is a public member of a std::pair"},
        {"type":"text","info":" 2. \"Has a\" - Implemented using composition (aggregation)"},
        {"type":"text","info":"Examples:"},
        {"type":"text","info":"A course section has a student list"},  
        {"type":"text","info":"A person has a birth date"},  
        {"type":"text","info":"A movie has a start time"},
        {"type":"text","info":"A library has a book"},
        {"type":"text","info":" 3. \"Is a\" - One object is a more specialized version of another:"},
        {"type":"text","info":"Implemented using inheritance"},
        {"type":"text","info":" A car is a vehicle"},
        {"type":"text","info":"A sorted list is a list"},
        {"type":"text","info":"A student is a person"},
        {"type":"text","info":""},
        {"type":"text","info":"An undergraduate student is a student"},
        {"type":"subtitle","info":"Inheritance and OOP"},
        {"type":"text","info":"More general class: base class (or superclass)."},
        {"type":"text","info":"Specialized classes: a derived class (or subclass)."},
        {"type":"text","info":"Derived classes use, extend, modify, or replace the base class behaviors."},
        {"type":"text","info":"Consider the Notre Dame community. Each \"object\" of the ND community has a unique set of privileges as well as a set of \"is a\" relationships"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/25-1.jpg') }}"},
        {"type":"text","info":"When designing a Base and Derived Class, adhere to the following rules (there are 8 total across Reading 25.2 and 25.3)"},
        {"type":"text","info":"1) Base class requires a destructor with the virtual keyword in the .h file"},
        {"type":"text","info":"virtual function - a member function which is declared within a base class and is re-defined (Overriden) by a derived class"},
        {"type":"text","info":"Use the virtual keyword in class definition (.h file) only"},
        {"type":"text","info":"2) Any private members or methods in the base that you wish for the derived class to have access to should be put under a protected keyword in the base"},
        {"type":"text","info":"Consider the Base Class Irish.h (Links to an external site.) and Irish.cpp (Links to an external site.) shown below. You can see the virtual destructor, even though no private member has an explicitly defined pointer. Furthermore, the members are protected since we plan on using all of them in the derived classes. "},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/25-2.png') }}"},
        {"type":"text","info":"3) In the derived class, the format is class derived : public base"},
        {"type":"text","info":"Example: class Student : public Irish"},
        {"type":"text","info":"4) For private members or methods in the derived class, you only need to add members that are unique to the derived class."},
        {"type":"text","info":"Example: For class Student, no need to include lastName, firstName, ndID, or homeAddress, since they are inherited from Irish"},
        {"type":"text","info":"5) For the constructor, you must use the constructor for the base class as the first argument for the member initialization list"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/25-3.png') }}"},
        {"type":"text","info":"6) The derived class must have a destructor"},
        {"type":"text","info":"Only use the virtual keyword if the derived class is a base class for another class"},
        {"type":"text","info":"7) You must write new friend methods, since the friend method depends on the specific class you are passing to it"},
        {"type":"text","info":"code examples for inheritance:"},
        {"type":"text","info":"Base Class: Irish"},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/include/Irish.h"},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/src/Irish.cpp"},
        {"type":"text","info":"Derived Class:Student"},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/include/Student.h"},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/src/Student.cpp"},
        {"type":"text","info":"Derived Class:Faculty"},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/include/Faculty.h"},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/src/Faculty.cpp"},
        {"type":"text","info":"Test Programs:"},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/src/IrishTest.cpp"},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/src/Inherit.cpp"},
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/src/Inherit2.cpp"},  
                                
        
        {"type":"subtitle","info":"C++ Polymorphism"}, 
        {"type":"text","info":"With Inheritance, we are able to represent the \"is a\" relationship between objects."},     
        {"type":"text","info":"However, each derived class should be able to override base class methods to implement their own version"}, 
        {"type":"text","info":"These derived class methods should have many forms."}, 
        {"type":"text","info":"In Greek, \"many forms\" translates to \"polymorph\""}, 
        {"type":"text","info":"This is why overriding base class methods is known as Polymorphism."}, 
        {"type":"text","info":"Polymorphism"}, 
        {"type":"text","info":"Formal: The ability of a base class to refer transparently to any of its derived classes"}, 
        {"type":"text","info":"Manipulate objects of these classes in a type-independent manner"},               
        {"type":"text","info":"Supported only when we use pointers or references"},
        {"type":"subtitle","info":"Static vs. Dynamic Binding in Polymorphism "},
        {"type":"text","info":"Binding is the process of determine which method in the class hierarchy is to be invoked for a particular object"}, 
        {"type":"text","info":"Static Binding"}, 
        {"type":"text","info":"Compile time"}, 
        {"type":"text","info":"Compiler can determine which method in the class hierarchy to use"}, 
        {"type":"text","info":"Dynamic Binding"}, 
        {"type":"text","info":"Run time"}, 
        {"type":"text","info":"Determination of which method in the class hierarchy occurs during program execution"}, 
        {"type":"subtitle","info":"An Example of Static Binding "},
        {"type":"text","info":"An Example of Static Binding "}, 
        {"type":"text","info":"Time t1;"}, 
        {"type":"text","info":"ExtTime et2;"}, 
        {"type":"text","info":"Statically Bind setTime method"}, 
        {"type":"text","info":"t1.setTime(12, 30, 00);            // static binding"}, 
        {"type":"text","info":"et2.setExtTime(13, 45, 30);    // static binding"}, 
        {"type":"text","info":"Statically Bind printTime methos"},
        {"type":"text","info":"t1.printTime( );         // static binding - Time's printTime( )"},
        {"type":"text","info":"et2.printTime();        // static binding - ExtTime's printTime( )"},
        {"type":"subtitle","info":"Dynamic Binding"},
        {"type":"text","info":"Base class must use the reserved word virtual"}, 
        {"type":"text","info":"We've seen an example already!"}, 
        {"type":"text","info":"Destructors for inherited classes"}, 
        {"type":"text","info":"Virtual Methods"}, 
        {"type":"text","info":"All overriding methods from that point on down the hierarchy are virtual"}, 
        {"type":"text","info":"Even if not explicitly defined to be so"},    
        {"type":"text","info":"We can use a base class with no constructor"},   
        {"type":"subtitle","info":"Arithmetic Trees Example"},
        {"type":"text","info":"In Lecture, we will study in detail an example of dynamic binding where we implement an arithmetic tree."},    
        {"type":"text","info":"This is a form of Advanced Data Structure known as an Abstract Syntax Tree"},  
        {"type":"text","info":"Trees with different types of nodes"},    
        {"type":"text","info":"Let's say we want to perform the task 2 * ( 3+4 ) + 5. We know how much orders of operation are important in mathematics. We also know that coding an advanced problem in C++ would be prohibitively difficult."},  
        {"type":"text","info":"So let's use our knowledge of data structures, inheritance, and polymoprhism to strategically program an approach to developing an arithmetic tree!"},    
        {"type":"image","info":"{{ url_for('static', filename='contentImages/25-4.gif') }}"},
        {"type":"text","info":"We know that there is a difference between the data (the values 2, 3, 4, and 5) and the structure of operations (+ and *). So let's build a class hierarchy of nodes:"},  
        {"type":"image","info":"{{ url_for('static', filename='contentImages/25-5.gif') }}"},
        {"type":"subtitle","info":"The Node Abstract Class"},
        {"type":"text","info":"The Node class is what is known as an abstract class"},
        {"type":"text","info":"Cannot be instantiated, so there is no constructor"},    
        {"type":"text","info":"Calc Virtual Method"},    
        {"type":"text","info":"returns a double as the result of calculating the node's value"},    
        {"type":"text","info":"The calculation may involve the recursive calculations of its children"},    
        {"type":"text","info":"method is const because it doesn't change the node itself"},  
        {"type":"text","info":"no \"default\" implementation of Calc for an arbitrary Node"},    
        {"type":"text","info":"Pure Virual"},  
        {"type":"text","info":"We will set it equal to 0"},   
        {"type":"text","info":"The Node.h file contains the example of this base virtual class."},  
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/include/Node.h"},    
        {"type":"text","info":"class Node"},
        {"type":"text","info":"{"},
        {"type":"text","info":"    public:"},
        {"type":"text","info":"     virtual ~Node () {}"},
        {"type":"text","info":"     virtual double Calc () const = 0;"},
        {"type":"text","info":"};"},  
        {"type":"subtitle","info":"BinNode Class "},
        {"type":"text","info":"In the BinNode.h and BinNode.cpp files, we see an example of Polymorphism."},    
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/include/BinNode.h"},  
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/src/BinNode.cpp"},    
        {"type":"text","info":"We create a constructor to bind two child nodes together. Since we don't if the child nodes will be a "},  
        {"type":"text","info":"All the other node types will derive from the BinNode class, so this will permit creation of the Abstract Syntax Tree"},  
        {"type":"text","info":"We do not need to create a Calc() method since we are not creating another form at this stage."},  
        {"type":"text","info":"All the derived classes will be able to overwrite the virutal method from Node."},  
        {"type":"text","info":"#include \"Node.h\""},

        {"type":"text","info":"class BinNode : public Node"},
        {"type":"text","info":"{"},
        {"type":"text","info":"    protected:"},
        {"type":"text","info":"        Node* leftNode;"},
        {"type":"text","info":"        Node* rightNode;        "},
        {"type":"text","info":"    public:"},
        {"type":"text","info":"        //default constructor"},
        {"type":"text","info":"         BinNode() : leftNode(Lnode), rightNode(Rnode){}"},
        {"type":"text","info":"        // destructor"},
        {"type":"text","info":"         virtual ~BinNode (){"},
        {"type":"text","info":"           delete leftNode;"},
        {"type":"text","info":"            delete rightNode;"},
        {"type":"text","info":"          }"},
        {"type":"text","info":"   };"},
        {"type":"text","info":" "},   
        {"type":"subtitle","info":"NumNode Class "},
        {"type":"text","info":"In the NumNode.h and NumNode.cpp files, we see an example of a derived class that creates its own form of the Calc() method."},    
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/include/NumNode.h"},  
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/src/NumNode.cpp"},    
        {"type":"text","info":"In this case, the NumNode will return its own private member with the value itself:"},  
        {"type":"text","info":"class NumNode : public Node"},  
        {"type":"text","info":" {"},  
        {"type":"text","info":"     protected:"},  
        {"type":"text","info":"         double num;"},  
        {"type":"text","info":"     public:"},  
        {"type":"text","info":"       // Constructor"},  
        {"type":"text","info":"       NumNode(double numIN) : num(numIN){ }"},  
        {"type":"text","info":"       // destructor"},  
        {"type":"text","info":"      virtual ~NumNode () { }    "},  
        {"type":"text","info":"       // overloaded method"},  
        {"type":"text","info":"       double Calc() const{"},  
        {"type":"text","info":"           return this -> num;"},  
        {"type":"text","info":"        }"},  
        {"type":"text","info":" };"},    
        {"type":"subtitle","info":"AddNode Class"},
        {"type":"text","info":"In the AddNode.h and AddNode.cpp files, we see an example of a derived class that creates pointers to two child Nodes. "},    
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/include/AddNode.h"},  
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/src/AddNode.cpp"},    
        {"type":"text","info":"They can be either another BinNode derived class, or a NumNode class."},  
        {"type":"text","info":"Notice how I use the BinNode constructor as the first object in the AddNode constructor"},    
        {"type":"text","info":"The destructor automatically calls the BinNode destructor, so we do not need to try to delete the nodes"},    
        {"type":"text","info":"The polymorphism is evident in the Calc() method"},    
        {"type":"text","info":"class AddNode : public BinNode"},
        {"type":"text","info":"{"},
        {"type":"text","info":"    public:"},
        {"type":"text","info":"      // overload Constructor"},
        {"type":"text","info":"      AddNode(Node* node1, Node* node2) : BinNode(node1,node2){ }"},
        {"type":"text","info":"       // destructor"},
        {"type":"text","info":"        ~AddNode () { }"},
        {"type":"text","info":"       // Function"},
        {"type":"text","info":"       double Calc() const{"},
        {"type":"text","info":"             double val1 = this -> leftNode -> Calc();"},
        {"type":"text","info":"            double val2 = this -> rightNode -> Calc();"},
        {"type":"text","info":"           return val1 + val2;"},
        {"type":"text","info":"      }"},
        {"type":"text","info":"};"},  
        {"type":"subtitle","info":"A Final Note on Polymorphism and Makefiles"},  
        {"type":"text","info":"The remaining classes perform Subtraction, Multiplication, and Division. Here are the remaining files and driver programs, which we will cover in detail in class:"},    
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/include/SubNode.h"},  
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/src/SubNode.cpp"},  
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/include/MultNode.h"},  
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/src/MultNode.cpp"},  
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/include/DivNode.h"},  
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/src/DivNode.cpp"},  
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/src/Polymorph.cpp"},  
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec25_Reading/Makefile"},  
        {"type":"text","info":"Here is the final compilation for the addition, subtraction, multiplication, and division. Note how many files and classes are required, even in this \"simple\" implementation. Imagine having to perform all those operations by hand! This should reinforce the purpose and benefit of Makefiles and File Hierarchies."},    
        {"type":"text","info":"-bash-4.2$ make Polymorph "},
        {"type":"text","info":"g++ -m64 -std=c++11 -Weffc++ -O2 -g -Wall -Wextra -Wconversion -Wshadow -Werror -c src/BinNode.cpp -o objects/BinNode.o "},
        {"type":"text","info":"g++ -m64 -std=c++11 -Weffc++ -O2 -g -Wall -Wextra -Wconversion -Wshadow -Werror -c src/NumNode.cpp -o objects/NumNode.o "},
        {"type":"text","info":"g++ -m64 -std=c++11 -Weffc++ -O2 -g -Wall -Wextra -Wconversion -Wshadow -Werror -c src/AddNode.cpp -o objects/AddNode.o "},
        {"type":"text","info":"g++ -m64 -std=c++11 -Weffc++ -O2 -g -Wall -Wextra -Wconversion -Wshadow -Werror -c src/SubNode.cpp -o objects/SubNode.o "},
        {"type":"text","info":"g++ -m64 -std=c++11 -Weffc++ -O2 -g -Wall -Wextra -Wconversion -Wshadow -Werror -c src/DivNode.cpp -o objects/DivNode.o "},
        {"type":"text","info":"g++ -m64 -std=c++11 -Weffc++ -O2 -g -Wall -Wextra -Wconversion -Wshadow -Werror -c src/MultNode.cpp -o objects/MultNode.o "},
        {"type":"text","info":"g++ -m64 -std=c++11 -Weffc++ -O2 -g -Wall -Wextra -Wconversion -Wshadow -Werror -o exe/Polymorph objects/Polymorph.o objects/BinNode."},
        {"type":"text","info":"o objects/NumNode.o objects/AddNode.o objects/SubNode.o objects/DivNode.o objects/MultNode.o "},
        {"type":"text","info":"-bash-4.2$ exe/./Polymorph"},
        {"type":"text","info":"First Equation: (20.0 - (-10.0) * 0.1)"},
        {"type":"text","info":"Multiplying : -10 + (0.1)"},
        {"type":"text","info":"Adding : 20 and -1"},
        {"type":"text","info":"Result: 19"},
        
        {"type":"text","info":"Second Equation: 5 - (1 / (3 * ( -20 + 6) ) )"},
        {"type":"text","info":"Adding : -20 + (6)"},
        {"type":"text","info":"Multiplying : 3 * -14"},
        {"type":"text","info":"Dividing : 1 / -42"},
        {"type":"text","info":"Subtracting : 5 - -0.0238095"},
        {"type":"text","info":"Result: 5.02381"}]},                    
        
      
        



    {"unique_id":"7-2","content":[
        {"type":"subtitle","info":"Cache Hierarchy"},
        {"type":"subtitle","info":"To Data Structures, and Beyond! How Computers Organize Memory"},
        {"type":"text","info":"When we write programs in a computing machine, because of the way we structure data and the way we compile code, programs tend to access data that forms a physical cluster in memory. This phenomenon is known as the principle of locality."}, 
        {"type":"text","info":"There are two types of locality in a computer:"},    
        {"type":"text","info":"Temporal locality - If an memory element is referenced, it will tend to be referenced again soon"},    
        {"type":"text","info":"Spatial locality - If an memory element is referenced, memory elements who memory addresses are close by will tend to be referenced soon."},    
        {"type":"text","info":"Furthermore, from our studies in storing data, we know we need to store significant amount of memory in a data structure. In Lecture 22, I performed a demonstration of B-Trees of several orders that stored several million elements that passed valgrind. For example:"},    
        {"type":"text","info":"The B-Tree with Order 64 that stored the Wordle dictionary (2,309 std::string elements) required 5,271 allocs, 5,271 frees, and 371,852 bytes allocated"},    
        {"type":"text","info":"The B-Tree with Order 3 that stored 2,500,000 long ints required 16,781,844 allocs, 16,781,844 frees, and 626,522,176 bytes allocated"},    
        {"type":"text","info":"The drawback of B-Trees is that they store elements by their cluster on a disk. While they make searching for specific keys more efficient, they do not efficiently temporal or spatial locality. So what if we could structure temporary memory so that recently accessed elements are easier to find?"},    
        {"type":"text","info":"This is the main idea behind cache memory. Hardware designers split the levels of memory between the processor and disk memory into several levels, each with increasing access speeds."},    
        {"type":"text","info":"The tradeoff is that, the faster the cache memory, the higher the cost"},    
        {"type":"text","info":"Or: In order to get more cache, you need more cash."},    
        {"type":"text","info":"Because of this design tradeoff, the speed and amount of cache are strategically selected to optimize the speed and cost. To understand why this is important, let us run the command lscpu from the UNIX command line. We can see the different levels of cache in the x86_64 architecture we ran the demonstrate on. In the Level 1 cache, you can see the separation into L1d (for Level 1 - Data Heap) and L1i (for Level 1 - Instruction Stack). "},    
        {"type":"text","info":"L1d cache: 32K"},    
        {"type":"text","info":"L1i cache: 32K"},    
        {"type":"text","info":"L2 cache: 256K"},    
        {"type":"text","info":"L3 cache: 20480K"},    
        {"type":"text","info":"We see that the 626,522,176 bytes we required for the B-Tree with 2,500,000 long integers required significantly more memory than all the cache memory we have available. Yet, when I printed the in-order traversal of that B-Tree, it did not take very long at all."},    
        {"type":"text","info":"The closer the data is to the CPU, the more recently it has been accessed."},    
        {"type":"text","info":"So we can say that swapping memory between levels of cache memory is one time-consuming operation that permits an improved average run time."},    
        {"type":"text","info":"Where have we studied that concept before?"},    
        {"type":"image","info":"{{ url_for('static', filename='contentImages/cache.jpeg') }}"}, 
        {"type":"text","info":"That's right! We studied Amortized Analysis in Lecture 14. In Reading 26.2, we will study a specific data structure called a Splay Tree keeps the elements in a sorted order, but \"splays\" the more recently accessed elements to the root of the Binary Search Tree. Consider this quote from the original paper by Daniel Sleator and Robert Tarjan in 1985:"},    
        {"type":"text","info":"\"[Self-balancing Binary Search Trees] are all designed to reduce the worst-case time per operation. However, in typical applications of search trees, not one but a sequence of operations is performed, and what matters is the total time the sequence takes, not the individual times of the operations.\""},    
        
        
        
        {"type":"subtitle","info":"Formally Defining Splay Trees"},    
        {"type":"text","info":"The main idea behind Splay Trees is that the nodes that are most recently access are closer to the top of the tree"},    
        {"type":"text","info":"Getting the element to the top from near the bottom of the tree is the occasional costly operation"},    
        {"type":"text","info":"However, the most recently accessed elements will be near the top."},    
        {"type":"text","info":"By the Principle of Locality, this means those elements are more likely to be accessed."},    
        {"type":"text","info":"So the traversal to the specific data element is lower on the average."},    
        {"type":"text","info":"Which means the average case is good!"},    
        {"type":"subtitle","info":"\"Splaying\" to the Top of the Tree"},    
        {"type":"text","info":"We will implement three rules when accessing an element in a Splay Tree"},    
        {"type":"text","info":"1. Insertion - When inserting an element into a Splay Tree, we will insert into the tree in the sorted order, like a normal Binary Search Tree. Then, we will \"splay\" the element to the top of the tree using the four rules listed below."},    
        {"type":"text","info":"2. Access - Whenever we access an element, we will splay the requested element to the top of the tree using the four rules listed below."},    
        {"type":"text","info":"3. Element not in Tree - If we attempt to access an element, and it is not in the tree, then we \"splay\" the closest element to that requested element to the top of the tree using the four rules listed below."},    
        {"type":"text","info":"Why do you think we would implement the third rule?"},    
        {"type":"text","info":"The reason is that the memory that is closest to the requested element is now at the top of the Splay Tree, so we are preserving the Principle of Locality."},        
        {"type":"subtitle","info":"Four Rules for Rotation Elements to the Top of the Splay Tree"},    
        {"type":"text","info":" Splaying 3 to the top of the tree"},    
        {"type":"text","info":"Rule 1 : Zig (Left of Root) - Splaying 3 to the top of the tree"},    
        {"type":"text","info":"4 becomes 3s right child"},    
        {"type":"text","info":"3s right child becomes 4s left child"},  
        {"type":"image","info":"{{ url_for('static', filename='contentImages/26-1.png') }}"}, 
        {"type":"text","info":"Rule 2 : Zag (Right of Root) - Splaying 5 to the top of the tree"},    
        {"type":"text","info":"4 becomes 5s left child"},    
        {"type":"text","info":"5s left child becomes 4s right child"},  
        {"type":"image","info":"{{ url_for('static', filename='contentImages/26-2.png') }}"}, 
        {"type":"text","info":"Rule 3 : Zig-Zig (Left of Left of Root, or Right of Right of Root)"},    
        {"type":"text","info":"In this example, we are splaying 3 to the top of the tree:"},    
        {"type":"image","info":"{{ url_for('static', filename='contentImages/26-3.png') }}"}, 
        {"type":"text","info":"Just like a Red-Black Tree, we say that"},    
        {"type":"text","info":"3 is the child"},    
        {"type":"text","info":"4 is the parent"},    
        {"type":"text","info":"10 is the grandparent"},    
        {"type":"text","info":"In the Zig-Zig, 3 becomes the new root, 4 becomes the right child of 3, and 10 becomes the new right child of 10."},    
        {"type":"image","info":"{{ url_for('static', filename='contentImages/26-4.png') }}"}, 
        {"type":"text","info":"Rule 4 - Zig-Zag (Left of Right of Root, or Right of Left of Root)"},    
        {"type":"text","info":"In this example, we are splaying 5 to the root:"},    
        {"type":"image","info":"{{ url_for('static', filename='contentImages/26-5.png') }}"}, 
        {"type":"text","info":"First, we make 5 the parent of 4, and then 5's right child becomes the left child of 4 (in this case, NULL)"},    
        {"type":"image","info":"{{ url_for('static', filename='contentImages/26-6.png') }}"}, 
        {"type":"text","info":"Next, we make 5 the root, and make 10 the right child of 5"},    
        {"type":"image","info":"{{ url_for('static', filename='contentImages/26-7.png') }}"},    
        {"type":"subtitle","info":"Example Problem:"},    
        {"type":"text","info":"Given the following insertions and finds, generate the final Splay Tree"},    
        {"type":"text","info":"Insert: 10, 7, 15, 8, 12, 16, 11"},    
        {"type":"text","info":"Find: 8, 13, 10"},    
        {"type":"text","info":"Note: 13 is not in the original Splay Tree. The problem on the Exam will have a similar attempted access"},    
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=3551fa41-cd5c-441a-85eb-ae5700127cdd&start=2.273826"},    
        


        {"type":"subtitle","info":"Visualizing the Benefit of Splay Trees with Caches"},    
        {"type":"text","info":"There are two excellent resources to help you visualize how Splay Trees work"},    
        {"type":"text","info":"University of San Francisco:"},    
        {"type":"code","info":" https://www.cs.usfca.edu/~galles/visualization/SplayTree.html"},    
        {"type":"text","info":"Carnegie Mellon:"},    
        {"type":"code","info":"https://www.link.cs.cmu.edu/splay/"},    
        {"type":"text","info":"The Splay Tree visualization was developed by Prof. Daniel Sleator, who is a co-inventor of Splay Trees. The interesting aspect of this visualization tool is that you can enter a number of elements, and then visualize the Splay of a large tree by clicking on the specific element."},    
        {"type":"text","info":"In the video below, I demonstrate how the Splay Tree can be used to promote memory addresses in a Cache."},    
        {"type":"text","info":"I enter 100 for the initial elements"},    
        {"type":"text","info":"I then focus my selections on 50-59 as the first block"},    
        {"type":"text","info":"After a couple of selections, 50-59 are all near the top of the Splay Tree"},    
        {"type":"text","info":"Next, I focus my selections on 70-79"},    
        {"type":"text","info":"After a couple of selections, 70-79 are near the top"},    
        {"type":"text","info":"You can also see 50-59 and 60-69 are also close to the top of the Splay"},    
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=ee249645-bd47-4778-94c7-ae5601823c0f&start=0"},    

        {"type":"subtitle","info":"Probabilistic Treaps"},    
        {"type":"text","info":"The main idea of a Splay Tree is that the elements that are more likely to be accessed will be closer to the top of the tree, and we use the most recent access to move the elements to the top of the tree."},    
        {"type":"text","info":"But... what if we could knew the priority in advance? We could combine balancing and priority somehow."},    
        {"type":"subtitle","info":"Trade-offs in Sorting Trees and Heaps"},    
        {"type":"text","info":"Based on our study of balancing data structures, let's consider the benefits and drawbacks to each self-balancing structure:"},    
        {"type":"text","info":""},    
        {"type":"subtitle","info":"B-Trees"},    
        {"type":"text","info":"Great for Databases"},    
        {"type":"text","info":"Strict Balancing"},    
        {"type":"text","info":"Good for structuring blocks of data, but not priorities"},    
        {"type":"subtitle","info":"Red-Black Trees"},    
        {"type":"text","info":"Relaxed balancing mechanisms improve on AVL, with a small tradeoff in height"},    
        {"type":"text","info":"Best for uniform access to data"},    
        {"type":"text","info":"Worst-case: When elements near the bottom of the tree have a higher priority"},      
        {"type":"subtitle","info":"Splay Trees"},    
        {"type":"text","info":"Good for amoritized, non-uniform access to the tree"},    
        {"type":"text","info":"Splay occasionally has a worst-case access"},    
        {"type":"subtitle","info":"Heaps and Binomial Heaps"},    
        {"type":"text","info":"Elements with higher priority are closer to the top of the Heaps"},    
        {"type":"text","info":"Not Sorted, so bad for structures that require sorting."},    
        {"type":"subtitle","info":"Ideation: Sort by Value, Heapify by Priority!"},    
        {"type":"text","info":"In the Splay Tree, we insert in order, and then splay the element to the top."},    
        {"type":"text","info":"In our new data structure, which we will call a Treap "},    
        {"type":"text","info":"Nodes are inserted in-order by their keys"},    
        {"type":"text","info":"But then heap-ordered by their priorities!"},    
        {"type":"text","info":"Consider the Treap below:"},    
        {"type":"text","info":"In-order: A, C, D, F, H, I, and J still works!"},    
        {"type":"text","info":"The level order of the tree shows that higher probabilities move up the tree"},    
        {"type":"text","info":"Prob - Level Order: 75, 70, 65, 55, 60, 14, 45"},    
        {"type":"image","info":"{{ url_for('static', filename='contentImages/26-8.png') }}"},        
        {"type":"subtitle","info":"Example Problem:"},    
        {"type":"text","info":"In the video below, we will go through the process of inserting into a Treap. The insertions are performed in the following order, where the input is show in the format {Data, Priority}:"},    
        {"type":"text","info":"{D, 60}, {F, 75}, {H, 14}, {C, 70}, {A, 55}, {I, 65}, {G, 80}"},    
        {"type":"video","info":"https://notredame.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=86342341-e575-45f6-aadc-ae5700298e43&start=0"},    
        {"type":"subtitle","info":"Probabilistic Treap "},    
        {"type":"text","info":"One way we can expand on this idea is to use the Random Number Generator to produce a random priority for each inserted value."},    
        {"type":"text","info":"A particular treap may have bad (or good) worst-case performance."},    
        {"type":"text","info":"But as we randomize the priorities in the treaps over time, we will see that most treaps average out to good worst-case performance overall."},      
        {"type":"subtitle","info":"Comparing the Maximum Height "},    
        {"type":"text","info":"For 100 Random Elements - log2( 100 ) = 6.64385618977 ≈ 7"},    
        {"type":"subtitle","info":"Binary Search Tree and Splay"},    
        {"type":"text","info":"Best case - 7"},    
        {"type":"text","info":"Requires traversing through 7 nodes to get to any leaf"},    
        {"type":"text","info":"Worst case - 100"},    
        {"type":"text","info":"Requires traversing through all 100 nodes to get to the leaf"},    
        {"type":"subtitle","info":"AVL Trees"},    
        {"type":"text","info":"Worst case height is 7"},    
        {"type":"subtitle","info":"Red Black Tree"},    
        {"type":"text","info":"Best case height - 7"},    
        {"type":"text","info":"2 * lg(100) + 1 = 14.28 => Worst case max height is 15"},    
        {"type":"subtitle","info":"Probabilistic Treaps"},    
        {"type":"text","info":"Given the height of the Treap with n nodes being h before an insert, the higher the probability, the more likely to be raised in the Treap."},    
        {"type":"text","info":"My presented Probabilistic Treap in C++, which you may view online, we well as its test driver program InsertRandom.cpp"},    
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec26_Reading/include/TreapNode.h"},    
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec26_Reading/include/Treap.h"},    
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec26_Reading/src/InsertRandom.cpp"},    
        {"type":"text","info":"To experiment, I ran 100 random inserts on a Probabilistic Treap 1,000,000 times and combined the statistics. You may view the code InsertRandom2.cpp"},    
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec26_Reading/src/InsertRandom2.cpp"},    
        {"type":"text","info":"Here are my results"},    
        {"type":"text","info":"The average was a height of 11.654"},    
        {"type":"text","info":"This result was remarkably consistent across dozens of runs."},    
        {"type":"text","info":"This is almost exactly equal to 3/2*lg(100)+1"},    
        {"type":"text","info":"Here is the output run for the 1,000,000 instance test:"},    
        {"type":"image","info":"{{ url_for('static', filename='contentImages/26-9.png') }}"},        
        {"type":"subtitle","info":"Probabilistic Treap in C++,"},    
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec26_Reading/include/TreapNode.h"},    
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec26_Reading/include/Treap.h"},    
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec26_Reading/src/InsertRandom.cpp"},    
        {"type":"code","info":"https://github.com/mmorri22/sp22-cse-20312/blob/main/Lec26_Reading/src/InsertRandom2.cpp"}      
        ]},



    {"unique_id":"7-3","content":[
        {"type":"subtitle","info":"Introduction to Data Compression"},
        {"type":"subtitle","info":"To Data Structures and Beyond! Data Management"},
        {"type":"text","info":"Every day, humans create a mind-blowing amount of data. Here are some examples for daily creation of data in 2022:"},
        {"type":"text","info":"900 million Tweets"},
        {"type":"text","info":"8 billion Google Searches"},
        {"type":"text","info":"376.4 billion emails"},
        {"type":"text","info":"720,000 hours of YouTube video"},
        {"type":"text","info":"Now that you have learned intuitively that data must actually be structured on a computer, you now understand the challenge that all this data must have a location to be stored!"},
        {"type":"text","info":"Companies like Google, Facebook, Amazon, TikTok, ect., are creating massive data stores"},
        {"type":"text","info":"These data stores require significant energy in order to maintain."},
        {"type":"text","info":"Google used about 15.439 gigawatt-hours of electricity in 2020"},
        {"type":"text","info":"That is about the amount of energy consumed by the entire Dominican Republic"},
        {"type":"text","info":"The more data that needs to be saved, the more energy it requires"},
        {"type":"text","info":"Going back to Makefiles and Git: This underlies the importance of running make clean before pushing to GitHub."},
        {"type":"subtitle","info":"Data Compression"},
        {"type":"text","info":"While companies are looking for ways to keep the power down or use renewable resources, there is another approach: what if we can represent the same amount of information while consuming less memory?"},
        {"type":"text","info":"We took our first crack at this idea when we implemented Tries."},
        {"type":"text","info":"We also managed to significantly reduce the amount of memory we required to save information in a Bloom Filter, albeit with a tradeoff in accuracy."},
        {"type":"text","info":"The goal of a compression algorithm is to find short sequences of bits or characters that generate desired longer sequences of bits. You see examples of Data Compression algorithms and applications every time you open your laptop!"},
        {"type":"text","info":"Generic file compression."},
        {"type":"text","info":"Files: Gzip, bzip2, 7z, PKZIP"},
        {"type":"text","info":"File systems: ZFS, HFS+, ReFS, GFS, APFS"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/27-1.png') }}"},        
        {"type":"text","info":"Multimedia."},
        {"type":"text","info":"Images: GIF, JPEG, PNG, RAW, ...."},
        {"type":"text","info":"Sound: MP3, AAC, Ogg Vorbis, ...."},
        {"type":"text","info":"Video: MP4, HDTV, H.264, HEVC, .... "},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/27-2.png') }}"},        
        {"type":"text","info":"Communication. Fax, Skype, WeChat, Zoom, ...."},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/27-3.png') }}"},        
        {"type":"text","info":"Databases. SQL, Google, Facebook, NSA, …."},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/27-4.png') }}"},        
        {"type":"text","info":"Smart sensors. Phone, watch, car, health, …."},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/27-5.png') }}"},        
        {"type":"subtitle","info":"Data Compression Algorithms Preview: \"Rdenudcany in Enlgsih lnagugae\""},
        {"type":"text","info":"There is quite a bit of redundancy in the English language. We can leverage this property to reduce the amount of data required to represent sentences, code, ect. while the final compressed string represents the exact same text:"},
        {"type":"text","info":"“ ... randomizing letters in the middle of words [has] little or no effect on the ability of skilled readers to understand the text. This is easy to denmtrasote.  In a pubiltacion of New Scnieitst you could ramdinose all the letetrs, keipeng the first two and last two the same, and reibadailty would hadrly be aftcfeed. ” — Graham Rawlinson"},
        {"type":"text","info":"Compression and expansion "},
        {"type":"text","info":"Message. Bitstream B we want to compress."},
        {"type":"text","info":"Compress. Generates a “compressed” representation C(B)."},
        {"type":"text","info":"Expand. Reconstructs original bitstream B."},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/27-6.png') }}"},        
        {"type":"text","info":"Simple Example: DNA Genomic Code"},
        {"type":"text","info":"Genome. String over the alphabet { A, T, C, G }."},
        {"type":"text","info":"Goal. Encode an n-character genome: ATAGATGCATAG"},
        {"type":"text","info":"Since there are only 4 characters, why use ASCII?"},
        {"type":"text","info":"ASCII characters require 8 characters each"},
        {"type":"text","info":"But since there are four choices, we can reduce to 2 bits for each"},
        {"type":"text","info":"Say we make A = 00, T = 01, C = 10, and G = 11"},
        {"type":"text","info":"Consider this example: ATAGATGCATAG"},
        {"type":"text","info":"In ASCII       : 010000010101010001000001010001110100000101010100010001110100001101000001010101000100000101000111"},
        {"type":"text","info":"Compressed: 000100110001111000010011"},
        {"type":"text","info":"We reduced the size by 75 percent! Considering the human genome has 3.2 billion base pairs"},
        {"type":"text","info":"Before: required 3.2 megabytes to represent one DNA strand"},
        {"type":"text","info":"After: required 800 kilobytes to represent one DNA strand"},
        {"type":"text","info":"Run-length encoding (RLE) "},
        {"type":"text","info":"RLE is a form of lossless data compression in which runs of data (sequences in which the same data value occurs in many consecutive data elements) are stored as a single data value and count, rather than as the original run."},
        {"type":"text","info":"Long runs of repeated bits"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/27-7.png') }}"},        
        {"type":"text","info":"Representation - 4-bit counts to represent alternating runs of 0s and 1s:"},
        {"type":"text","info":"15 0s, then 7 1s, then 7 0s, then 11 1s."},
        {"type":"text","info":"1111 0111 0111 1011"},
        {"type":"text","info":"Reduction from a length of 40 bits to 16 bits"},
        {"type":"text","info":"So what is the compression ratio?"},
        {"type":"text","info":"4^2 = 16"},
        {"type":"text","info":"The run length can go from 0 to 15"},
        {"type":"text","info":" - 0000"},
        {"type":"text","info":" 0 - 0001"},
        {"type":"text","info":" 00 - 0010"},
        {"type":"text","info":" 000 - 0011"},
        {"type":"text","info":" 0000 - 0100"},
        {"type":"text","info":" 00000 - 0101"},
        {"type":"text","info":" 000000 - 0110"},
        {"type":"text","info":" 0000000 - 0111"},
        {"type":"text","info":" 00000000 - 1000"},
        {"type":"text","info":" 000000000 - 1001"},
        {"type":"text","info":" 0000000000 - 1010"},
        {"type":"text","info":" 00000000000 - 1011"},
        {"type":"text","info":" 000000000000 - 1100"},
        {"type":"text","info":" 0000000000000 - 1101"},
        {"type":"text","info":" 00000000000000 - 1110"},
        {"type":"text","info":" 000000000000000 - 1111"},
        {"type":"text","info":"So what is the average compression ration?"},
        {"type":"text","info":"Sum of 0 to 15, 16 values"},
        {"type":"text","info":"( n * n - 1 ) / 2 = 16*15 / 2 = 120"},
        {"type":"text","info":"Each of the compressed values is 4 bits"},
        {"type":"text","info":"16 * 4 = 64"},
        {"type":"text","info":"Therefore, the average compression ratio is 64/120"},
        {"type":"text","info":"Example Problem: Given a run-length encoding scheme of 8-bits, what is the average compression ratio"},
        {"type":"text","info":"n^2 = 64 bits"},
        {"type":"text","info":"Sum of 0 to 63, 64 values"},
        {"type":"text","info":"( n * n - 1 ) / 2 = 64*63 / 2 = 2016"},
        {"type":"text","info":"Each of the compressed values is 8 bits"},
        {"type":"text","info":"64 * 8 = 512"},
        {"type":"text","info":"Therefore, the average compression ratio is 512/2016, which reduces to 16/63"},
        {"type":"text","info":"Advantages and Disadvantages"},
        {"type":"text","info":"RLE is most efficient on data that contains many such runs, for example, simple graphic images such as icons, line drawings, Conway's Game of Life, and animations."},
        
   
        {"type":"subtitle","info":"Huffman Encoding"},
        {"type":"text","info":"We can compress the string if we use a variable-length code where codewords may have different lengths."},
        {"type":"text","info":"Give short codewords for characters that appear often and long codewords for characters that appear rarely."},
        {"type":"text","info":"For example, let's say we have the following string: AABACDACA"},
        {"type":"text","info":"A fixed length encoding would try to reduce to:"},
        {"type":"text","info":"A = 00, B = 01, C = 10, D = 11"},
        {"type":"text","info":"The ASCII representation is 72 bits"},
        {"type":"text","info":"The fixed length encoding is now 18 bits: 000001001011001000"},
        {"type":"text","info":"But let's now consider the number of instances:"},
        {"type":"text","info":"The count is A = 5, B = 1, C = 2, and D = 1"},
        {"type":"text","info":"Let's say that we make each string unique in that we get to 0 and then stop the character. This approach ensures that no codeword is a prefix of another codeword, which prevents ambiguity"},
        {"type":"text","info":"it is not allowed that a code would contain both codewords 10 and 1011. "},
        {"type":"text","info":"Can't tell if the 10 is the beginning of 1011 or the entire string of 10!"},
        {"type":"text","info":"However, since specific strings are prefixes of other characters, radio operators had to leave a space between each character so that the receiver of the message knew how to interpret the characters."},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/28-1.png') }}"},        
        {"type":"subtitle","info":"Huffman Coding"},
        {"type":"text","info":"Huffman coding is a greedy algorithm that constructs an optimal code for compressing a given string. The algorithm builds a binary tree based on the frequencies of the characters in the string, and each character's codeword can be read by following a path from the root to the corresponding node. A move to the left corresponds to bit 0, and a move to the right corresponds to bit 1."},
        {"type":"text","info":"Initially, each character of the string is represented by a node whose weight is the number of times the character occurs in the string. Then at each step two nodes with minimum weights are combined by creating a new node whose weight is the sum of the weights of the original nodes. The process continues until all nodes have been combined."},
        {"type":"text","info":"Next we will see how Huffman coding creates the optimal code for the string AABACDACA. The node that represents character A has weight 5 because character A appears 5 times in the string. The other weights have been calculated in the same way. In a tie, we sort by alphabetical order:"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/28-2.png') }}"},        
        {"type":"text","info":"The next step is to combine the nodes that correspond to characters B and D, both with weight 1. The result is:"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/28-3.png') }}"},        
        {"type":"text","info":"After this, the nodes with weight 2 are combined: "},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/28-4.png') }}"},        
        {"type":"text","info":"Finally, the two remaining nodes are combined:"},
        {"type":"image","info":"{{ url_for('static', filename='contentImages/28-5.png') }}"},        
        {"type":"text","info":"Now all nodes are in the tree, so the code is ready. The following codewords can be read from the tree:"},
        {"type":"text","info":"A = 0"},
        {"type":"text","info":"C = 10"},
        {"type":"text","info":"B = 110"},
        {"type":"text","info":"D = 111"},
        {"type":"text","info":"Now we can reduce AABACDACA:"},
        {"type":"text","info":"001100101110100, which is now 15 bits"},
        {"type":"subtitle","info":"Two possible philosophies for using Huffman Compression:"},
        {"type":"text","info":"1. For each input type (English text, Chinese text, images, Java source code, etc.), assemble huge numbers of sample inputs for that category. Use each corpus to create a standard code for English, Chinese, etc."},
        {"type":"text","info":"Will result in suboptimal encoding for specific input strings"},
        {"type":"text","info":"2. For every possible input file, create a unique code just for that file. Send the code along with the compressed file."},
        {"type":"text","info":"Requires you to use extra space for the codeword table in the compressed bitstream"},
        {"type":"text","info":"demonstrate your understanding of Huffman Encoding by building the tree, which is the second philosophy. This approach is also the philosophy used in the real world."}
        
        
        ]},


    {"unique_id":"7-4","content":[
        {"type":"text","info":"EXAMPLE PARAGRAPH"},
        {"type":"image","info":"link to image"}
        ]},

    {"unique_id":"8-1","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},
    {"unique_id":"8-2","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},
    {"unique_id":"8-3","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]},
    {"unique_id":"8-4","content":[{"type":"text","info":"EXAMPLE PARAGRAPH"},{"type":"image","info":"link to image"}]}

]



